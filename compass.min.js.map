{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/cp","compass.js","node_modules/clusterfck/lib/clusterfck.js","node_modules/clusterfck/lib/distance.js","node_modules/clusterfck/lib/hcluster.js","node_modules/clusterfck/lib/kmeans.js","src/cluster/cluster.js","src/cluster/clusterconsts.js","src/cluster/distance.js","src/consts.js","src/gen/aggregates.js","src/gen/encodings.js","src/gen/encs.js","src/gen/gen.js","src/gen/marktypes.js","src/gen/projections.js","src/globals.js","src/rank/rank.js","src/rank/rankEncodings.js","src/util.js"],"names":["e","exports","module","define","amd","f","window","global","self","cp","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"consts","cluster","gen","rank","util","auto","./cluster/cluster","./consts","./gen/gen","./rank/rank","./util",2,"hcluster","Kmeans","kmeans","./hcluster","./kmeans",3,"euclidean","v1","v2","total","Math","pow","sqrt","manhattan","abs","max",4,"distances","HierarchicalClustering","distance","linkage","threshold","this","undefined","Infinity","prototype","items","snapshotPeriod","snapshotCb","clusters","dists","mins","index","value","key","size","j","dist","merged","mergeClosest","forEach","minKey","min","c1","c2","left","right","splice","ci","key1","key2","snapshot","snapshotCallback","./distance",5,"KMeans","centroids","randomCentroids","points","k","slice","sort","round","random","classify","point","ceil","assignment","Array","iterations","movement","assigned","push","centroid","newCentroid","g","sum","toJSON","JSON","stringify","fromJSON","json","parse","vectors",6,"encodings","opt","table","clusterTrees","clusterfck","e1","e2","s1","vl","Encoding","shorthand","s2","CLUSTER_THRESHOLD","map","tree","traverse","encoding1","encoding2","score","filter","cluster1","cluster2","../util","./clusterconsts",7,"reduceTupleToTable","x","b","d","c","SWAPPABLE","DIST_MISSING","DIST_BY_ENCTYPE","reduce",8,"len","colencs","getEncTypeByColumnName","shorthands","diff","sj","si","get","colenc1","colenc2","cols","union","keys","col","encType","isStack1","isStack","isStack2","enc","color","name","encoding","_colenc","duplicate","marktype",9,"projections","type","properties","omitDotPlot","default","description","maxCardinalityForAutoAddOrdinal","alwaysAddHistogram","aggregates","config","data","tableTypes","enum","genDimQ","minCardinalityForBin","omitMeasureOnly","omitDimensionOnly","addCountForDimensionOnly","aggrList","timeFnList","consistentAutoQ","marktypeList","encodingTypeList","maxGoodCardinalityForFacets","maxCardinalityForFacets","maxGoodCardinalityForColor","maxCardinalityForColor","maxCardinalityForShape","omitTranpose","omitDotPlotWithExtraEncoding","omitMultipleRetinalEncodings","omitNonTextAggrWithAllDimsOnFacets","omitSizeOnBar","omitStackedAverage","alwaysGenerateTableAsHeatmap",10,"genAggregates","output","fields","stats","emit","fieldSet","field","checkAndPush","hasMeasure","hasDimension","hasRaw","tf","isDimension","aggr","count","pop","assignAggrQ","hasAggr","autoMode","canHaveAggr","cantHaveAggr","assignField","assignBinQ","bin","assignQ","_aggr","_raw","_bin","ANY","isin","hasO","highCardinality","cardinality","isAuto","genBin","genCast","assignFnT","fn","assignT","_fn","schema","extend","any","../consts",11,"genEncodingsFromFields","nested","encs","genEncs","dict","genEncodingsFromEncs","list","getMarktypes","markType","finalTouch","scoreFeatures","features","text","et","isMeasure","isCount","stat","stdev","avg","scale","zero","../rank/rank","./encs","./marktypes",12,"retinalEncRules","shape","alpha","colorRules","shapeRules","dimMeaTransposeRule","y","generalRules","genMarkTypes","satisfyRules","geo","arc","row","isAggrWithAllDimOnFacets","isDimX","isDimY","isAggregate","tmpEnc","isDim","rules","dimension","measure","multiple","detail","hasOtherO","../globals",13,"marktypes","charts","cfg","flat","getOpt","fieldSets","genAggr","level","nestedReduce","nestedMap","./aggregates","./encodings","./projections",14,"markTypes","vlmarktypes","facetRule","facetsRule","pointRule","xIsDim","yIsDim","tickRule","isOrdinalScale","barRule","lineRule","areaRule","textRule","marksRule","rule","bar","line","area","tick","mark","compile","marks","reqs","requiredEncoding","support","supportedEncoding",15,"selected","fieldsToAdd","hasSelectedDimension","hasSelectedMeasure","indices","compareFieldsToAdd","setsToAdd","chooseKorLess","setToAdd","concat","typeIsMeasureScore","O","T","Q","projection","join",16,"CHART_TYPES","TABLE","BAR","PLOT","LINE","AREA","MAP","HISTOGRAM","ANY_DATA_TYPES",17,"./rankEncodings",18,"rankEncodings","encTypes","encodingMappingByField","mappings","reasons","m","assign","scores","role","reason","apply","UNUSED_POSITION","MARK_SCORE","p","circle","square","D","M","BAD","TERRIBLE","minor","pos","Y_T","facet_text","facet_good","facet_ok","facet_bad","color_good","color_ok","color_bad","color_stack","bad","terrible","dimensionScore","hasOrder","isStacked","measureScore",19,"isArray","obj","toString","sp","v","nonEmpty","grp","node","arr","Object","create","DEFAULT_OPT","powerset","ps","subset","sub","chooseK","kArray","cross"],"mappings":"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","file":"compass.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = {\n  consts: require('./consts'),\n  cluster: require('./cluster/cluster'),\n  gen: require('./gen/gen'),\n  rank: require('./rank/rank'),\n  util: require('./util'),\n  auto: \"-, sum\"\n};\n\n\n","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.cp=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = {\n  consts: require('./consts'),\n  cluster: require('./cluster/cluster'),\n  gen: require('./gen/gen'),\n  rank: require('./rank/rank'),\n  util: require('./util'),\n  auto: \"-, sum\"\n};\n\n\n\n},{\"./cluster/cluster\":6,\"./consts\":9,\"./gen/gen\":13,\"./rank/rank\":17,\"./util\":19}],2:[function(require,module,exports){\nmodule.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};\n},{\"./hcluster\":4,\"./kmeans\":5}],3:[function(require,module,exports){\nmodule.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};\n},{}],4:[function(require,module,exports){\nvar distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n\n},{\"./distance\":3}],5:[function(require,module,exports){\nvar distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}\n},{\"./distance\":3}],6:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nmodule.exports = cluster;\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  clusterfck = require('clusterfck'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\ncluster.distance = require('./distance');\n\nfunction cluster(encodings, opt) {\n  // jshint unused:false\n  var dist = cluster.distance.table(encodings);\n\n  var clusterTrees = clusterfck.hcluster(encodings, function(e1, e2) {\n    var s1 = vl.Encoding.shorthand(e1),\n      s2 = vl.Encoding.shorthand(e2);\n    return dist[s1][s2];\n  }, 'average', consts.CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n      return util.traverse(tree, []);\n    })\n   .map(function(cluster) {\n    return cluster.sort(function(encoding1, encoding2) {\n      // sort each cluster -- have the highest score as 1st item\n      return encoding2.score - encoding1.score;\n    });\n  }).filter(function(cluster) {  // filter empty cluster\n    return cluster.length >0;\n  }).sort(function(cluster1, cluster2) {\n    //sort by highest scoring item in each cluster\n    return cluster2[0].score - cluster1[0].score;\n  });\n\n  clusters.dist = dist; //append dist in the array for debugging\n\n  return clusters;\n}\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../util\":19,\"./clusterconsts\":7,\"./distance\":8,\"clusterfck\":2}],7:[function(require,module,exports){\n'use strict';\n\nvar c = module.exports = {};\n\nc.SWAPPABLE = 0.05;\nc.DIST_MISSING = 1;\nc.CLUSTER_THRESHOLD = 1;\n\nfunction reduceTupleToTable(r, x) {\n  var a = x[0], b = x[1], d = x[2];\n  r[a] = r[a] || {};\n  r[b] = r[b] || {};\n  r[a][b] = r[b][a] = d;\n  return r;\n}\n\nc.DIST_BY_ENCTYPE = [\n  // positional\n  ['x', 'y', c.SWAPPABLE],\n  ['row', 'col', c.SWAPPABLE],\n\n  // ordinal mark properties\n  ['color', 'shape', c.SWAPPABLE],\n  ['color', 'detail', c.SWAPPABLE],\n  ['detail', 'shape', c.SWAPPABLE],\n\n  // quantitative mark properties\n  ['color', 'alpha', c.SWAPPABLE],\n  ['size', 'alpha', c.SWAPPABLE],\n  ['size', 'color', c.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n\n},{}],8:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\nvar distance = {};\nmodule.exports = distance;\n\ndistance.table = function (encodings) {\n  var len = encodings.length,\n    colencs = encodings.map(function(e) { return distance.getEncTypeByColumnName(e); }),\n    shorthands = encodings.map(vl.Encoding.shorthand),\n    diff = {}, i, j;\n\n  for (i = 0; i < len; i++) diff[shorthands[i]] = {};\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      var sj = shorthands[j], si = shorthands[i];\n\n      diff[sj][si] = diff[si][sj] = distance.get(colencs[i], colencs[j]);\n    }\n  }\n  return diff;\n};\n\ndistance.get = function (colenc1, colenc2) {\n  var cols = util.union(vl.keys(colenc1.col), vl.keys(colenc2.col)),\n    dist = 0;\n\n  cols.forEach(function(col) {\n    var e1 = colenc1.col[col], e2 = colenc2.col[col];\n\n    if (e1 && e2) {\n      if (e1.encType != e2.encType) {\n        dist += (consts.DIST_BY_ENCTYPE[e1.encType] || {})[e2.encType] || 1;\n      }\n    } else {\n      dist += consts.DIST_MISSING;\n    }\n  });\n\n  // do not group stacked chart with similar non-stacked chart!\n  var isStack1 = vl.Encoding.isStack(colenc1),\n    isStack2 = vl.Encoding.isStack(colenc2);\n\n  if(isStack1 || isStack2) {\n    if(isStack1 && isStack2) {\n      if(colenc1.enc.color.name !== colenc2.enc.color.name) {\n        dist+=1;\n      }\n    } else {\n      dist+=1; // surely different\n    }\n  }\n  return dist;\n};\n\n// get encoding type by fieldname\ndistance.getEncTypeByColumnName = function(encoding) {\n  var _colenc = {},\n    enc = encoding.enc;\n\n  vl.keys(enc).forEach(function(encType) {\n    var e = vl.duplicate(enc[encType]);\n    e.encType = encType;\n    _colenc[e.name || ''] = e;\n    delete e.name;\n  });\n\n  return {\n    marktype: encoding.marktype,\n    col: _colenc,\n    enc: encoding.enc\n  };\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../util\":19,\"./clusterconsts\":7}],9:[function(require,module,exports){\n'use strict';\n\nvar consts = module.exports = {\n  gen: {},\n  cluster: {},\n  rank: {}\n};\n\nconsts.gen.projections = {\n  type: 'object',\n  properties: {\n    omitDotPlot: { //FIXME remove this!\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    maxCardinalityForAutoAddOrdinal: {\n      type: 'integer',\n      default: 50,\n      description: 'max cardinality for ordinal field to be considered for auto adding'\n    },\n    alwaysAddHistogram: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nconsts.gen.aggregates = {\n  type: 'object',\n  properties: {\n    config: {\n      type: 'object'\n    },\n    data: {\n      type: 'object'\n    },\n    tableTypes: {\n      type: 'boolean',\n      default: 'both',\n      enum: ['both', 'aggregated', 'disaggregated']\n    },\n    genDimQ: {\n      type: 'string',\n      default: 'auto',\n      enum: ['auto', 'bin', 'cast', 'none'],\n      description: 'Use Q as Dimension either by binning or casting'\n    },\n    minCardinalityForBin: {\n      type: 'integer',\n      default: 20,\n      description: 'minimum cardinality of a field if we were to bin'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitMeasureOnly: {\n      type: 'boolean',\n      default: false,\n      description: 'Omit aggregation with measure(s) only'\n    },\n    omitDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Omit aggregation with dimension(s) only'\n    },\n    addCountForDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Add count when there are dimension(s) only'\n    },\n    aggrList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: [undefined, 'avg']\n    },\n    timeFnList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: ['year']\n    },\n    consistentAutoQ: {\n      type: 'boolean',\n      default: true,\n      description: \"generate similar auto transform for quant\"\n    }\n  }\n};\n\nconsts.gen.encodings = {\n  type: 'object',\n  properties: {\n    marktypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['point', 'bar', 'line', 'area', 'text', 'tick'], //filled_map\n      description: 'allowed marktypes'\n    },\n    encodingTypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['x', 'y', 'row', 'col', 'size', 'color', 'text', 'detail'],\n      description: 'allowed encoding types'\n    },\n    maxGoodCardinalityForFacets: {\n      type: 'integer',\n      default: 5,\n      description: 'maximum cardinality of a field to be put on facet (row/col) effectively'\n    },\n    maxCardinalityForFacets: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of a field to be put on facet (row/col)'\n    },\n    maxGoodCardinalityForColor: {\n      type: 'integer',\n      default: 7,\n      description: 'maximum cardinality of an ordinal field to be put on color effectively'\n    },\n    maxCardinalityForColor: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal field to be put on color'\n    },\n    maxCardinalityForShape: {\n      type: 'integer',\n      default: 6,\n      description: 'maximum cardinality of an ordinal field to be put on shape'\n    },\n    omitTranpose:  {\n      type: 'boolean',\n      default: true,\n      description: 'Eliminate all transpose by (1) keeping horizontal dot plot only (2) for OxQ charts, always put O on Y (3) show only one DxD, MxM (currently sorted by name)'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitDotPlotWithExtraEncoding: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all dot plots with >1 encoding'\n    },\n    omitMultipleRetinalEncodings: {\n      type: 'boolean',\n      default: true,\n      description: 'omit using multiple retinal variables (size, color, alpha, shape)'\n    },\n    omitNonTextAggrWithAllDimsOnFacets: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all aggregated charts (except text tables) with all dims on facets (row, col)'\n    },\n    omitSizeOnBar: {\n      type: 'boolean',\n      default: false,\n      description: 'do not use bar\\'s size'\n    },\n    omitStackedAverage: {\n      type: 'boolean',\n      default: true,\n      description: 'do not stack bar chart with average'\n    },\n    alwaysGenerateTableAsHeatmap: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\n\n\n\n},{}],10:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null);\n\nvar consts = require('../consts');\n\nvar ANY='*';\n\nmodule.exports = genAggregates;\n\nfunction genAggregates(output, fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.aggregates);\n  var tf = new Array(fields.length);\n  var hasO = vl.any(fields, function(f) {\n    return f.type === 'O';\n  });\n\n  function emit(fieldSet) {\n    fieldSet = vl.duplicate(fieldSet);\n    fieldSet.key = vl.field.shorthands(fieldSet);\n    output.push(fieldSet);\n  }\n\n  function checkAndPush() {\n    if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n      var hasMeasure = false, hasDimension = false, hasRaw = false;\n      tf.forEach(function(f) {\n        if (vl.field.isDimension(f)) {\n          hasDimension = true;\n        } else {\n          hasMeasure = true;\n          if (!f.aggr) hasRaw = true;\n        }\n      });\n      if (!hasDimension && !hasRaw && opt.omitMeasureOnly) return;\n      if (!hasMeasure) {\n        if (opt.addCountForDimensionOnly) {\n          tf.push(vl.field.count());\n          emit(tf);\n          tf.pop();\n        }\n        if (opt.omitDimensionOnly) return;\n      }\n    }\n    if (opt.omitDotPlot && tf.length === 1) return;\n    emit(tf);\n  }\n\n  function assignAggrQ(i, hasAggr, autoMode, a) {\n    var canHaveAggr = hasAggr === true || hasAggr === null,\n      cantHaveAggr = hasAggr === false || hasAggr === null;\n    if (a) {\n      if (canHaveAggr) {\n        tf[i].aggr = a;\n        assignField(i + 1, true, autoMode);\n        delete tf[i].aggr;\n      }\n    } else { // if(a === undefined)\n      if (cantHaveAggr) {\n        assignField(i + 1, false, autoMode);\n      }\n    }\n  }\n\n  function assignBinQ(i, hasAggr, autoMode) {\n    tf[i].bin = true;\n    assignField(i + 1, hasAggr, autoMode);\n    delete tf[i].bin;\n  }\n\n  function assignQ(i, hasAggr, autoMode) {\n    var f = fields[i],\n      canHaveAggr = hasAggr === true || hasAggr === null;\n\n    tf[i] = {name: f.name, type: f.type};\n\n    if (f.aggr === 'count') { // if count is included in the selected fields\n      if (canHaveAggr) {\n        tf[i].aggr = f.aggr;\n        assignField(i + 1, true, autoMode);\n      }\n    } else if (f._aggr) {\n      // TODO support array of f._aggrs too\n      assignAggrQ(i, hasAggr, autoMode, f._aggr);\n    } else if (f._raw) {\n      assignAggrQ(i, hasAggr, autoMode, undefined);\n    } else if (f._bin) {\n      assignBinQ(i, hasAggr, autoMode);\n    } else {\n      opt.aggrList.forEach(function(a) {\n        if (!opt.consistentAutoQ || autoMode === ANY || autoMode === a) {\n          assignAggrQ(i, hasAggr, a /*assign autoMode*/, a);\n        }\n      });\n\n      if ((!opt.consistentAutoQ || vl.isin(autoMode, [ANY, 'bin', 'cast', 'autocast'])) && !hasO) {\n        var highCardinality = vl.field.cardinality(f, stats) > opt.minCardinalityForBin;\n\n        var isAuto = opt.genDimQ === 'auto',\n          genBin = opt.genDimQ  === 'bin' || (isAuto && highCardinality),\n          genCast = opt.genDimQ === 'cast' || (isAuto && !highCardinality);\n\n        if (genBin && vl.isin(autoMode, [ANY, 'bin', 'autocast'])) {\n          assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n        }\n        if (genCast && vl.isin(autoMode, [ANY, 'cast', 'autocast'])) {\n          tf[i].type = 'O';\n          assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n          tf[i].type = 'Q';\n        }\n      }\n    }\n  }\n\n  function assignFnT(i, hasAggr, autoMode, fn) {\n    tf[i].fn = fn;\n    assignField(i+1, hasAggr, autoMode);\n    delete tf[i].fn;\n  }\n\n  function assignT(i, hasAggr, autoMode) {\n    var f = fields[i];\n    tf[i] = {name: f.name, type: f.type};\n\n    // TODO support array of f._fns\n    if (f._fn) {\n      assignFnT(i, hasAggr, autoMode, f._fn);\n    } else {\n      opt.timeFnList.forEach(function(fn) {\n        if (fn === undefined) {\n          if (!hasAggr) { // can't aggregate over raw time\n            assignField(i+1, false, autoMode);\n          }\n        } else {\n          assignFnT(i, hasAggr, autoMode, fn);\n        }\n      });\n    }\n\n    // FIXME what if you aggregate time?\n  }\n\n  function assignField(i, hasAggr, autoMode) {\n    if (i === fields.length) { // If all fields are assigned\n      checkAndPush();\n      return;\n    }\n\n    var f = fields[i];\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case 'Q':\n        assignQ(i, hasAggr, autoMode);\n        break;\n\n      case 'T':\n        assignT(i, hasAggr, autoMode);\n        break;\n\n      case 'O':\n        /* falls through */\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr, autoMode);\n        break;\n    }\n  }\n\n  var hasAggr = opt.tableTypes === 'aggregated' ? true : opt.tableTypes === 'disaggregated' ? false : null;\n  assignField(0, hasAggr, ANY);\n\n  return output;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":9}],11:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  genEncs = require('./encs'),\n  getMarktypes = require('./marktypes'),\n  rank = require('../rank/rank'),\n  consts = require('../consts');\n\nmodule.exports = genEncodingsFromFields;\n\nfunction genEncodingsFromFields(output, fields, stats, opt, nested) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  var encs = genEncs([], fields, stats, opt);\n\n  if (nested) {\n    return encs.reduce(function(dict, enc) {\n      dict[enc] = genEncodingsFromEncs([], enc, stats, opt);\n      return dict;\n    }, {});\n  } else {\n    return encs.reduce(function(list, enc) {\n      return genEncodingsFromEncs(list, enc, stats, opt);\n    }, []);\n  }\n}\n\nfunction genEncodingsFromEncs(output, enc, stats, opt) {\n  getMarktypes(enc, stats, opt)\n    .forEach(function(markType) {\n      var e = vl.duplicate({\n          data: opt.data,\n          marktype: markType,\n          enc: enc,\n          config: opt.config\n        }),\n        encoding = finalTouch(e, stats, opt),\n        score = rank.encoding(encoding, stats, opt);\n\n      encoding.score = score.score;\n      encoding.scoreFeatures = score.features;\n      output.push(encoding);\n    });\n  return output;\n}\n\n//FIXME this should be refactors\nfunction finalTouch(encoding, stats, opt) {\n  if (encoding.marktype === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n    encoding.enc.color = encoding.enc.text;\n  }\n\n  // don't include zero if stdev/avg < 0.01\n  // https://github.com/uwdata/visrec/issues/69\n  var enc = encoding.enc;\n  ['x', 'y'].forEach(function(et) {\n    var field = enc[et];\n    if (field && vl.field.isMeasure(field) && !vl.field.isCount(field)) {\n      var stat = stats[field.name];\n      if (stat.stdev / stat.avg < 0.01) {\n        field.scale = {zero: false};\n      }\n    }\n  });\n  return encoding;\n}\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":9,\"../rank/rank\":17,\"./encs\":12,\"./marktypes\":14}],12:[function(require,module,exports){\n(function (global){\n\"use strict\";\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('../consts'),\n  genMarkTypes = require('./marktypes'),\n  isDimension = vl.field.isDimension,\n  isMeasure = vl.field.isMeasure;\n\nmodule.exports = genEncs;\n\n// FIXME remove dimension, measure and use information in vega-lite instead!\nvar rules = {\n  x: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dimension: true,\n    multiple: true\n  },\n  col: {\n    dimension: true,\n    multiple: true\n  },\n  shape: {\n    dimension: true,\n    rules: shapeRules\n  },\n  size: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  color: {\n    dimension: true,\n    measure: true,\n    rules: colorRules\n  },\n  alpha: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  text: {\n    measure: true\n  },\n  detail: {\n    dimension: true\n  }\n  //geo: {\n  //  geo: true\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\nfunction retinalEncRules(enc, field, stats, opt) {\n  if (opt.omitMultipleRetinalEncodings) {\n    if (enc.color || enc.size || enc.shape || enc.alpha) return false;\n  }\n  return true;\n}\n\nfunction colorRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  return vl.field.isMeasure(field) ||\n    vl.field.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction shapeRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  if (field.bin && field.type === 'Q') return false;\n  if (field.fn && field.type === 'T') return false;\n  return vl.field.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction dimMeaTransposeRule(enc) {\n  // create horizontal histogram for ordinal\n  if (enc.y.type === 'O' && isMeasure(enc.x)) return true;\n\n  // vertical histogram for Q and T\n  if (isMeasure(enc.y) && (enc.x.type !== 'O' && isDimension(enc.x))) return true;\n\n  return false;\n}\n\nfunction generalRules(enc, stats, opt) {\n  // enc.text is only used for TEXT TABLE\n  if (enc.text) {\n    return genMarkTypes.satisfyRules(enc, 'text', stats, opt);\n  }\n\n  // CARTESIAN PLOT OR MAP\n  if (enc.x || enc.y || enc.geo || enc.arc) {\n\n    if (enc.row || enc.col) { //have facet(s)\n\n      // don't use facets before filling up x,y\n      if (!enc.x || !enc.y) return false;\n\n      if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n        // remove all aggregated charts with all dims on facets (row, col)\n        if (genEncs.isAggrWithAllDimOnFacets(enc)) return false;\n      }\n    }\n\n    if (enc.x && enc.y) {\n      var isDimX = !!isDimension(enc.x),\n        isDimY = !!isDimension(enc.y);\n\n      if (isDimX && isDimY && !vl.enc.isAggregate(enc)) {\n        // FIXME actually check if there would be occlusion #90\n        return false;\n      }\n\n      if (opt.omitTranpose) {\n        if (isDimX ^ isDimY) { // dim x mea\n          if (!dimMeaTransposeRule(enc)) return false;\n        } else if (enc.y.type==='T' || enc.x.type === 'T') {\n          if (enc.y.type==='T' && enc.x.type !== 'T') return false;\n        } else { // show only one OxO, QxQ\n          if (enc.x.name > enc.y.name) return false;\n        }\n      }\n      return true;\n    }\n\n    // DOT PLOTS\n    // // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // one dimension \"count\" is useless\n    if (enc.x && enc.x.aggr == 'count' && !enc.y) return false;\n    if (enc.y && enc.y.aggr == 'count' && !enc.x) return false;\n\n    return true;\n  }\n  return false;\n}\n\ngenEncs.isAggrWithAllDimOnFacets = function (enc) {\n  var hasAggr = false, hasOtherO = false;\n  for (var encType in enc) {\n    var field = enc[encType];\n    if (field.aggr) {\n      hasAggr = true;\n    }\n    if (vl.field.isDimension(field) && (encType !== 'row' && encType !== 'col')) {\n      hasOtherO = true;\n    }\n    if (hasAggr && hasOtherO) break;\n  }\n\n  return hasAggr && !hasOtherO;\n};\n\n\nfunction genEncs(encs, fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  // generate a collection vega-lite's enc\n  var tmpEnc = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fields.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (generalRules(tmpEnc, stats, opt)) {\n        encs.push(vl.duplicate(tmpEnc));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var field = fields[i];\n    for (var j in opt.encodingTypeList) {\n      var et = opt.encodingTypeList[j],\n        isDim = isDimension(field);\n\n      //TODO: support \"multiple\" assignment\n      if (!(et in tmpEnc) && // encoding not used\n        ((isDim && rules[et].dimension) || (!isDim && rules[et].measure)) &&\n        (!rules[et].rules || rules[et].rules(tmpEnc, field, stats, opt))\n      ) {\n        tmpEnc[et] = field;\n        assignField(i + 1);\n        delete tmpEnc[et];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encs;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":9,\"../globals\":16,\"./marktypes\":14}],13:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util');\n\nvar gen = module.exports = {\n  // data variations\n  aggregates: require('./aggregates'),\n  projections: require('./projections'),\n  // encodings / visual variatons\n  encodings: require('./encodings'),\n  encs: require('./encs'),\n  marktypes: require('./marktypes')\n};\n\ngen.charts = function(fields, opt, cfg, flat) {\n  opt = util.gen.getOpt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? gen.aggregates([], fields, opt) : [fields],\n    encs, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggr)) {\n    encs = fieldSets.reduce(function(output, fields) {\n      return gen.encs(output, fields, opt);\n    }, []);\n  } else {\n    encs = fieldSets.map(function(fields) {\n      return gen.encs([], fields, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = util.nestedReduce(encs, function(output, enc) {\n      return gen.marktypes(output, enc, opt, cfg);\n    }, level, true);\n  } else {\n    charts = util.nestedMap(encs, function(enc) {\n      return gen.marktypes([], enc, opt, cfg);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};\n},{\"../util\":19,\"./aggregates\":10,\"./encodings\":11,\"./encs\":12,\"./marktypes\":14,\"./projections\":15}],14:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('../consts'),\n  isDimension = vl.field.isDimension,\n  isOrdinalScale = vl.field.isOrdinalScale;\n\nvar vlmarktypes = module.exports = getMarktypes;\n\nvar marksRule = vlmarktypes.rule = {\n  point:  pointRule,\n  bar:    barRule,\n  line:   lineRule,\n  area:   areaRule, // area is similar to line\n  text:   textRule,\n  tick:   tickRule\n};\n\nfunction getMarktypes(enc, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n\n  var markTypes = opt.marktypeList.filter(function(markType){\n    return vlmarktypes.satisfyRules(enc, markType, stats, opt);\n  });\n\n  return markTypes;\n}\n\nvlmarktypes.satisfyRules = function (enc, markType, stats, opt) {\n  var mark = vl.compile.marks[markType],\n    reqs = mark.requiredEncoding,\n    support = mark.supportedEncoding;\n\n  for (var i in reqs) { // all required encodings in enc\n    if (!(reqs[i] in enc)) return false;\n  }\n\n  for (var encType in enc) { // all encodings in enc are supported\n    if (!support[encType]) return false;\n  }\n\n  return !marksRule[markType] || marksRule[markType](enc, stats, opt);\n};\n\nfunction facetRule(field, stats, opt) {\n  return vl.field.cardinality(field, stats) <= opt.maxCardinalityForFacets;\n}\n\nfunction facetsRule(enc, stats, opt) {\n  if(enc.row && !facetRule(enc.row, stats, opt)) return false;\n  if(enc.col && !facetRule(enc.col, stats, opt)) return false;\n  return true;\n}\n\nfunction pointRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n  if (enc.x && enc.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    // For OxO\n    if (xIsDim && yIsDim) {\n      // shape doesn't work with both x, y as ordinal\n      if (enc.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (enc.color && isDimension(enc.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (enc.shape) return false;\n  }\n  return true;\n}\n\nfunction tickRule(enc, stats, opt) {\n  // jshint unused:false\n  if (enc.x || enc.y) {\n    if(vl.enc.isAggregate(enc)) return false;\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    return (!xIsDim && (!enc.y || isOrdinalScale(enc.y))) ||\n      (!yIsDim && (!enc.x || isOrdinalScale(enc.x)));\n  }\n  return false;\n}\n\nfunction barRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // need to aggregate on either x or y\n  if (opt.omitSizeOnBar && enc.size !== undefined) return false;\n\n  // FIXME actually check if there would be occlusion #90\n  if (((enc.x.aggr !== undefined) ^ (enc.y.aggr !== undefined)) &&\n      (isDimension(enc.x) ^ isDimension(enc.y))) {\n\n    var aggr = enc.x.aggr || enc.y.aggr;\n    return !(opt.omitStackedAverage && aggr ==='avg' && enc.color);\n  }\n\n  return false;\n}\n\nfunction lineRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // FIXME truly ordinal data is fine here too.\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return enc.x.type == 'T' && enc.x.fn && enc.y.type == 'Q' && enc.y.aggr;\n}\n\nfunction areaRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  if(!lineRule(enc, stats, opt)) return false;\n\n  return !(opt.omitStackedAverage && enc.y.aggr ==='avg' && enc.color);\n}\n\nfunction textRule(enc, stats, opt) {\n  // at least must have row or col and aggregated text values\n  return (enc.row || enc.col) && enc.text && enc.text.aggr && !enc.x && !enc.y && !enc.size &&\n    (!opt.alwaysGenerateTableAsHeatmap || !enc.color);\n}\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":9}],15:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar util = require('../util'),\n  consts = require('../consts'),\n  vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  isDimension = vl.field.isDimension;\n\nmodule.exports = projections;\n\n// TODO support other mode of projections generation\n// powerset, chooseK, chooseKorLess are already included in the util\n\n/**\n * fields\n * @param  {[type]} fields array of fields and query information\n * @return {[type]}        [description]\n */\nfunction projections(fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.projections);\n\n  // First categorize field, selected, fieldsToAdd, and save indices\n  var selected = [], fieldsToAdd = [], fieldSets = [],\n    hasSelectedDimension = false,\n    hasSelectedMeasure = false,\n    indices = {};\n\n  fields.forEach(function(field, index){\n    //save indices for stable sort later\n    indices[field.name] = index;\n\n    if (field.selected) {\n      selected.push(field);\n      if (isDimension(field) || field.type ==='T') { // FIXME / HACK\n        hasSelectedDimension = true;\n      } else {\n        hasSelectedMeasure = true;\n      }\n    } else if (field.selected !== false && !vl.field.isCount(field)) {\n      if (vl.field.isDimension(field) &&\n          !opt.maxCardinalityForAutoAddOrdinal &&\n          vl.field.cardinality(field, stats, 15) > opt.maxCardinalityForAutoAddOrdinal\n        ) {\n        return;\n      }\n      fieldsToAdd.push(field);\n    }\n  });\n\n  fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n\n  var setsToAdd = util.chooseKorLess(fieldsToAdd, 1);\n\n  setsToAdd.forEach(function(setToAdd) {\n    var fieldSet = selected.concat(setToAdd);\n    if (fieldSet.length > 0) {\n      if (opt.omitDotPlot && fieldSet.length === 1) return;\n      fieldSets.push(fieldSet);\n    }\n  });\n\n  fieldSets.forEach(function(fieldSet) {\n      // always append projection's key to each projection returned, d3 style.\n    fieldSet.key = projections.key(fieldSet);\n  });\n\n  return fieldSets;\n}\n\nvar typeIsMeasureScore = {\n  O: 0,\n  T: 1,\n  Q: 2\n};\n\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n  return function(a, b){\n    // sort by type of the data\n    if (a.type !== b.type) {\n      if (!hasSelectedDimension) {\n        return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n      } else if (!hasSelectedMeasure) {\n        return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n      }\n    }\n    //make the sort stable\n    return indices[a.name] - indices[b.name];\n  };\n}\n\nprojections.key = function(projection) {\n  return projection.map(function(field) {\n    return vl.field.isCount(field) ? 'count' : field.name;\n  }).join(',');\n};\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":9,\"../util\":19}],16:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar g = global || window;\n\ng.CHART_TYPES = {\n  TABLE: 'TABLE',\n  BAR: 'BAR',\n  PLOT: 'PLOT',\n  LINE: 'LINE',\n  AREA: 'AREA',\n  MAP: 'MAP',\n  HISTOGRAM: 'HISTOGRAM'\n};\n\ng.ANY_DATA_TYPES = (1 << 4) - 1;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],17:[function(require,module,exports){\nmodule.exports = {\n  encoding: require('./rankEncodings')\n};\n\n\n\n},{\"./rankEncodings\":18}],18:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  isDimension = vl.field.isDimension;\n\nmodule.exports = rankEncodings;\n\n// bad score not specified in the table above\nvar UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  tick: 0.96,\n  point: 0.95,\n  circle: 0.94,\n  square: 0.94,\n  text: 0.8\n};\n\nfunction rankEncodings(encoding, stats, opt, selected) {\n  var features = [],\n    encTypes = vl.keys(encoding.enc),\n    marktype = encoding.marktype,\n    enc = encoding.enc;\n\n  var encodingMappingByField = vl.enc.reduce(encoding.enc, function(o, field, encType) {\n    var key = vl.field.shorthand(field);\n    var mappings = o[key] = o[key] || [];\n    mappings.push({encType: encType, field: field});\n    return o;\n  }, {});\n\n  // data - encoding mapping score\n  vl.forEach(encodingMappingByField, function(mappings) {\n    var reasons = mappings.map(function(m) {\n        return m.encType + vl.shorthand.assign + vl.field.shorthand(m.field) +\n          ' ' + (selected && selected[m.field.name] ? '[x]' : '[ ]');\n      }),\n      scores = mappings.map(function(m) {\n        var role = vl.field.role(m.field);\n        var score = rankEncodings.score[role](m.field, m.encType, encoding.marktype, stats, opt);\n\n        return !selected || selected[m.field.name] ? score : Math.pow(score, 0.125);\n      });\n\n    features.push({\n      reason: reasons.join(\" | \"),\n      score: Math.max.apply(null, scores)\n    });\n  });\n\n  // plot type\n  if (marktype === 'text') {\n    // TODO\n  } else {\n    if (enc.x && enc.y) {\n      if (isDimension(enc.x) ^ isDimension(enc.y)) {\n        features.push({\n          reason: 'OxQ plot',\n          score: 0.8\n        });\n      }\n    }\n  }\n\n  // penalize not using positional only penalize for non-text\n  if (encTypes.length > 1 && marktype !== 'text') {\n    if ((!enc.x || !enc.y) && !enc.geo && !enc.text) {\n      features.push({\n        reason: 'unused position',\n        score: UNUSED_POSITION\n      });\n    }\n  }\n\n  // mark type score\n  features.push({\n    reason: 'marktype='+marktype,\n    score: MARK_SCORE[marktype]\n  });\n\n  return {\n    score: features.reduce(function(p, f) {\n      return p * f.score;\n    }, 1),\n    features: features\n  };\n}\n\n\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\n\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675; // < color_ok, > color_bad\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65; // > M.Size\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\n\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.alpha = 0.45;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\n\nrankEncodings.dimensionScore = function (field, encType, marktype, stats, opt){\n  var cardinality = vl.field.cardinality(field, stats);\n  switch (encType) {\n    case 'x':\n      if(field.type === 'O') return D.pos - D.minor;\n      return D.pos;\n\n    case 'y':\n      if(field.type === 'O') return D.pos - D.minor; //prefer ordinal on y\n      if(field.type === 'T') return D.Y_T; // time should not be on Y\n      return D.pos - D.minor;\n\n    case 'col':\n      if (marktype === 'text') return D.facet_text;\n      //prefer column over row due to scrolling issues\n      return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n\n    case 'row':\n      if (marktype === 'text') return D.facet_text;\n      return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n\n    case 'color':\n      var hasOrder = (field.bin && field.type==='Q') || (field.fn && field.type==='T');\n\n      //FIXME add stacking option once we have control ..\n      var isStacked = marktype ==='bar' || marktype ==='area';\n\n      // true ordinal on color is currently BAD (until we have good ordinal color scale support)\n      if (hasOrder) return D.color_bad;\n\n      //stacking gets lower score\n      if (isStacked) return D.color_stack;\n\n      return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good: cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n    case 'shape':\n      return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n    case 'detail':\n      return D.detail;\n  }\n  return TERRIBLE;\n};\n\nrankEncodings.dimensionScore.consts = D;\n\nrankEncodings.measureScore = function (field, encType, marktype, stats, opt) {\n  // jshint unused:false\n  switch (encType){\n    case 'x': return M.pos;\n    case 'y': return M.pos;\n    case 'size':\n      if (marktype === 'bar') return BAD; //size of bar is very bad\n      if (marktype === 'text') return BAD;\n      if (marktype === 'line') return BAD;\n      return M.size;\n    case 'color': return M.color;\n    case 'alpha': return M.alpha;\n    case 'text': return M.text;\n  }\n  return BAD;\n};\n\nrankEncodings.measureScore.consts = M;\n\n\nrankEncodings.score = {\n  dimension: rankEncodings.dimensionScore,\n  measure: rankEncodings.measureScore,\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],19:[function(require,module,exports){\n\"use strict\";\n\nvar consts = require('./consts');\n\nvar util = module.exports = {\n  gen: {}\n};\n\nutil.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) == '[object Array]';\n};\n\nutil.json = function(s, sp) {\n  return JSON.stringify(s, null, sp);\n};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.nestedMap = function (col, f, level, filter) {\n  return level === 0 ?\n    col.map(f) :\n    col.map(function(v) {\n      var r = util.nestedMap(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nestedReduce = function (col, f, level, filter) {\n  return level === 0 ?\n    col.reduce(f, []) :\n    col.map(function(v) {\n      var r = util.nestedReduce(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nonEmpty = function(grp) {\n  return !util.isArray(grp) || grp.length > 0;\n};\n\n\nutil.traverse = function (node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) util.traverse(node.left, arr);\n    if (node.right) util.traverse(node.right, arr);\n  }\n  return arr;\n};\n\nutil.union = function (a, b) {\n  var o = {};\n  a.forEach(function(x) { o[x] = true;});\n  b.forEach(function(x) { o[x] = true;});\n  return util.keys(o);\n};\n\n\nutil.gen.getOpt = function (opt) {\n  //merge with default\n  return (opt ? util.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(consts.gen.DEFAULT_OPT));\n};\n\n/**\n * powerset code from http://rosettacode.org/wiki/Power_Set#JavaScript\n *\n *   var res = powerset([1,2,3,4]);\n *\n * returns\n *\n * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],\n * [2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n[edit]\n*/\n\nutil.powerset = function(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n};\n\nutil.chooseKorLess = function(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length <= k){\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n};\n\nutil.chooseK = function(list, k) {\n  var subset = [[]];\n  var kArray =[];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length < k){\n        subset.push(sub);\n      }else if (sub.length === k){\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n};\n\nutil.cross = function(a,b){\n  var x = [];\n  for(var i=0; i< a.length; i++){\n    for(var j=0;j< b.length; j++){\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n};\n\n\n},{\"./consts\":9}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvY3AiLCJub2RlX21vZHVsZXMvY2x1c3RlcmZjay9saWIvY2x1c3RlcmZjay5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9kaXN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9oY2x1c3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9rbWVhbnMuanMiLCJzcmMvY2x1c3Rlci9jbHVzdGVyLmpzIiwic3JjL2NsdXN0ZXIvY2x1c3RlcmNvbnN0cy5qcyIsInNyYy9jbHVzdGVyL2Rpc3RhbmNlLmpzIiwic3JjL2NvbnN0cy5qcyIsInNyYy9nZW4vYWdncmVnYXRlcy5qcyIsInNyYy9nZW4vZW5jb2RpbmdzLmpzIiwic3JjL2dlbi9lbmNzLmpzIiwic3JjL2dlbi9nZW4uanMiLCJzcmMvZ2VuL21hcmt0eXBlcy5qcyIsInNyYy9nZW4vcHJvamVjdGlvbnMuanMiLCJzcmMvZ2xvYmFscy5qcyIsInNyYy9yYW5rL3JhbmsuanMiLCJzcmMvcmFuay9yYW5rRW5jb2RpbmdzLmpzIiwic3JjL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uc3RzOiByZXF1aXJlKCcuL2NvbnN0cycpLFxuICBjbHVzdGVyOiByZXF1aXJlKCcuL2NsdXN0ZXIvY2x1c3RlcicpLFxuICBnZW46IHJlcXVpcmUoJy4vZ2VuL2dlbicpLFxuICByYW5rOiByZXF1aXJlKCcuL3JhbmsvcmFuaycpLFxuICB1dGlsOiByZXF1aXJlKCcuL3V0aWwnKSxcbiAgYXV0bzogXCItLCBzdW1cIlxufTtcblxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgIGhjbHVzdGVyOiByZXF1aXJlKFwiLi9oY2x1c3RlclwiKSxcbiAgIEttZWFuczogcmVxdWlyZShcIi4va21lYW5zXCIpLFxuICAga21lYW5zOiByZXF1aXJlKFwiLi9rbWVhbnNcIikua21lYW5zXG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBldWNsaWRlYW46IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHRvdGFsICs9IE1hdGgucG93KHYyW2ldIC0gdjFbaV0sIDIpOyAgICAgIFxuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguc3FydCh0b3RhbCk7XG4gICB9LFxuICAgbWFuaGF0dGFuOiBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2MS5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModjJbaV0gLSB2MVtpXSk7ICAgICAgXG4gICAgIH1cbiAgICAgcmV0dXJuIHRvdGFsO1xuICAgfSxcbiAgIG1heDogZnVuY3Rpb24odjEsIHYyKSB7XG4gICAgIHZhciBtYXggPSAwO1xuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCAsIE1hdGguYWJzKHYyW2ldIC0gdjFbaV0pKTsgICAgICBcbiAgICAgfVxuICAgICByZXR1cm4gbWF4O1xuICAgfVxufTsiLCJ2YXIgZGlzdGFuY2VzID0gcmVxdWlyZShcIi4vZGlzdGFuY2VcIik7XG5cbnZhciBIaWVyYXJjaGljYWxDbHVzdGVyaW5nID0gZnVuY3Rpb24oZGlzdGFuY2UsIGxpbmthZ2UsIHRocmVzaG9sZCkge1xuICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgdGhpcy5saW5rYWdlID0gbGlua2FnZTtcbiAgIHRoaXMudGhyZXNob2xkID0gdGhyZXNob2xkID09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhyZXNob2xkO1xufVxuXG5IaWVyYXJjaGljYWxDbHVzdGVyaW5nLnByb3RvdHlwZSA9IHtcbiAgIGNsdXN0ZXIgOiBmdW5jdGlvbihpdGVtcywgc25hcHNob3RQZXJpb2QsIHNuYXBzaG90Q2IpIHtcbiAgICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICAgIHRoaXMuZGlzdHMgPSBbXTsgIC8vIGRpc3RhbmNlcyBiZXR3ZWVuIGVhY2ggcGFpciBvZiBjbHVzdGVyc1xuICAgICAgdGhpcy5taW5zID0gW107IC8vIGNsb3Nlc3QgY2x1c3RlciBmb3IgZWFjaCBjbHVzdGVyXG4gICAgICB0aGlzLmluZGV4ID0gW107IC8vIGtlZXAgYSBoYXNoIG9mIGFsbCBjbHVzdGVycyBieSBrZXlcbiAgICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGNsdXN0ZXIgPSB7XG4gICAgICAgICAgICB2YWx1ZTogaXRlbXNbaV0sXG4gICAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgIH07XG4gICAgICAgICB0aGlzLmNsdXN0ZXJzW2ldID0gY2x1c3RlcjtcbiAgICAgICAgIHRoaXMuaW5kZXhbaV0gPSBjbHVzdGVyO1xuICAgICAgICAgdGhpcy5kaXN0c1tpXSA9IFtdO1xuICAgICAgICAgdGhpcy5taW5zW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBpOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gKGkgPT0gaikgPyBJbmZpbml0eSA6IFxuICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSh0aGlzLmNsdXN0ZXJzW2ldLnZhbHVlLCB0aGlzLmNsdXN0ZXJzW2pdLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzdHNbaV1bal0gPSBkaXN0O1xuICAgICAgICAgICAgdGhpcy5kaXN0c1tqXVtpXSA9IGRpc3Q7XG5cbiAgICAgICAgICAgIGlmIChkaXN0IDwgdGhpcy5kaXN0c1tpXVt0aGlzLm1pbnNbaV1dKSB7XG4gICAgICAgICAgICAgICB0aGlzLm1pbnNbaV0gPSBqOyAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWVyZ2VkID0gdGhpcy5tZXJnZUNsb3Nlc3QoKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChtZXJnZWQpIHtcbiAgICAgICAgaWYgKHNuYXBzaG90Q2IgJiYgKGkrKyAlIHNuYXBzaG90UGVyaW9kKSA9PSAwKSB7XG4gICAgICAgICAgIHNuYXBzaG90Q2IodGhpcy5jbHVzdGVycyk7ICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBtZXJnZWQgPSB0aGlzLm1lcmdlQ2xvc2VzdCgpO1xuICAgICAgfVxuICAgIFxuICAgICAgdGhpcy5jbHVzdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGNsdXN0ZXIpIHtcbiAgICAgICAgLy8gY2xlYW4gdXAgbWV0YWRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuICAgICAgICBkZWxldGUgY2x1c3Rlci5rZXk7XG4gICAgICAgIGRlbGV0ZSBjbHVzdGVyLmluZGV4O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJzO1xuICAgfSxcbiAgXG4gICBtZXJnZUNsb3Nlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gZmluZCB0d28gY2xvc2VzdCBjbHVzdGVycyBmcm9tIGNhY2hlZCBtaW5zXG4gICAgICB2YXIgbWluS2V5ID0gMCwgbWluID0gSW5maW5pdHk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBrZXkgPSB0aGlzLmNsdXN0ZXJzW2ldLmtleSxcbiAgICAgICAgICAgICBkaXN0ID0gdGhpcy5kaXN0c1trZXldW3RoaXMubWluc1trZXldXTtcbiAgICAgICAgIGlmIChkaXN0IDwgbWluKSB7XG4gICAgICAgICAgICBtaW5LZXkgPSBrZXk7XG4gICAgICAgICAgICBtaW4gPSBkaXN0O1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1pbiA+PSB0aGlzLnRocmVzaG9sZCkge1xuICAgICAgICAgcmV0dXJuIGZhbHNlOyAgICAgICAgIFxuICAgICAgfVxuXG4gICAgICB2YXIgYzEgPSB0aGlzLmluZGV4W21pbktleV0sXG4gICAgICAgICAgYzIgPSB0aGlzLmluZGV4W3RoaXMubWluc1ttaW5LZXldXTtcblxuICAgICAgLy8gbWVyZ2UgdHdvIGNsb3Nlc3QgY2x1c3RlcnNcbiAgICAgIHZhciBtZXJnZWQgPSB7XG4gICAgICAgICBsZWZ0OiBjMSxcbiAgICAgICAgIHJpZ2h0OiBjMixcbiAgICAgICAgIGtleTogYzEua2V5LFxuICAgICAgICAgc2l6ZTogYzEuc2l6ZSArIGMyLnNpemVcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuY2x1c3RlcnNbYzEuaW5kZXhdID0gbWVyZ2VkO1xuICAgICAgdGhpcy5jbHVzdGVycy5zcGxpY2UoYzIuaW5kZXgsIDEpO1xuICAgICAgdGhpcy5pbmRleFtjMS5rZXldID0gbWVyZ2VkO1xuXG4gICAgICAvLyB1cGRhdGUgZGlzdGFuY2VzIHdpdGggbmV3IG1lcmdlZCBjbHVzdGVyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBjaSA9IHRoaXMuY2x1c3RlcnNbaV07XG4gICAgICAgICB2YXIgZGlzdDtcbiAgICAgICAgIGlmIChjMS5rZXkgPT0gY2kua2V5KSB7XG4gICAgICAgICAgICBkaXN0ID0gSW5maW5pdHk7ICAgICAgICAgICAgXG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmICh0aGlzLmxpbmthZ2UgPT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgZGlzdCA9IHRoaXMuZGlzdHNbYzEua2V5XVtjaS5rZXldO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzdHNbYzEua2V5XVtjaS5rZXldID4gdGhpcy5kaXN0c1tjMi5rZXldW2NpLmtleV0pIHtcbiAgICAgICAgICAgICAgIGRpc3QgPSB0aGlzLmRpc3RzW2MyLmtleV1bY2kua2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKHRoaXMubGlua2FnZSA9PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgIGRpc3QgPSB0aGlzLmRpc3RzW2MxLmtleV1bY2kua2V5XTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3RzW2MxLmtleV1bY2kua2V5XSA8IHRoaXMuZGlzdHNbYzIua2V5XVtjaS5rZXldKSB7XG4gICAgICAgICAgICAgICBkaXN0ID0gdGhpcy5kaXN0c1tjMi5rZXldW2NpLmtleV07ICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKHRoaXMubGlua2FnZSA9PSBcImF2ZXJhZ2VcIikge1xuICAgICAgICAgICAgZGlzdCA9ICh0aGlzLmRpc3RzW2MxLmtleV1bY2kua2V5XSAqIGMxLnNpemVcbiAgICAgICAgICAgICAgICAgICArIHRoaXMuZGlzdHNbYzIua2V5XVtjaS5rZXldICogYzIuc2l6ZSkgLyAoYzEuc2l6ZSArIGMyLnNpemUpO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkaXN0ID0gdGhpcy5kaXN0YW5jZShjaS52YWx1ZSwgYzEudmFsdWUpOyAgICAgICAgICAgIFxuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLmRpc3RzW2MxLmtleV1bY2kua2V5XSA9IHRoaXMuZGlzdHNbY2kua2V5XVtjMS5rZXldID0gZGlzdDtcbiAgICAgIH1cblxuICAgIFxuICAgICAgLy8gdXBkYXRlIGNhY2hlZCBtaW5zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBrZXkxID0gdGhpcy5jbHVzdGVyc1tpXS5rZXk7ICAgICAgICBcbiAgICAgICAgIGlmICh0aGlzLm1pbnNba2V5MV0gPT0gYzEua2V5IHx8IHRoaXMubWluc1trZXkxXSA9PSBjMi5rZXkpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBrZXkxO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNsdXN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICB2YXIga2V5MiA9IHRoaXMuY2x1c3RlcnNbal0ua2V5O1xuICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzdHNba2V5MV1ba2V5Ml0gPCB0aGlzLmRpc3RzW2tleTFdW21pbl0pIHtcbiAgICAgICAgICAgICAgICAgIG1pbiA9IGtleTI7ICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1pbnNba2V5MV0gPSBtaW47XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLmNsdXN0ZXJzW2ldLmluZGV4ID0gaTtcbiAgICAgIH1cbiAgICBcbiAgICAgIC8vIGNsZWFuIHVwIG1ldGFkYXRhIHVzZWQgZm9yIGNsdXN0ZXJpbmdcbiAgICAgIGRlbGV0ZSBjMS5rZXk7IGRlbGV0ZSBjMi5rZXk7XG4gICAgICBkZWxldGUgYzEuaW5kZXg7IGRlbGV0ZSBjMi5pbmRleDtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICB9XG59XG5cbnZhciBoY2x1c3RlciA9IGZ1bmN0aW9uKGl0ZW1zLCBkaXN0YW5jZSwgbGlua2FnZSwgdGhyZXNob2xkLCBzbmFwc2hvdCwgc25hcHNob3RDYWxsYmFjaykge1xuICAgZGlzdGFuY2UgPSBkaXN0YW5jZSB8fCBcImV1Y2xpZGVhblwiO1xuICAgbGlua2FnZSA9IGxpbmthZ2UgfHwgXCJhdmVyYWdlXCI7XG5cbiAgIGlmICh0eXBlb2YgZGlzdGFuY2UgPT0gXCJzdHJpbmdcIikge1xuICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlc1tkaXN0YW5jZV07XG4gICB9XG4gICB2YXIgY2x1c3RlcnMgPSAobmV3IEhpZXJhcmNoaWNhbENsdXN0ZXJpbmcoZGlzdGFuY2UsIGxpbmthZ2UsIHRocmVzaG9sZCkpXG4gICAgICAgICAgICAgICAgICAuY2x1c3RlcihpdGVtcywgc25hcHNob3QsIHNuYXBzaG90Q2FsbGJhY2spO1xuICAgICAgXG4gICBpZiAodGhyZXNob2xkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjbHVzdGVyc1swXTsgLy8gYWxsIGNsdXN0ZXJlZCBpbnRvIG9uZVxuICAgfVxuICAgcmV0dXJuIGNsdXN0ZXJzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhjbHVzdGVyO1xuIiwidmFyIGRpc3RhbmNlcyA9IHJlcXVpcmUoXCIuL2Rpc3RhbmNlXCIpO1xuXG5mdW5jdGlvbiBLTWVhbnMoY2VudHJvaWRzKSB7XG4gICB0aGlzLmNlbnRyb2lkcyA9IGNlbnRyb2lkcyB8fCBbXTtcbn1cblxuS01lYW5zLnByb3RvdHlwZS5yYW5kb21DZW50cm9pZHMgPSBmdW5jdGlvbihwb2ludHMsIGspIHtcbiAgIHZhciBjZW50cm9pZHMgPSBwb2ludHMuc2xpY2UoMCk7IC8vIGNvcHlcbiAgIGNlbnRyb2lkcy5zb3J0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkpIC0gMC41KTtcbiAgIH0pO1xuICAgcmV0dXJuIGNlbnRyb2lkcy5zbGljZSgwLCBrKTtcbn1cblxuS01lYW5zLnByb3RvdHlwZS5jbGFzc2lmeSA9IGZ1bmN0aW9uKHBvaW50LCBkaXN0YW5jZSkge1xuICAgdmFyIG1pbiA9IEluZmluaXR5LFxuICAgICAgIGluZGV4ID0gMDtcblxuICAgZGlzdGFuY2UgPSBkaXN0YW5jZSB8fCBcImV1Y2xpZGVhblwiO1xuICAgaWYgKHR5cGVvZiBkaXN0YW5jZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlc1tkaXN0YW5jZV07XG4gICB9XG5cbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jZW50cm9pZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaXN0ID0gZGlzdGFuY2UocG9pbnQsIHRoaXMuY2VudHJvaWRzW2ldKTtcbiAgICAgIGlmIChkaXN0IDwgbWluKSB7XG4gICAgICAgICBtaW4gPSBkaXN0O1xuICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgfVxuICAgfVxuXG4gICByZXR1cm4gaW5kZXg7XG59XG5cbktNZWFucy5wcm90b3R5cGUuY2x1c3RlciA9IGZ1bmN0aW9uKHBvaW50cywgaywgZGlzdGFuY2UsIHNuYXBzaG90UGVyaW9kLCBzbmFwc2hvdENiKSB7XG4gICBrID0gayB8fCBNYXRoLm1heCgyLCBNYXRoLmNlaWwoTWF0aC5zcXJ0KHBvaW50cy5sZW5ndGggLyAyKSkpO1xuXG4gICBkaXN0YW5jZSA9IGRpc3RhbmNlIHx8IFwiZXVjbGlkZWFuXCI7XG4gICBpZiAodHlwZW9mIGRpc3RhbmNlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2VzW2Rpc3RhbmNlXTtcbiAgIH1cblxuICAgdGhpcy5jZW50cm9pZHMgPSB0aGlzLnJhbmRvbUNlbnRyb2lkcyhwb2ludHMsIGspO1xuXG4gICB2YXIgYXNzaWdubWVudCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoKTtcbiAgIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShrKTtcblxuICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgdmFyIG1vdmVtZW50ID0gdHJ1ZTtcbiAgIHdoaWxlIChtb3ZlbWVudCkge1xuICAgICAgLy8gdXBkYXRlIHBvaW50LXRvLWNlbnRyb2lkIGFzc2lnbm1lbnRzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgYXNzaWdubWVudFtpXSA9IHRoaXMuY2xhc3NpZnkocG9pbnRzW2ldLCBkaXN0YW5jZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBsb2NhdGlvbiBvZiBlYWNoIGNlbnRyb2lkXG4gICAgICBtb3ZlbWVudCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrOyBqKyspIHtcbiAgICAgICAgIHZhciBhc3NpZ25lZCA9IFtdO1xuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3NpZ25tZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXNzaWdubWVudFtpXSA9PSBqKSB7XG4gICAgICAgICAgICAgICBhc3NpZ25lZC5wdXNoKHBvaW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICghYXNzaWduZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIGNlbnRyb2lkID0gdGhpcy5jZW50cm9pZHNbal07XG4gICAgICAgICB2YXIgbmV3Q2VudHJvaWQgPSBuZXcgQXJyYXkoY2VudHJvaWQubGVuZ3RoKTtcblxuICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBjZW50cm9pZC5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzc2lnbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICBzdW0gKz0gYXNzaWduZWRbaV1bZ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdDZW50cm9pZFtnXSA9IHN1bSAvIGFzc2lnbmVkLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKG5ld0NlbnRyb2lkW2ddICE9IGNlbnRyb2lkW2ddKSB7XG4gICAgICAgICAgICAgICBtb3ZlbWVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuY2VudHJvaWRzW2pdID0gbmV3Q2VudHJvaWQ7XG4gICAgICAgICBjbHVzdGVyc1tqXSA9IGFzc2lnbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoc25hcHNob3RDYiAmJiAoaXRlcmF0aW9ucysrICUgc25hcHNob3RQZXJpb2QgPT0gMCkpIHtcbiAgICAgICAgIHNuYXBzaG90Q2IoY2x1c3RlcnMpO1xuICAgICAgfVxuICAgfVxuXG4gICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbktNZWFucy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5jZW50cm9pZHMpO1xufVxuXG5LTWVhbnMucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24oanNvbikge1xuICAgdGhpcy5jZW50cm9pZHMgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS01lYW5zO1xuXG5tb2R1bGUuZXhwb3J0cy5rbWVhbnMgPSBmdW5jdGlvbih2ZWN0b3JzLCBrKSB7XG4gICByZXR1cm4gKG5ldyBLTWVhbnMoKSkuY2x1c3Rlcih2ZWN0b3JzLCBrKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBjbHVzdGVyO1xuXG52YXIgdmwgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy52bCA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudmwgOiBudWxsKSxcbiAgY2x1c3RlcmZjayA9IHJlcXVpcmUoJ2NsdXN0ZXJmY2snKSxcbiAgY29uc3RzID0gcmVxdWlyZSgnLi9jbHVzdGVyY29uc3RzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmNsdXN0ZXIuZGlzdGFuY2UgPSByZXF1aXJlKCcuL2Rpc3RhbmNlJyk7XG5cbmZ1bmN0aW9uIGNsdXN0ZXIoZW5jb2RpbmdzLCBvcHQpIHtcbiAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgZGlzdCA9IGNsdXN0ZXIuZGlzdGFuY2UudGFibGUoZW5jb2RpbmdzKTtcblxuICB2YXIgY2x1c3RlclRyZWVzID0gY2x1c3RlcmZjay5oY2x1c3RlcihlbmNvZGluZ3MsIGZ1bmN0aW9uKGUxLCBlMikge1xuICAgIHZhciBzMSA9IHZsLkVuY29kaW5nLnNob3J0aGFuZChlMSksXG4gICAgICBzMiA9IHZsLkVuY29kaW5nLnNob3J0aGFuZChlMik7XG4gICAgcmV0dXJuIGRpc3RbczFdW3MyXTtcbiAgfSwgJ2F2ZXJhZ2UnLCBjb25zdHMuQ0xVU1RFUl9USFJFU0hPTEQpO1xuXG4gIHZhciBjbHVzdGVycyA9IGNsdXN0ZXJUcmVlcy5tYXAoZnVuY3Rpb24odHJlZSkge1xuICAgICAgcmV0dXJuIHV0aWwudHJhdmVyc2UodHJlZSwgW10pO1xuICAgIH0pXG4gICAubWFwKGZ1bmN0aW9uKGNsdXN0ZXIpIHtcbiAgICByZXR1cm4gY2x1c3Rlci5zb3J0KGZ1bmN0aW9uKGVuY29kaW5nMSwgZW5jb2RpbmcyKSB7XG4gICAgICAvLyBzb3J0IGVhY2ggY2x1c3RlciAtLSBoYXZlIHRoZSBoaWdoZXN0IHNjb3JlIGFzIDFzdCBpdGVtXG4gICAgICByZXR1cm4gZW5jb2RpbmcyLnNjb3JlIC0gZW5jb2RpbmcxLnNjb3JlO1xuICAgIH0pO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24oY2x1c3RlcikgeyAgLy8gZmlsdGVyIGVtcHR5IGNsdXN0ZXJcbiAgICByZXR1cm4gY2x1c3Rlci5sZW5ndGggPjA7XG4gIH0pLnNvcnQoZnVuY3Rpb24oY2x1c3RlcjEsIGNsdXN0ZXIyKSB7XG4gICAgLy9zb3J0IGJ5IGhpZ2hlc3Qgc2NvcmluZyBpdGVtIGluIGVhY2ggY2x1c3RlclxuICAgIHJldHVybiBjbHVzdGVyMlswXS5zY29yZSAtIGNsdXN0ZXIxWzBdLnNjb3JlO1xuICB9KTtcblxuICBjbHVzdGVycy5kaXN0ID0gZGlzdDsgLy9hcHBlbmQgZGlzdCBpbiB0aGUgYXJyYXkgZm9yIGRlYnVnZ2luZ1xuXG4gIHJldHVybiBjbHVzdGVycztcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuYy5TV0FQUEFCTEUgPSAwLjA1O1xuYy5ESVNUX01JU1NJTkcgPSAxO1xuYy5DTFVTVEVSX1RIUkVTSE9MRCA9IDE7XG5cbmZ1bmN0aW9uIHJlZHVjZVR1cGxlVG9UYWJsZShyLCB4KSB7XG4gIHZhciBhID0geFswXSwgYiA9IHhbMV0sIGQgPSB4WzJdO1xuICByW2FdID0gclthXSB8fCB7fTtcbiAgcltiXSA9IHJbYl0gfHwge307XG4gIHJbYV1bYl0gPSByW2JdW2FdID0gZDtcbiAgcmV0dXJuIHI7XG59XG5cbmMuRElTVF9CWV9FTkNUWVBFID0gW1xuICAvLyBwb3NpdGlvbmFsXG4gIFsneCcsICd5JywgYy5TV0FQUEFCTEVdLFxuICBbJ3JvdycsICdjb2wnLCBjLlNXQVBQQUJMRV0sXG5cbiAgLy8gb3JkaW5hbCBtYXJrIHByb3BlcnRpZXNcbiAgWydjb2xvcicsICdzaGFwZScsIGMuU1dBUFBBQkxFXSxcbiAgWydjb2xvcicsICdkZXRhaWwnLCBjLlNXQVBQQUJMRV0sXG4gIFsnZGV0YWlsJywgJ3NoYXBlJywgYy5TV0FQUEFCTEVdLFxuXG4gIC8vIHF1YW50aXRhdGl2ZSBtYXJrIHByb3BlcnRpZXNcbiAgWydjb2xvcicsICdhbHBoYScsIGMuU1dBUFBBQkxFXSxcbiAgWydzaXplJywgJ2FscGhhJywgYy5TV0FQUEFCTEVdLFxuICBbJ3NpemUnLCAnY29sb3InLCBjLlNXQVBQQUJMRV1cbl0ucmVkdWNlKHJlZHVjZVR1cGxlVG9UYWJsZSwge30pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmwgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy52bCA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudmwgOiBudWxsKSxcbiAgY29uc3RzID0gcmVxdWlyZSgnLi9jbHVzdGVyY29uc3RzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBkaXN0YW5jZSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBkaXN0YW5jZTtcblxuZGlzdGFuY2UudGFibGUgPSBmdW5jdGlvbiAoZW5jb2RpbmdzKSB7XG4gIHZhciBsZW4gPSBlbmNvZGluZ3MubGVuZ3RoLFxuICAgIGNvbGVuY3MgPSBlbmNvZGluZ3MubWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGRpc3RhbmNlLmdldEVuY1R5cGVCeUNvbHVtbk5hbWUoZSk7IH0pLFxuICAgIHNob3J0aGFuZHMgPSBlbmNvZGluZ3MubWFwKHZsLkVuY29kaW5nLnNob3J0aGFuZCksXG4gICAgZGlmZiA9IHt9LCBpLCBqO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgZGlmZltzaG9ydGhhbmRzW2ldXSA9IHt9O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBzaiA9IHNob3J0aGFuZHNbal0sIHNpID0gc2hvcnRoYW5kc1tpXTtcblxuICAgICAgZGlmZltzal1bc2ldID0gZGlmZltzaV1bc2pdID0gZGlzdGFuY2UuZ2V0KGNvbGVuY3NbaV0sIGNvbGVuY3Nbal0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn07XG5cbmRpc3RhbmNlLmdldCA9IGZ1bmN0aW9uIChjb2xlbmMxLCBjb2xlbmMyKSB7XG4gIHZhciBjb2xzID0gdXRpbC51bmlvbih2bC5rZXlzKGNvbGVuYzEuY29sKSwgdmwua2V5cyhjb2xlbmMyLmNvbCkpLFxuICAgIGRpc3QgPSAwO1xuXG4gIGNvbHMuZm9yRWFjaChmdW5jdGlvbihjb2wpIHtcbiAgICB2YXIgZTEgPSBjb2xlbmMxLmNvbFtjb2xdLCBlMiA9IGNvbGVuYzIuY29sW2NvbF07XG5cbiAgICBpZiAoZTEgJiYgZTIpIHtcbiAgICAgIGlmIChlMS5lbmNUeXBlICE9IGUyLmVuY1R5cGUpIHtcbiAgICAgICAgZGlzdCArPSAoY29uc3RzLkRJU1RfQllfRU5DVFlQRVtlMS5lbmNUeXBlXSB8fCB7fSlbZTIuZW5jVHlwZV0gfHwgMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGlzdCArPSBjb25zdHMuRElTVF9NSVNTSU5HO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZG8gbm90IGdyb3VwIHN0YWNrZWQgY2hhcnQgd2l0aCBzaW1pbGFyIG5vbi1zdGFja2VkIGNoYXJ0IVxuICB2YXIgaXNTdGFjazEgPSB2bC5FbmNvZGluZy5pc1N0YWNrKGNvbGVuYzEpLFxuICAgIGlzU3RhY2syID0gdmwuRW5jb2RpbmcuaXNTdGFjayhjb2xlbmMyKTtcblxuICBpZihpc1N0YWNrMSB8fCBpc1N0YWNrMikge1xuICAgIGlmKGlzU3RhY2sxICYmIGlzU3RhY2syKSB7XG4gICAgICBpZihjb2xlbmMxLmVuYy5jb2xvci5uYW1lICE9PSBjb2xlbmMyLmVuYy5jb2xvci5uYW1lKSB7XG4gICAgICAgIGRpc3QrPTE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3QrPTE7IC8vIHN1cmVseSBkaWZmZXJlbnRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpc3Q7XG59O1xuXG4vLyBnZXQgZW5jb2RpbmcgdHlwZSBieSBmaWVsZG5hbWVcbmRpc3RhbmNlLmdldEVuY1R5cGVCeUNvbHVtbk5hbWUgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgX2NvbGVuYyA9IHt9LFxuICAgIGVuYyA9IGVuY29kaW5nLmVuYztcblxuICB2bC5rZXlzKGVuYykuZm9yRWFjaChmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgdmFyIGUgPSB2bC5kdXBsaWNhdGUoZW5jW2VuY1R5cGVdKTtcbiAgICBlLmVuY1R5cGUgPSBlbmNUeXBlO1xuICAgIF9jb2xlbmNbZS5uYW1lIHx8ICcnXSA9IGU7XG4gICAgZGVsZXRlIGUubmFtZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtYXJrdHlwZTogZW5jb2RpbmcubWFya3R5cGUsXG4gICAgY29sOiBfY29sZW5jLFxuICAgIGVuYzogZW5jb2RpbmcuZW5jXG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbnN0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBnZW46IHt9LFxuICBjbHVzdGVyOiB7fSxcbiAgcmFuazoge31cbn07XG5cbmNvbnN0cy5nZW4ucHJvamVjdGlvbnMgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgb21pdERvdFBsb3Q6IHsgLy9GSVhNRSByZW1vdmUgdGhpcyFcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICdyZW1vdmUgYWxsIGRvdCBwbG90cydcbiAgICB9LFxuICAgIG1heENhcmRpbmFsaXR5Rm9yQXV0b0FkZE9yZGluYWw6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDUwLFxuICAgICAgZGVzY3JpcHRpb246ICdtYXggY2FyZGluYWxpdHkgZm9yIG9yZGluYWwgZmllbGQgdG8gYmUgY29uc2lkZXJlZCBmb3IgYXV0byBhZGRpbmcnXG4gICAgfSxcbiAgICBhbHdheXNBZGRIaXN0b2dyYW06IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0cy5nZW4uYWdncmVnYXRlcyA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBjb25maWc6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0J1xuICAgIH0sXG4gICAgdGFibGVUeXBlczoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogJ2JvdGgnLFxuICAgICAgZW51bTogWydib3RoJywgJ2FnZ3JlZ2F0ZWQnLCAnZGlzYWdncmVnYXRlZCddXG4gICAgfSxcbiAgICBnZW5EaW1ROiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdhdXRvJyxcbiAgICAgIGVudW06IFsnYXV0bycsICdiaW4nLCAnY2FzdCcsICdub25lJ10sXG4gICAgICBkZXNjcmlwdGlvbjogJ1VzZSBRIGFzIERpbWVuc2lvbiBlaXRoZXIgYnkgYmlubmluZyBvciBjYXN0aW5nJ1xuICAgIH0sXG4gICAgbWluQ2FyZGluYWxpdHlGb3JCaW46IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwLFxuICAgICAgZGVzY3JpcHRpb246ICdtaW5pbXVtIGNhcmRpbmFsaXR5IG9mIGEgZmllbGQgaWYgd2Ugd2VyZSB0byBiaW4nXG4gICAgfSxcbiAgICBvbWl0RG90UGxvdDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ3JlbW92ZSBhbGwgZG90IHBsb3RzJ1xuICAgIH0sXG4gICAgb21pdE1lYXN1cmVPbmx5OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnT21pdCBhZ2dyZWdhdGlvbiB3aXRoIG1lYXN1cmUocykgb25seSdcbiAgICB9LFxuICAgIG9taXREaW1lbnNpb25Pbmx5OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdPbWl0IGFnZ3JlZ2F0aW9uIHdpdGggZGltZW5zaW9uKHMpIG9ubHknXG4gICAgfSxcbiAgICBhZGRDb3VudEZvckRpbWVuc2lvbk9ubHk6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ0FkZCBjb3VudCB3aGVuIHRoZXJlIGFyZSBkaW1lbnNpb24ocykgb25seSdcbiAgICB9LFxuICAgIGFnZ3JMaXN0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogWydzdHJpbmcnXVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFt1bmRlZmluZWQsICdhdmcnXVxuICAgIH0sXG4gICAgdGltZUZuTGlzdDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6IFsnc3RyaW5nJ11cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBbJ3llYXInXVxuICAgIH0sXG4gICAgY29uc2lzdGVudEF1dG9ROiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246IFwiZ2VuZXJhdGUgc2ltaWxhciBhdXRvIHRyYW5zZm9ybSBmb3IgcXVhbnRcIlxuICAgIH1cbiAgfVxufTtcblxuY29uc3RzLmdlbi5lbmNvZGluZ3MgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbWFya3R5cGVMaXN0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICBkZWZhdWx0OiBbJ3BvaW50JywgJ2JhcicsICdsaW5lJywgJ2FyZWEnLCAndGV4dCcsICd0aWNrJ10sIC8vZmlsbGVkX21hcFxuICAgICAgZGVzY3JpcHRpb246ICdhbGxvd2VkIG1hcmt0eXBlcydcbiAgICB9LFxuICAgIGVuY29kaW5nVHlwZUxpc3Q6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICAgIGRlZmF1bHQ6IFsneCcsICd5JywgJ3JvdycsICdjb2wnLCAnc2l6ZScsICdjb2xvcicsICd0ZXh0JywgJ2RldGFpbCddLFxuICAgICAgZGVzY3JpcHRpb246ICdhbGxvd2VkIGVuY29kaW5nIHR5cGVzJ1xuICAgIH0sXG4gICAgbWF4R29vZENhcmRpbmFsaXR5Rm9yRmFjZXRzOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA1LFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIGNhcmRpbmFsaXR5IG9mIGEgZmllbGQgdG8gYmUgcHV0IG9uIGZhY2V0IChyb3cvY29sKSBlZmZlY3RpdmVseSdcbiAgICB9LFxuICAgIG1heENhcmRpbmFsaXR5Rm9yRmFjZXRzOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMCxcbiAgICAgIGRlc2NyaXB0aW9uOiAnbWF4aW11bSBjYXJkaW5hbGl0eSBvZiBhIGZpZWxkIHRvIGJlIHB1dCBvbiBmYWNldCAocm93L2NvbCknXG4gICAgfSxcbiAgICBtYXhHb29kQ2FyZGluYWxpdHlGb3JDb2xvcjoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnbWF4aW11bSBjYXJkaW5hbGl0eSBvZiBhbiBvcmRpbmFsIGZpZWxkIHRvIGJlIHB1dCBvbiBjb2xvciBlZmZlY3RpdmVseSdcbiAgICB9LFxuICAgIG1heENhcmRpbmFsaXR5Rm9yQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwLFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIGNhcmRpbmFsaXR5IG9mIGFuIG9yZGluYWwgZmllbGQgdG8gYmUgcHV0IG9uIGNvbG9yJ1xuICAgIH0sXG4gICAgbWF4Q2FyZGluYWxpdHlGb3JTaGFwZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNixcbiAgICAgIGRlc2NyaXB0aW9uOiAnbWF4aW11bSBjYXJkaW5hbGl0eSBvZiBhbiBvcmRpbmFsIGZpZWxkIHRvIGJlIHB1dCBvbiBzaGFwZSdcbiAgICB9LFxuICAgIG9taXRUcmFucG9zZTogIHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ0VsaW1pbmF0ZSBhbGwgdHJhbnNwb3NlIGJ5ICgxKSBrZWVwaW5nIGhvcml6b250YWwgZG90IHBsb3Qgb25seSAoMikgZm9yIE94USBjaGFydHMsIGFsd2F5cyBwdXQgTyBvbiBZICgzKSBzaG93IG9ubHkgb25lIER4RCwgTXhNIChjdXJyZW50bHkgc29ydGVkIGJ5IG5hbWUpJ1xuICAgIH0sXG4gICAgb21pdERvdFBsb3Q6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICdyZW1vdmUgYWxsIGRvdCBwbG90cydcbiAgICB9LFxuICAgIG9taXREb3RQbG90V2l0aEV4dHJhRW5jb2Rpbmc6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ3JlbW92ZSBhbGwgZG90IHBsb3RzIHdpdGggPjEgZW5jb2RpbmcnXG4gICAgfSxcbiAgICBvbWl0TXVsdGlwbGVSZXRpbmFsRW5jb2RpbmdzOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdvbWl0IHVzaW5nIG11bHRpcGxlIHJldGluYWwgdmFyaWFibGVzIChzaXplLCBjb2xvciwgYWxwaGEsIHNoYXBlKSdcbiAgICB9LFxuICAgIG9taXROb25UZXh0QWdncldpdGhBbGxEaW1zT25GYWNldHM6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ3JlbW92ZSBhbGwgYWdncmVnYXRlZCBjaGFydHMgKGV4Y2VwdCB0ZXh0IHRhYmxlcykgd2l0aCBhbGwgZGltcyBvbiBmYWNldHMgKHJvdywgY29sKSdcbiAgICB9LFxuICAgIG9taXRTaXplT25CYXI6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICdkbyBub3QgdXNlIGJhclxcJ3Mgc2l6ZSdcbiAgICB9LFxuICAgIG9taXRTdGFja2VkQXZlcmFnZToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnZG8gbm90IHN0YWNrIGJhciBjaGFydCB3aXRoIGF2ZXJhZ2UnXG4gICAgfSxcbiAgICBhbHdheXNHZW5lcmF0ZVRhYmxlQXNIZWF0bWFwOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfVxuICB9XG59O1xuXG5cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmwgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy52bCA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudmwgOiBudWxsKTtcblxudmFyIGNvbnN0cyA9IHJlcXVpcmUoJy4uL2NvbnN0cycpO1xuXG52YXIgQU5ZPScqJztcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5BZ2dyZWdhdGVzO1xuXG5mdW5jdGlvbiBnZW5BZ2dyZWdhdGVzKG91dHB1dCwgZmllbGRzLCBzdGF0cywgb3B0KSB7XG4gIG9wdCA9IHZsLnNjaGVtYS51dGlsLmV4dGVuZChvcHR8fHt9LCBjb25zdHMuZ2VuLmFnZ3JlZ2F0ZXMpO1xuICB2YXIgdGYgPSBuZXcgQXJyYXkoZmllbGRzLmxlbmd0aCk7XG4gIHZhciBoYXNPID0gdmwuYW55KGZpZWxkcywgZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBmLnR5cGUgPT09ICdPJztcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZW1pdChmaWVsZFNldCkge1xuICAgIGZpZWxkU2V0ID0gdmwuZHVwbGljYXRlKGZpZWxkU2V0KTtcbiAgICBmaWVsZFNldC5rZXkgPSB2bC5maWVsZC5zaG9ydGhhbmRzKGZpZWxkU2V0KTtcbiAgICBvdXRwdXQucHVzaChmaWVsZFNldCk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0FuZFB1c2goKSB7XG4gICAgaWYgKG9wdC5vbWl0TWVhc3VyZU9ubHkgfHwgb3B0Lm9taXREaW1lbnNpb25Pbmx5KSB7XG4gICAgICB2YXIgaGFzTWVhc3VyZSA9IGZhbHNlLCBoYXNEaW1lbnNpb24gPSBmYWxzZSwgaGFzUmF3ID0gZmFsc2U7XG4gICAgICB0Zi5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgaWYgKHZsLmZpZWxkLmlzRGltZW5zaW9uKGYpKSB7XG4gICAgICAgICAgaGFzRGltZW5zaW9uID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIWYuYWdncikgaGFzUmF3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWhhc0RpbWVuc2lvbiAmJiAhaGFzUmF3ICYmIG9wdC5vbWl0TWVhc3VyZU9ubHkpIHJldHVybjtcbiAgICAgIGlmICghaGFzTWVhc3VyZSkge1xuICAgICAgICBpZiAob3B0LmFkZENvdW50Rm9yRGltZW5zaW9uT25seSkge1xuICAgICAgICAgIHRmLnB1c2godmwuZmllbGQuY291bnQoKSk7XG4gICAgICAgICAgZW1pdCh0Zik7XG4gICAgICAgICAgdGYucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdC5vbWl0RGltZW5zaW9uT25seSkgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0Lm9taXREb3RQbG90ICYmIHRmLmxlbmd0aCA9PT0gMSkgcmV0dXJuO1xuICAgIGVtaXQodGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduQWdnclEoaSwgaGFzQWdnciwgYXV0b01vZGUsIGEpIHtcbiAgICB2YXIgY2FuSGF2ZUFnZ3IgPSBoYXNBZ2dyID09PSB0cnVlIHx8IGhhc0FnZ3IgPT09IG51bGwsXG4gICAgICBjYW50SGF2ZUFnZ3IgPSBoYXNBZ2dyID09PSBmYWxzZSB8fCBoYXNBZ2dyID09PSBudWxsO1xuICAgIGlmIChhKSB7XG4gICAgICBpZiAoY2FuSGF2ZUFnZ3IpIHtcbiAgICAgICAgdGZbaV0uYWdnciA9IGE7XG4gICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCB0cnVlLCBhdXRvTW9kZSk7XG4gICAgICAgIGRlbGV0ZSB0ZltpXS5hZ2dyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIGlmKGEgPT09IHVuZGVmaW5lZClcbiAgICAgIGlmIChjYW50SGF2ZUFnZ3IpIHtcbiAgICAgICAgYXNzaWduRmllbGQoaSArIDEsIGZhbHNlLCBhdXRvTW9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduQmluUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSkge1xuICAgIHRmW2ldLmJpbiA9IHRydWU7XG4gICAgYXNzaWduRmllbGQoaSArIDEsIGhhc0FnZ3IsIGF1dG9Nb2RlKTtcbiAgICBkZWxldGUgdGZbaV0uYmluO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSkge1xuICAgIHZhciBmID0gZmllbGRzW2ldLFxuICAgICAgY2FuSGF2ZUFnZ3IgPSBoYXNBZ2dyID09PSB0cnVlIHx8IGhhc0FnZ3IgPT09IG51bGw7XG5cbiAgICB0ZltpXSA9IHtuYW1lOiBmLm5hbWUsIHR5cGU6IGYudHlwZX07XG5cbiAgICBpZiAoZi5hZ2dyID09PSAnY291bnQnKSB7IC8vIGlmIGNvdW50IGlzIGluY2x1ZGVkIGluIHRoZSBzZWxlY3RlZCBmaWVsZHNcbiAgICAgIGlmIChjYW5IYXZlQWdncikge1xuICAgICAgICB0ZltpXS5hZ2dyID0gZi5hZ2dyO1xuICAgICAgICBhc3NpZ25GaWVsZChpICsgMSwgdHJ1ZSwgYXV0b01vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZi5fYWdncikge1xuICAgICAgLy8gVE9ETyBzdXBwb3J0IGFycmF5IG9mIGYuX2FnZ3JzIHRvb1xuICAgICAgYXNzaWduQWdnclEoaSwgaGFzQWdnciwgYXV0b01vZGUsIGYuX2FnZ3IpO1xuICAgIH0gZWxzZSBpZiAoZi5fcmF3KSB7XG4gICAgICBhc3NpZ25BZ2dyUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGYuX2Jpbikge1xuICAgICAgYXNzaWduQmluUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdC5hZ2dyTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgaWYgKCFvcHQuY29uc2lzdGVudEF1dG9RIHx8IGF1dG9Nb2RlID09PSBBTlkgfHwgYXV0b01vZGUgPT09IGEpIHtcbiAgICAgICAgICBhc3NpZ25BZ2dyUShpLCBoYXNBZ2dyLCBhIC8qYXNzaWduIGF1dG9Nb2RlKi8sIGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCghb3B0LmNvbnNpc3RlbnRBdXRvUSB8fCB2bC5pc2luKGF1dG9Nb2RlLCBbQU5ZLCAnYmluJywgJ2Nhc3QnLCAnYXV0b2Nhc3QnXSkpICYmICFoYXNPKSB7XG4gICAgICAgIHZhciBoaWdoQ2FyZGluYWxpdHkgPSB2bC5maWVsZC5jYXJkaW5hbGl0eShmLCBzdGF0cykgPiBvcHQubWluQ2FyZGluYWxpdHlGb3JCaW47XG5cbiAgICAgICAgdmFyIGlzQXV0byA9IG9wdC5nZW5EaW1RID09PSAnYXV0bycsXG4gICAgICAgICAgZ2VuQmluID0gb3B0LmdlbkRpbVEgID09PSAnYmluJyB8fCAoaXNBdXRvICYmIGhpZ2hDYXJkaW5hbGl0eSksXG4gICAgICAgICAgZ2VuQ2FzdCA9IG9wdC5nZW5EaW1RID09PSAnY2FzdCcgfHwgKGlzQXV0byAmJiAhaGlnaENhcmRpbmFsaXR5KTtcblxuICAgICAgICBpZiAoZ2VuQmluICYmIHZsLmlzaW4oYXV0b01vZGUsIFtBTlksICdiaW4nLCAnYXV0b2Nhc3QnXSkpIHtcbiAgICAgICAgICBhc3NpZ25CaW5RKGksIGhhc0FnZ3IsIGlzQXV0byA/ICdhdXRvY2FzdCcgOiAnYmluJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbkNhc3QgJiYgdmwuaXNpbihhdXRvTW9kZSwgW0FOWSwgJ2Nhc3QnLCAnYXV0b2Nhc3QnXSkpIHtcbiAgICAgICAgICB0ZltpXS50eXBlID0gJ08nO1xuICAgICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCBoYXNBZ2dyLCBpc0F1dG8gPyAnYXV0b2Nhc3QnIDogJ2Nhc3QnKTtcbiAgICAgICAgICB0ZltpXS50eXBlID0gJ1EnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduRm5UKGksIGhhc0FnZ3IsIGF1dG9Nb2RlLCBmbikge1xuICAgIHRmW2ldLmZuID0gZm47XG4gICAgYXNzaWduRmllbGQoaSsxLCBoYXNBZ2dyLCBhdXRvTW9kZSk7XG4gICAgZGVsZXRlIHRmW2ldLmZuO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduVChpLCBoYXNBZ2dyLCBhdXRvTW9kZSkge1xuICAgIHZhciBmID0gZmllbGRzW2ldO1xuICAgIHRmW2ldID0ge25hbWU6IGYubmFtZSwgdHlwZTogZi50eXBlfTtcblxuICAgIC8vIFRPRE8gc3VwcG9ydCBhcnJheSBvZiBmLl9mbnNcbiAgICBpZiAoZi5fZm4pIHtcbiAgICAgIGFzc2lnbkZuVChpLCBoYXNBZ2dyLCBhdXRvTW9kZSwgZi5fZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHQudGltZUZuTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCFoYXNBZ2dyKSB7IC8vIGNhbid0IGFnZ3JlZ2F0ZSBvdmVyIHJhdyB0aW1lXG4gICAgICAgICAgICBhc3NpZ25GaWVsZChpKzEsIGZhbHNlLCBhdXRvTW9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnbkZuVChpLCBoYXNBZ2dyLCBhdXRvTW9kZSwgZm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRSB3aGF0IGlmIHlvdSBhZ2dyZWdhdGUgdGltZT9cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnbkZpZWxkKGksIGhhc0FnZ3IsIGF1dG9Nb2RlKSB7XG4gICAgaWYgKGkgPT09IGZpZWxkcy5sZW5ndGgpIHsgLy8gSWYgYWxsIGZpZWxkcyBhcmUgYXNzaWduZWRcbiAgICAgIGNoZWNrQW5kUHVzaCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmID0gZmllbGRzW2ldO1xuICAgIC8vIE90aGVyd2lzZSwgYXNzaWduIGktdGggZmllbGRcbiAgICBzd2l0Y2ggKGYudHlwZSkge1xuICAgICAgLy9UT0RPIFwiRFwiLCBcIkdcIlxuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIGFzc2lnblEoaSwgaGFzQWdnciwgYXV0b01vZGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVCc6XG4gICAgICAgIGFzc2lnblQoaSwgaGFzQWdnciwgYXV0b01vZGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTyc6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRmW2ldID0gZjtcbiAgICAgICAgYXNzaWduRmllbGQoaSArIDEsIGhhc0FnZ3IsIGF1dG9Nb2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhc0FnZ3IgPSBvcHQudGFibGVUeXBlcyA9PT0gJ2FnZ3JlZ2F0ZWQnID8gdHJ1ZSA6IG9wdC50YWJsZVR5cGVzID09PSAnZGlzYWdncmVnYXRlZCcgPyBmYWxzZSA6IG51bGw7XG4gIGFzc2lnbkZpZWxkKDAsIGhhc0FnZ3IsIEFOWSk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cudmwgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLnZsIDogbnVsbCksXG4gIGdlbkVuY3MgPSByZXF1aXJlKCcuL2VuY3MnKSxcbiAgZ2V0TWFya3R5cGVzID0gcmVxdWlyZSgnLi9tYXJrdHlwZXMnKSxcbiAgcmFuayA9IHJlcXVpcmUoJy4uL3JhbmsvcmFuaycpLFxuICBjb25zdHMgPSByZXF1aXJlKCcuLi9jb25zdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5FbmNvZGluZ3NGcm9tRmllbGRzO1xuXG5mdW5jdGlvbiBnZW5FbmNvZGluZ3NGcm9tRmllbGRzKG91dHB1dCwgZmllbGRzLCBzdGF0cywgb3B0LCBuZXN0ZWQpIHtcbiAgb3B0ID0gdmwuc2NoZW1hLnV0aWwuZXh0ZW5kKG9wdHx8e30sIGNvbnN0cy5nZW4uZW5jb2RpbmdzKTtcbiAgdmFyIGVuY3MgPSBnZW5FbmNzKFtdLCBmaWVsZHMsIHN0YXRzLCBvcHQpO1xuXG4gIGlmIChuZXN0ZWQpIHtcbiAgICByZXR1cm4gZW5jcy5yZWR1Y2UoZnVuY3Rpb24oZGljdCwgZW5jKSB7XG4gICAgICBkaWN0W2VuY10gPSBnZW5FbmNvZGluZ3NGcm9tRW5jcyhbXSwgZW5jLCBzdGF0cywgb3B0KTtcbiAgICAgIHJldHVybiBkaWN0O1xuICAgIH0sIHt9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZW5jcy5yZWR1Y2UoZnVuY3Rpb24obGlzdCwgZW5jKSB7XG4gICAgICByZXR1cm4gZ2VuRW5jb2RpbmdzRnJvbUVuY3MobGlzdCwgZW5jLCBzdGF0cywgb3B0KTtcbiAgICB9LCBbXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRW5jb2RpbmdzRnJvbUVuY3Mob3V0cHV0LCBlbmMsIHN0YXRzLCBvcHQpIHtcbiAgZ2V0TWFya3R5cGVzKGVuYywgc3RhdHMsIG9wdClcbiAgICAuZm9yRWFjaChmdW5jdGlvbihtYXJrVHlwZSkge1xuICAgICAgdmFyIGUgPSB2bC5kdXBsaWNhdGUoe1xuICAgICAgICAgIGRhdGE6IG9wdC5kYXRhLFxuICAgICAgICAgIG1hcmt0eXBlOiBtYXJrVHlwZSxcbiAgICAgICAgICBlbmM6IGVuYyxcbiAgICAgICAgICBjb25maWc6IG9wdC5jb25maWdcbiAgICAgICAgfSksXG4gICAgICAgIGVuY29kaW5nID0gZmluYWxUb3VjaChlLCBzdGF0cywgb3B0KSxcbiAgICAgICAgc2NvcmUgPSByYW5rLmVuY29kaW5nKGVuY29kaW5nLCBzdGF0cywgb3B0KTtcblxuICAgICAgZW5jb2Rpbmcuc2NvcmUgPSBzY29yZS5zY29yZTtcbiAgICAgIGVuY29kaW5nLnNjb3JlRmVhdHVyZXMgPSBzY29yZS5mZWF0dXJlcztcbiAgICAgIG91dHB1dC5wdXNoKGVuY29kaW5nKTtcbiAgICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy9GSVhNRSB0aGlzIHNob3VsZCBiZSByZWZhY3RvcnNcbmZ1bmN0aW9uIGZpbmFsVG91Y2goZW5jb2RpbmcsIHN0YXRzLCBvcHQpIHtcbiAgaWYgKGVuY29kaW5nLm1hcmt0eXBlID09PSAndGV4dCcgJiYgb3B0LmFsd2F5c0dlbmVyYXRlVGFibGVBc0hlYXRtYXApIHtcbiAgICBlbmNvZGluZy5lbmMuY29sb3IgPSBlbmNvZGluZy5lbmMudGV4dDtcbiAgfVxuXG4gIC8vIGRvbid0IGluY2x1ZGUgemVybyBpZiBzdGRldi9hdmcgPCAwLjAxXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91d2RhdGEvdmlzcmVjL2lzc3Vlcy82OVxuICB2YXIgZW5jID0gZW5jb2RpbmcuZW5jO1xuICBbJ3gnLCAneSddLmZvckVhY2goZnVuY3Rpb24oZXQpIHtcbiAgICB2YXIgZmllbGQgPSBlbmNbZXRdO1xuICAgIGlmIChmaWVsZCAmJiB2bC5maWVsZC5pc01lYXN1cmUoZmllbGQpICYmICF2bC5maWVsZC5pc0NvdW50KGZpZWxkKSkge1xuICAgICAgdmFyIHN0YXQgPSBzdGF0c1tmaWVsZC5uYW1lXTtcbiAgICAgIGlmIChzdGF0LnN0ZGV2IC8gc3RhdC5hdmcgPCAwLjAxKSB7XG4gICAgICAgIGZpZWxkLnNjYWxlID0ge3plcm86IGZhbHNlfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZW5jb2Rpbmc7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnZsIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC52bCA6IG51bGwpLFxuICBjb25zdHMgPSByZXF1aXJlKCcuLi9jb25zdHMnKSxcbiAgZ2VuTWFya1R5cGVzID0gcmVxdWlyZSgnLi9tYXJrdHlwZXMnKSxcbiAgaXNEaW1lbnNpb24gPSB2bC5maWVsZC5pc0RpbWVuc2lvbixcbiAgaXNNZWFzdXJlID0gdmwuZmllbGQuaXNNZWFzdXJlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbkVuY3M7XG5cbi8vIEZJWE1FIHJlbW92ZSBkaW1lbnNpb24sIG1lYXN1cmUgYW5kIHVzZSBpbmZvcm1hdGlvbiBpbiB2ZWdhLWxpdGUgaW5zdGVhZCFcbnZhciBydWxlcyA9IHtcbiAgeDoge1xuICAgIGRpbWVuc2lvbjogdHJ1ZSxcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIG11bHRpcGxlOiB0cnVlIC8vRklYTUUgc2hvdWxkIGFsbG93IG11bHRpcGxlIG9ubHkgZm9yIFEsIFRcbiAgfSxcbiAgeToge1xuICAgIGRpbWVuc2lvbjogdHJ1ZSxcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIG11bHRpcGxlOiB0cnVlIC8vRklYTUUgc2hvdWxkIGFsbG93IG11bHRpcGxlIG9ubHkgZm9yIFEsIFRcbiAgfSxcbiAgcm93OiB7XG4gICAgZGltZW5zaW9uOiB0cnVlLFxuICAgIG11bHRpcGxlOiB0cnVlXG4gIH0sXG4gIGNvbDoge1xuICAgIGRpbWVuc2lvbjogdHJ1ZSxcbiAgICBtdWx0aXBsZTogdHJ1ZVxuICB9LFxuICBzaGFwZToge1xuICAgIGRpbWVuc2lvbjogdHJ1ZSxcbiAgICBydWxlczogc2hhcGVSdWxlc1xuICB9LFxuICBzaXplOiB7XG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBydWxlczogcmV0aW5hbEVuY1J1bGVzXG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgZGltZW5zaW9uOiB0cnVlLFxuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgcnVsZXM6IGNvbG9yUnVsZXNcbiAgfSxcbiAgYWxwaGE6IHtcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIHJ1bGVzOiByZXRpbmFsRW5jUnVsZXNcbiAgfSxcbiAgdGV4dDoge1xuICAgIG1lYXN1cmU6IHRydWVcbiAgfSxcbiAgZGV0YWlsOiB7XG4gICAgZGltZW5zaW9uOiB0cnVlXG4gIH1cbiAgLy9nZW86IHtcbiAgLy8gIGdlbzogdHJ1ZVxuICAvL30sXG4gIC8vYXJjOiB7IC8vIHBpZVxuICAvL1xuICAvL31cbn07XG5cbmZ1bmN0aW9uIHJldGluYWxFbmNSdWxlcyhlbmMsIGZpZWxkLCBzdGF0cywgb3B0KSB7XG4gIGlmIChvcHQub21pdE11bHRpcGxlUmV0aW5hbEVuY29kaW5ncykge1xuICAgIGlmIChlbmMuY29sb3IgfHwgZW5jLnNpemUgfHwgZW5jLnNoYXBlIHx8IGVuYy5hbHBoYSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb2xvclJ1bGVzKGVuYywgZmllbGQsIHN0YXRzLCBvcHQpIHtcbiAgaWYoIXJldGluYWxFbmNSdWxlcyhlbmMsIGZpZWxkLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB2bC5maWVsZC5pc01lYXN1cmUoZmllbGQpIHx8XG4gICAgdmwuZmllbGQuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzKSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JDb2xvcjtcbn1cblxuZnVuY3Rpb24gc2hhcGVSdWxlcyhlbmMsIGZpZWxkLCBzdGF0cywgb3B0KSB7XG4gIGlmKCFyZXRpbmFsRW5jUnVsZXMoZW5jLCBmaWVsZCwgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcblxuICBpZiAoZmllbGQuYmluICYmIGZpZWxkLnR5cGUgPT09ICdRJykgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmllbGQuZm4gJiYgZmllbGQudHlwZSA9PT0gJ1QnKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB2bC5maWVsZC5jYXJkaW5hbGl0eShmaWVsZCwgc3RhdHMpIDw9IG9wdC5tYXhDYXJkaW5hbGl0eUZvckNvbG9yO1xufVxuXG5mdW5jdGlvbiBkaW1NZWFUcmFuc3Bvc2VSdWxlKGVuYykge1xuICAvLyBjcmVhdGUgaG9yaXpvbnRhbCBoaXN0b2dyYW0gZm9yIG9yZGluYWxcbiAgaWYgKGVuYy55LnR5cGUgPT09ICdPJyAmJiBpc01lYXN1cmUoZW5jLngpKSByZXR1cm4gdHJ1ZTtcblxuICAvLyB2ZXJ0aWNhbCBoaXN0b2dyYW0gZm9yIFEgYW5kIFRcbiAgaWYgKGlzTWVhc3VyZShlbmMueSkgJiYgKGVuYy54LnR5cGUgIT09ICdPJyAmJiBpc0RpbWVuc2lvbihlbmMueCkpKSByZXR1cm4gdHJ1ZTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYWxSdWxlcyhlbmMsIHN0YXRzLCBvcHQpIHtcbiAgLy8gZW5jLnRleHQgaXMgb25seSB1c2VkIGZvciBURVhUIFRBQkxFXG4gIGlmIChlbmMudGV4dCkge1xuICAgIHJldHVybiBnZW5NYXJrVHlwZXMuc2F0aXNmeVJ1bGVzKGVuYywgJ3RleHQnLCBzdGF0cywgb3B0KTtcbiAgfVxuXG4gIC8vIENBUlRFU0lBTiBQTE9UIE9SIE1BUFxuICBpZiAoZW5jLnggfHwgZW5jLnkgfHwgZW5jLmdlbyB8fCBlbmMuYXJjKSB7XG5cbiAgICBpZiAoZW5jLnJvdyB8fCBlbmMuY29sKSB7IC8vaGF2ZSBmYWNldChzKVxuXG4gICAgICAvLyBkb24ndCB1c2UgZmFjZXRzIGJlZm9yZSBmaWxsaW5nIHVwIHgseVxuICAgICAgaWYgKCFlbmMueCB8fCAhZW5jLnkpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKG9wdC5vbWl0Tm9uVGV4dEFnZ3JXaXRoQWxsRGltc09uRmFjZXRzKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgYWdncmVnYXRlZCBjaGFydHMgd2l0aCBhbGwgZGltcyBvbiBmYWNldHMgKHJvdywgY29sKVxuICAgICAgICBpZiAoZ2VuRW5jcy5pc0FnZ3JXaXRoQWxsRGltT25GYWNldHMoZW5jKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmMueCAmJiBlbmMueSkge1xuICAgICAgdmFyIGlzRGltWCA9ICEhaXNEaW1lbnNpb24oZW5jLngpLFxuICAgICAgICBpc0RpbVkgPSAhIWlzRGltZW5zaW9uKGVuYy55KTtcblxuICAgICAgaWYgKGlzRGltWCAmJiBpc0RpbVkgJiYgIXZsLmVuYy5pc0FnZ3JlZ2F0ZShlbmMpKSB7XG4gICAgICAgIC8vIEZJWE1FIGFjdHVhbGx5IGNoZWNrIGlmIHRoZXJlIHdvdWxkIGJlIG9jY2x1c2lvbiAjOTBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0Lm9taXRUcmFucG9zZSkge1xuICAgICAgICBpZiAoaXNEaW1YIF4gaXNEaW1ZKSB7IC8vIGRpbSB4IG1lYVxuICAgICAgICAgIGlmICghZGltTWVhVHJhbnNwb3NlUnVsZShlbmMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZW5jLnkudHlwZT09PSdUJyB8fCBlbmMueC50eXBlID09PSAnVCcpIHtcbiAgICAgICAgICBpZiAoZW5jLnkudHlwZT09PSdUJyAmJiBlbmMueC50eXBlICE9PSAnVCcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHsgLy8gc2hvdyBvbmx5IG9uZSBPeE8sIFF4UVxuICAgICAgICAgIGlmIChlbmMueC5uYW1lID4gZW5jLnkubmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBET1QgUExPVFNcbiAgICAvLyAvLyBwbG90IHdpdGggb25lIGF4aXMgPSBkb3QgcGxvdFxuICAgIGlmIChvcHQub21pdERvdFBsb3QpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIERvdCBwbG90IHNob3VsZCBhbHdheXMgYmUgaG9yaXpvbnRhbFxuICAgIGlmIChvcHQub21pdFRyYW5wb3NlICYmIGVuYy55KSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBkb3QgcGxvdCBzaG91bGRuJ3QgaGF2ZSBvdGhlciBlbmNvZGluZ1xuICAgIGlmIChvcHQub21pdERvdFBsb3RXaXRoRXh0cmFFbmNvZGluZyAmJiB2bC5rZXlzKGVuYykubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gb25lIGRpbWVuc2lvbiBcImNvdW50XCIgaXMgdXNlbGVzc1xuICAgIGlmIChlbmMueCAmJiBlbmMueC5hZ2dyID09ICdjb3VudCcgJiYgIWVuYy55KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGVuYy55ICYmIGVuYy55LmFnZ3IgPT0gJ2NvdW50JyAmJiAhZW5jLngpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZ2VuRW5jcy5pc0FnZ3JXaXRoQWxsRGltT25GYWNldHMgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciBoYXNBZ2dyID0gZmFsc2UsIGhhc090aGVyTyA9IGZhbHNlO1xuICBmb3IgKHZhciBlbmNUeXBlIGluIGVuYykge1xuICAgIHZhciBmaWVsZCA9IGVuY1tlbmNUeXBlXTtcbiAgICBpZiAoZmllbGQuYWdncikge1xuICAgICAgaGFzQWdnciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh2bC5maWVsZC5pc0RpbWVuc2lvbihmaWVsZCkgJiYgKGVuY1R5cGUgIT09ICdyb3cnICYmIGVuY1R5cGUgIT09ICdjb2wnKSkge1xuICAgICAgaGFzT3RoZXJPID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0FnZ3IgJiYgaGFzT3RoZXJPKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBoYXNBZ2dyICYmICFoYXNPdGhlck87XG59O1xuXG5cbmZ1bmN0aW9uIGdlbkVuY3MoZW5jcywgZmllbGRzLCBzdGF0cywgb3B0KSB7XG4gIG9wdCA9IHZsLnNjaGVtYS51dGlsLmV4dGVuZChvcHR8fHt9LCBjb25zdHMuZ2VuLmVuY29kaW5ncyk7XG4gIC8vIGdlbmVyYXRlIGEgY29sbGVjdGlvbiB2ZWdhLWxpdGUncyBlbmNcbiAgdmFyIHRtcEVuYyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGFzc2lnbkZpZWxkKGkpIHtcbiAgICAvLyBJZiBhbGwgZmllbGRzIGFyZSBhc3NpZ25lZCwgc2F2ZVxuICAgIGlmIChpID09PSBmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAvLyBhdCB0aGUgbWluaW1hbCBhbGwgY2hhcnQgc2hvdWxkIGhhdmUgeCwgeSwgZ2VvLCB0ZXh0IG9yIGFyY1xuICAgICAgaWYgKGdlbmVyYWxSdWxlcyh0bXBFbmMsIHN0YXRzLCBvcHQpKSB7XG4gICAgICAgIGVuY3MucHVzaCh2bC5kdXBsaWNhdGUodG1wRW5jKSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBhc3NpZ24gaS10aCBmaWVsZFxuICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICBmb3IgKHZhciBqIGluIG9wdC5lbmNvZGluZ1R5cGVMaXN0KSB7XG4gICAgICB2YXIgZXQgPSBvcHQuZW5jb2RpbmdUeXBlTGlzdFtqXSxcbiAgICAgICAgaXNEaW0gPSBpc0RpbWVuc2lvbihmaWVsZCk7XG5cbiAgICAgIC8vVE9ETzogc3VwcG9ydCBcIm11bHRpcGxlXCIgYXNzaWdubWVudFxuICAgICAgaWYgKCEoZXQgaW4gdG1wRW5jKSAmJiAvLyBlbmNvZGluZyBub3QgdXNlZFxuICAgICAgICAoKGlzRGltICYmIHJ1bGVzW2V0XS5kaW1lbnNpb24pIHx8ICghaXNEaW0gJiYgcnVsZXNbZXRdLm1lYXN1cmUpKSAmJlxuICAgICAgICAoIXJ1bGVzW2V0XS5ydWxlcyB8fCBydWxlc1tldF0ucnVsZXModG1wRW5jLCBmaWVsZCwgc3RhdHMsIG9wdCkpXG4gICAgICApIHtcbiAgICAgICAgdG1wRW5jW2V0XSA9IGZpZWxkO1xuICAgICAgICBhc3NpZ25GaWVsZChpICsgMSk7XG4gICAgICAgIGRlbGV0ZSB0bXBFbmNbZXRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzc2lnbkZpZWxkKDApO1xuXG4gIHJldHVybiBlbmNzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIGdlbiA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBkYXRhIHZhcmlhdGlvbnNcbiAgYWdncmVnYXRlczogcmVxdWlyZSgnLi9hZ2dyZWdhdGVzJyksXG4gIHByb2plY3Rpb25zOiByZXF1aXJlKCcuL3Byb2plY3Rpb25zJyksXG4gIC8vIGVuY29kaW5ncyAvIHZpc3VhbCB2YXJpYXRvbnNcbiAgZW5jb2RpbmdzOiByZXF1aXJlKCcuL2VuY29kaW5ncycpLFxuICBlbmNzOiByZXF1aXJlKCcuL2VuY3MnKSxcbiAgbWFya3R5cGVzOiByZXF1aXJlKCcuL21hcmt0eXBlcycpXG59O1xuXG5nZW4uY2hhcnRzID0gZnVuY3Rpb24oZmllbGRzLCBvcHQsIGNmZywgZmxhdCkge1xuICBvcHQgPSB1dGlsLmdlbi5nZXRPcHQob3B0KTtcbiAgZmxhdCA9IGZsYXQgPT09IHVuZGVmaW5lZCA/IHtlbmNvZGluZ3M6IDF9IDogZmxhdDtcblxuICAvLyBUT0RPIGdlbmVyYXRlXG5cbiAgLy8gZ2VuZXJhdGUgcGVybXV0YXRpb24gb2YgZW5jb2RpbmcgbWFwcGluZ3NcbiAgdmFyIGZpZWxkU2V0cyA9IG9wdC5nZW5BZ2dyID8gZ2VuLmFnZ3JlZ2F0ZXMoW10sIGZpZWxkcywgb3B0KSA6IFtmaWVsZHNdLFxuICAgIGVuY3MsIGNoYXJ0cywgbGV2ZWwgPSAwO1xuXG4gIGlmIChmbGF0ID09PSB0cnVlIHx8IChmbGF0ICYmIGZsYXQuYWdncikpIHtcbiAgICBlbmNzID0gZmllbGRTZXRzLnJlZHVjZShmdW5jdGlvbihvdXRwdXQsIGZpZWxkcykge1xuICAgICAgcmV0dXJuIGdlbi5lbmNzKG91dHB1dCwgZmllbGRzLCBvcHQpO1xuICAgIH0sIFtdKTtcbiAgfSBlbHNlIHtcbiAgICBlbmNzID0gZmllbGRTZXRzLm1hcChmdW5jdGlvbihmaWVsZHMpIHtcbiAgICAgIHJldHVybiBnZW4uZW5jcyhbXSwgZmllbGRzLCBvcHQpO1xuICAgIH0sIHRydWUpO1xuICAgIGxldmVsICs9IDE7XG4gIH1cblxuICBpZiAoZmxhdCA9PT0gdHJ1ZSB8fCAoZmxhdCAmJiBmbGF0LmVuY29kaW5ncykpIHtcbiAgICBjaGFydHMgPSB1dGlsLm5lc3RlZFJlZHVjZShlbmNzLCBmdW5jdGlvbihvdXRwdXQsIGVuYykge1xuICAgICAgcmV0dXJuIGdlbi5tYXJrdHlwZXMob3V0cHV0LCBlbmMsIG9wdCwgY2ZnKTtcbiAgICB9LCBsZXZlbCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnRzID0gdXRpbC5uZXN0ZWRNYXAoZW5jcywgZnVuY3Rpb24oZW5jKSB7XG4gICAgICByZXR1cm4gZ2VuLm1hcmt0eXBlcyhbXSwgZW5jLCBvcHQsIGNmZyk7XG4gICAgfSwgbGV2ZWwsIHRydWUpO1xuICAgIGxldmVsICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0cztcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnZsIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC52bCA6IG51bGwpLFxuICBjb25zdHMgPSByZXF1aXJlKCcuLi9jb25zdHMnKSxcbiAgaXNEaW1lbnNpb24gPSB2bC5maWVsZC5pc0RpbWVuc2lvbixcbiAgaXNPcmRpbmFsU2NhbGUgPSB2bC5maWVsZC5pc09yZGluYWxTY2FsZTtcblxudmFyIHZsbWFya3R5cGVzID0gbW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdHlwZXM7XG5cbnZhciBtYXJrc1J1bGUgPSB2bG1hcmt0eXBlcy5ydWxlID0ge1xuICBwb2ludDogIHBvaW50UnVsZSxcbiAgYmFyOiAgICBiYXJSdWxlLFxuICBsaW5lOiAgIGxpbmVSdWxlLFxuICBhcmVhOiAgIGFyZWFSdWxlLCAvLyBhcmVhIGlzIHNpbWlsYXIgdG8gbGluZVxuICB0ZXh0OiAgIHRleHRSdWxlLFxuICB0aWNrOiAgIHRpY2tSdWxlXG59O1xuXG5mdW5jdGlvbiBnZXRNYXJrdHlwZXMoZW5jLCBzdGF0cywgb3B0KSB7XG4gIG9wdCA9IHZsLnNjaGVtYS51dGlsLmV4dGVuZChvcHR8fHt9LCBjb25zdHMuZ2VuLmVuY29kaW5ncyk7XG5cbiAgdmFyIG1hcmtUeXBlcyA9IG9wdC5tYXJrdHlwZUxpc3QuZmlsdGVyKGZ1bmN0aW9uKG1hcmtUeXBlKXtcbiAgICByZXR1cm4gdmxtYXJrdHlwZXMuc2F0aXNmeVJ1bGVzKGVuYywgbWFya1R5cGUsIHN0YXRzLCBvcHQpO1xuICB9KTtcblxuICByZXR1cm4gbWFya1R5cGVzO1xufVxuXG52bG1hcmt0eXBlcy5zYXRpc2Z5UnVsZXMgPSBmdW5jdGlvbiAoZW5jLCBtYXJrVHlwZSwgc3RhdHMsIG9wdCkge1xuICB2YXIgbWFyayA9IHZsLmNvbXBpbGUubWFya3NbbWFya1R5cGVdLFxuICAgIHJlcXMgPSBtYXJrLnJlcXVpcmVkRW5jb2RpbmcsXG4gICAgc3VwcG9ydCA9IG1hcmsuc3VwcG9ydGVkRW5jb2Rpbmc7XG5cbiAgZm9yICh2YXIgaSBpbiByZXFzKSB7IC8vIGFsbCByZXF1aXJlZCBlbmNvZGluZ3MgaW4gZW5jXG4gICAgaWYgKCEocmVxc1tpXSBpbiBlbmMpKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBlbmNUeXBlIGluIGVuYykgeyAvLyBhbGwgZW5jb2RpbmdzIGluIGVuYyBhcmUgc3VwcG9ydGVkXG4gICAgaWYgKCFzdXBwb3J0W2VuY1R5cGVdKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIW1hcmtzUnVsZVttYXJrVHlwZV0gfHwgbWFya3NSdWxlW21hcmtUeXBlXShlbmMsIHN0YXRzLCBvcHQpO1xufTtcblxuZnVuY3Rpb24gZmFjZXRSdWxlKGZpZWxkLCBzdGF0cywgb3B0KSB7XG4gIHJldHVybiB2bC5maWVsZC5jYXJkaW5hbGl0eShmaWVsZCwgc3RhdHMpIDw9IG9wdC5tYXhDYXJkaW5hbGl0eUZvckZhY2V0cztcbn1cblxuZnVuY3Rpb24gZmFjZXRzUnVsZShlbmMsIHN0YXRzLCBvcHQpIHtcbiAgaWYoZW5jLnJvdyAmJiAhZmFjZXRSdWxlKGVuYy5yb3csIHN0YXRzLCBvcHQpKSByZXR1cm4gZmFsc2U7XG4gIGlmKGVuYy5jb2wgJiYgIWZhY2V0UnVsZShlbmMuY29sLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcG9pbnRSdWxlKGVuYywgc3RhdHMsIG9wdCkge1xuICBpZighZmFjZXRzUnVsZShlbmMsIHN0YXRzLCBvcHQpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChlbmMueCAmJiBlbmMueSkge1xuICAgIC8vIGhhdmUgYm90aCB4ICYgeSA9PT4gc2NhdHRlciBwbG90IC8gYnViYmxlIHBsb3RcblxuICAgIHZhciB4SXNEaW0gPSBpc0RpbWVuc2lvbihlbmMueCksXG4gICAgICB5SXNEaW0gPSBpc0RpbWVuc2lvbihlbmMueSk7XG5cbiAgICAvLyBGb3IgT3hPXG4gICAgaWYgKHhJc0RpbSAmJiB5SXNEaW0pIHtcbiAgICAgIC8vIHNoYXBlIGRvZXNuJ3Qgd29yayB3aXRoIGJvdGggeCwgeSBhcyBvcmRpbmFsXG4gICAgICBpZiAoZW5jLnNoYXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyhrYW5pdHcpOiBjaGVjayB0aGF0IHRoZXJlIGlzIHF1YW50IGF0IGxlYXN0IC4uLlxuICAgICAgaWYgKGVuYy5jb2xvciAmJiBpc0RpbWVuc2lvbihlbmMuY29sb3IpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIHsgLy8gcGxvdCB3aXRoIG9uZSBheGlzID0gZG90IHBsb3RcbiAgICBpZiAob3B0Lm9taXREb3RQbG90KSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBEb3QgcGxvdCBzaG91bGQgYWx3YXlzIGJlIGhvcml6b250YWxcbiAgICBpZiAob3B0Lm9taXRUcmFucG9zZSAmJiBlbmMueSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gZG90IHBsb3Qgc2hvdWxkbid0IGhhdmUgb3RoZXIgZW5jb2RpbmdcbiAgICBpZiAob3B0Lm9taXREb3RQbG90V2l0aEV4dHJhRW5jb2RpbmcgJiYgdmwua2V5cyhlbmMpLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGRvdCBwbG90IHdpdGggc2hhcGUgaXMgbm9uLXNlbnNlXG4gICAgaWYgKGVuYy5zaGFwZSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB0aWNrUnVsZShlbmMsIHN0YXRzLCBvcHQpIHtcbiAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICBpZiAoZW5jLnggfHwgZW5jLnkpIHtcbiAgICBpZih2bC5lbmMuaXNBZ2dyZWdhdGUoZW5jKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHhJc0RpbSA9IGlzRGltZW5zaW9uKGVuYy54KSxcbiAgICAgIHlJc0RpbSA9IGlzRGltZW5zaW9uKGVuYy55KTtcblxuICAgIHJldHVybiAoIXhJc0RpbSAmJiAoIWVuYy55IHx8IGlzT3JkaW5hbFNjYWxlKGVuYy55KSkpIHx8XG4gICAgICAoIXlJc0RpbSAmJiAoIWVuYy54IHx8IGlzT3JkaW5hbFNjYWxlKGVuYy54KSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYmFyUnVsZShlbmMsIHN0YXRzLCBvcHQpIHtcbiAgaWYoIWZhY2V0c1J1bGUoZW5jLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIG5lZWQgdG8gYWdncmVnYXRlIG9uIGVpdGhlciB4IG9yIHlcbiAgaWYgKG9wdC5vbWl0U2l6ZU9uQmFyICYmIGVuYy5zaXplICE9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcblxuICAvLyBGSVhNRSBhY3R1YWxseSBjaGVjayBpZiB0aGVyZSB3b3VsZCBiZSBvY2NsdXNpb24gIzkwXG4gIGlmICgoKGVuYy54LmFnZ3IgIT09IHVuZGVmaW5lZCkgXiAoZW5jLnkuYWdnciAhPT0gdW5kZWZpbmVkKSkgJiZcbiAgICAgIChpc0RpbWVuc2lvbihlbmMueCkgXiBpc0RpbWVuc2lvbihlbmMueSkpKSB7XG5cbiAgICB2YXIgYWdnciA9IGVuYy54LmFnZ3IgfHwgZW5jLnkuYWdncjtcbiAgICByZXR1cm4gIShvcHQub21pdFN0YWNrZWRBdmVyYWdlICYmIGFnZ3IgPT09J2F2ZycgJiYgZW5jLmNvbG9yKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGluZVJ1bGUoZW5jLCBzdGF0cywgb3B0KSB7XG4gIGlmKCFmYWNldHNSdWxlKGVuYywgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcblxuICAvLyBUT0RPKGthbml0dyk6IGFkZCBvbWl0VmVydGljYWxMaW5lIGFzIGNvbmZpZ1xuXG4gIC8vIEZJWE1FIHRydWx5IG9yZGluYWwgZGF0YSBpcyBmaW5lIGhlcmUgdG9vLlxuICAvLyBMaW5lIGNoYXJ0IHNob3VsZCBiZSBvbmx5IGhvcml6b250YWxcbiAgLy8gYW5kIHVzZSBvbmx5IHRlbXBvcmFsIGRhdGFcbiAgcmV0dXJuIGVuYy54LnR5cGUgPT0gJ1QnICYmIGVuYy54LmZuICYmIGVuYy55LnR5cGUgPT0gJ1EnICYmIGVuYy55LmFnZ3I7XG59XG5cbmZ1bmN0aW9uIGFyZWFSdWxlKGVuYywgc3RhdHMsIG9wdCkge1xuICBpZighZmFjZXRzUnVsZShlbmMsIHN0YXRzLCBvcHQpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYoIWxpbmVSdWxlKGVuYywgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gIShvcHQub21pdFN0YWNrZWRBdmVyYWdlICYmIGVuYy55LmFnZ3IgPT09J2F2ZycgJiYgZW5jLmNvbG9yKTtcbn1cblxuZnVuY3Rpb24gdGV4dFJ1bGUoZW5jLCBzdGF0cywgb3B0KSB7XG4gIC8vIGF0IGxlYXN0IG11c3QgaGF2ZSByb3cgb3IgY29sIGFuZCBhZ2dyZWdhdGVkIHRleHQgdmFsdWVzXG4gIHJldHVybiAoZW5jLnJvdyB8fCBlbmMuY29sKSAmJiBlbmMudGV4dCAmJiBlbmMudGV4dC5hZ2dyICYmICFlbmMueCAmJiAhZW5jLnkgJiYgIWVuYy5zaXplICYmXG4gICAgKCFvcHQuYWx3YXlzR2VuZXJhdGVUYWJsZUFzSGVhdG1hcCB8fCAhZW5jLmNvbG9yKTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBjb25zdHMgPSByZXF1aXJlKCcuLi9jb25zdHMnKSxcbiAgdmwgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy52bCA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudmwgOiBudWxsKSxcbiAgaXNEaW1lbnNpb24gPSB2bC5maWVsZC5pc0RpbWVuc2lvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBwcm9qZWN0aW9ucztcblxuLy8gVE9ETyBzdXBwb3J0IG90aGVyIG1vZGUgb2YgcHJvamVjdGlvbnMgZ2VuZXJhdGlvblxuLy8gcG93ZXJzZXQsIGNob29zZUssIGNob29zZUtvckxlc3MgYXJlIGFscmVhZHkgaW5jbHVkZWQgaW4gdGhlIHV0aWxcblxuLyoqXG4gKiBmaWVsZHNcbiAqIEBwYXJhbSAge1t0eXBlXX0gZmllbGRzIGFycmF5IG9mIGZpZWxkcyBhbmQgcXVlcnkgaW5mb3JtYXRpb25cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gcHJvamVjdGlvbnMoZmllbGRzLCBzdGF0cywgb3B0KSB7XG4gIG9wdCA9IHZsLnNjaGVtYS51dGlsLmV4dGVuZChvcHR8fHt9LCBjb25zdHMuZ2VuLnByb2plY3Rpb25zKTtcblxuICAvLyBGaXJzdCBjYXRlZ29yaXplIGZpZWxkLCBzZWxlY3RlZCwgZmllbGRzVG9BZGQsIGFuZCBzYXZlIGluZGljZXNcbiAgdmFyIHNlbGVjdGVkID0gW10sIGZpZWxkc1RvQWRkID0gW10sIGZpZWxkU2V0cyA9IFtdLFxuICAgIGhhc1NlbGVjdGVkRGltZW5zaW9uID0gZmFsc2UsXG4gICAgaGFzU2VsZWN0ZWRNZWFzdXJlID0gZmFsc2UsXG4gICAgaW5kaWNlcyA9IHt9O1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBpbmRleCl7XG4gICAgLy9zYXZlIGluZGljZXMgZm9yIHN0YWJsZSBzb3J0IGxhdGVyXG4gICAgaW5kaWNlc1tmaWVsZC5uYW1lXSA9IGluZGV4O1xuXG4gICAgaWYgKGZpZWxkLnNlbGVjdGVkKSB7XG4gICAgICBzZWxlY3RlZC5wdXNoKGZpZWxkKTtcbiAgICAgIGlmIChpc0RpbWVuc2lvbihmaWVsZCkgfHwgZmllbGQudHlwZSA9PT0nVCcpIHsgLy8gRklYTUUgLyBIQUNLXG4gICAgICAgIGhhc1NlbGVjdGVkRGltZW5zaW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1NlbGVjdGVkTWVhc3VyZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWVsZC5zZWxlY3RlZCAhPT0gZmFsc2UgJiYgIXZsLmZpZWxkLmlzQ291bnQoZmllbGQpKSB7XG4gICAgICBpZiAodmwuZmllbGQuaXNEaW1lbnNpb24oZmllbGQpICYmXG4gICAgICAgICAgIW9wdC5tYXhDYXJkaW5hbGl0eUZvckF1dG9BZGRPcmRpbmFsICYmXG4gICAgICAgICAgdmwuZmllbGQuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzLCAxNSkgPiBvcHQubWF4Q2FyZGluYWxpdHlGb3JBdXRvQWRkT3JkaW5hbFxuICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmllbGRzVG9BZGQucHVzaChmaWVsZCk7XG4gICAgfVxuICB9KTtcblxuICBmaWVsZHNUb0FkZC5zb3J0KGNvbXBhcmVGaWVsZHNUb0FkZChoYXNTZWxlY3RlZERpbWVuc2lvbiwgaGFzU2VsZWN0ZWRNZWFzdXJlLCBpbmRpY2VzKSk7XG5cbiAgdmFyIHNldHNUb0FkZCA9IHV0aWwuY2hvb3NlS29yTGVzcyhmaWVsZHNUb0FkZCwgMSk7XG5cbiAgc2V0c1RvQWRkLmZvckVhY2goZnVuY3Rpb24oc2V0VG9BZGQpIHtcbiAgICB2YXIgZmllbGRTZXQgPSBzZWxlY3RlZC5jb25jYXQoc2V0VG9BZGQpO1xuICAgIGlmIChmaWVsZFNldC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAob3B0Lm9taXREb3RQbG90ICYmIGZpZWxkU2V0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuO1xuICAgICAgZmllbGRTZXRzLnB1c2goZmllbGRTZXQpO1xuICAgIH1cbiAgfSk7XG5cbiAgZmllbGRTZXRzLmZvckVhY2goZnVuY3Rpb24oZmllbGRTZXQpIHtcbiAgICAgIC8vIGFsd2F5cyBhcHBlbmQgcHJvamVjdGlvbidzIGtleSB0byBlYWNoIHByb2plY3Rpb24gcmV0dXJuZWQsIGQzIHN0eWxlLlxuICAgIGZpZWxkU2V0LmtleSA9IHByb2plY3Rpb25zLmtleShmaWVsZFNldCk7XG4gIH0pO1xuXG4gIHJldHVybiBmaWVsZFNldHM7XG59XG5cbnZhciB0eXBlSXNNZWFzdXJlU2NvcmUgPSB7XG4gIE86IDAsXG4gIFQ6IDEsXG4gIFE6IDJcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVGaWVsZHNUb0FkZChoYXNTZWxlY3RlZERpbWVuc2lvbiwgaGFzU2VsZWN0ZWRNZWFzdXJlLCBpbmRpY2VzKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAvLyBzb3J0IGJ5IHR5cGUgb2YgdGhlIGRhdGFcbiAgICBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICAgIGlmICghaGFzU2VsZWN0ZWREaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVJc01lYXN1cmVTY29yZVthLnR5cGVdIC0gdHlwZUlzTWVhc3VyZVNjb3JlW2IudHlwZV07XG4gICAgICB9IGVsc2UgaWYgKCFoYXNTZWxlY3RlZE1lYXN1cmUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVJc01lYXN1cmVTY29yZVtiLnR5cGVdIC0gdHlwZUlzTWVhc3VyZVNjb3JlW2EudHlwZV07XG4gICAgICB9XG4gICAgfVxuICAgIC8vbWFrZSB0aGUgc29ydCBzdGFibGVcbiAgICByZXR1cm4gaW5kaWNlc1thLm5hbWVdIC0gaW5kaWNlc1tiLm5hbWVdO1xuICB9O1xufVxuXG5wcm9qZWN0aW9ucy5rZXkgPSBmdW5jdGlvbihwcm9qZWN0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICAgIHJldHVybiB2bC5maWVsZC5pc0NvdW50KGZpZWxkKSA/ICdjb3VudCcgOiBmaWVsZC5uYW1lO1xuICB9KS5qb2luKCcsJyk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnID0gZ2xvYmFsIHx8IHdpbmRvdztcblxuZy5DSEFSVF9UWVBFUyA9IHtcbiAgVEFCTEU6ICdUQUJMRScsXG4gIEJBUjogJ0JBUicsXG4gIFBMT1Q6ICdQTE9UJyxcbiAgTElORTogJ0xJTkUnLFxuICBBUkVBOiAnQVJFQScsXG4gIE1BUDogJ01BUCcsXG4gIEhJU1RPR1JBTTogJ0hJU1RPR1JBTSdcbn07XG5cbmcuQU5ZX0RBVEFfVFlQRVMgPSAoMSA8PCA0KSAtIDE7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuY29kaW5nOiByZXF1aXJlKCcuL3JhbmtFbmNvZGluZ3MnKVxufTtcblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnZsIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC52bCA6IG51bGwpLFxuICBpc0RpbWVuc2lvbiA9IHZsLmZpZWxkLmlzRGltZW5zaW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmtFbmNvZGluZ3M7XG5cbi8vIGJhZCBzY29yZSBub3Qgc3BlY2lmaWVkIGluIHRoZSB0YWJsZSBhYm92ZVxudmFyIFVOVVNFRF9QT1NJVElPTiA9IDAuNTtcblxudmFyIE1BUktfU0NPUkUgPSB7XG4gIGxpbmU6IDAuOTksXG4gIGFyZWE6IDAuOTgsXG4gIGJhcjogMC45NyxcbiAgdGljazogMC45NixcbiAgcG9pbnQ6IDAuOTUsXG4gIGNpcmNsZTogMC45NCxcbiAgc3F1YXJlOiAwLjk0LFxuICB0ZXh0OiAwLjhcbn07XG5cbmZ1bmN0aW9uIHJhbmtFbmNvZGluZ3MoZW5jb2RpbmcsIHN0YXRzLCBvcHQsIHNlbGVjdGVkKSB7XG4gIHZhciBmZWF0dXJlcyA9IFtdLFxuICAgIGVuY1R5cGVzID0gdmwua2V5cyhlbmNvZGluZy5lbmMpLFxuICAgIG1hcmt0eXBlID0gZW5jb2RpbmcubWFya3R5cGUsXG4gICAgZW5jID0gZW5jb2RpbmcuZW5jO1xuXG4gIHZhciBlbmNvZGluZ01hcHBpbmdCeUZpZWxkID0gdmwuZW5jLnJlZHVjZShlbmNvZGluZy5lbmMsIGZ1bmN0aW9uKG8sIGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgdmFyIGtleSA9IHZsLmZpZWxkLnNob3J0aGFuZChmaWVsZCk7XG4gICAgdmFyIG1hcHBpbmdzID0gb1trZXldID0gb1trZXldIHx8IFtdO1xuICAgIG1hcHBpbmdzLnB1c2goe2VuY1R5cGU6IGVuY1R5cGUsIGZpZWxkOiBmaWVsZH0pO1xuICAgIHJldHVybiBvO1xuICB9LCB7fSk7XG5cbiAgLy8gZGF0YSAtIGVuY29kaW5nIG1hcHBpbmcgc2NvcmVcbiAgdmwuZm9yRWFjaChlbmNvZGluZ01hcHBpbmdCeUZpZWxkLCBmdW5jdGlvbihtYXBwaW5ncykge1xuICAgIHZhciByZWFzb25zID0gbWFwcGluZ3MubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIG0uZW5jVHlwZSArIHZsLnNob3J0aGFuZC5hc3NpZ24gKyB2bC5maWVsZC5zaG9ydGhhbmQobS5maWVsZCkgK1xuICAgICAgICAgICcgJyArIChzZWxlY3RlZCAmJiBzZWxlY3RlZFttLmZpZWxkLm5hbWVdID8gJ1t4XScgOiAnWyBdJyk7XG4gICAgICB9KSxcbiAgICAgIHNjb3JlcyA9IG1hcHBpbmdzLm1hcChmdW5jdGlvbihtKSB7XG4gICAgICAgIHZhciByb2xlID0gdmwuZmllbGQucm9sZShtLmZpZWxkKTtcbiAgICAgICAgdmFyIHNjb3JlID0gcmFua0VuY29kaW5ncy5zY29yZVtyb2xlXShtLmZpZWxkLCBtLmVuY1R5cGUsIGVuY29kaW5nLm1hcmt0eXBlLCBzdGF0cywgb3B0KTtcblxuICAgICAgICByZXR1cm4gIXNlbGVjdGVkIHx8IHNlbGVjdGVkW20uZmllbGQubmFtZV0gPyBzY29yZSA6IE1hdGgucG93KHNjb3JlLCAwLjEyNSk7XG4gICAgICB9KTtcblxuICAgIGZlYXR1cmVzLnB1c2goe1xuICAgICAgcmVhc29uOiByZWFzb25zLmpvaW4oXCIgfCBcIiksXG4gICAgICBzY29yZTogTWF0aC5tYXguYXBwbHkobnVsbCwgc2NvcmVzKVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBwbG90IHR5cGVcbiAgaWYgKG1hcmt0eXBlID09PSAndGV4dCcpIHtcbiAgICAvLyBUT0RPXG4gIH0gZWxzZSB7XG4gICAgaWYgKGVuYy54ICYmIGVuYy55KSB7XG4gICAgICBpZiAoaXNEaW1lbnNpb24oZW5jLngpIF4gaXNEaW1lbnNpb24oZW5jLnkpKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goe1xuICAgICAgICAgIHJlYXNvbjogJ094USBwbG90JyxcbiAgICAgICAgICBzY29yZTogMC44XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHBlbmFsaXplIG5vdCB1c2luZyBwb3NpdGlvbmFsIG9ubHkgcGVuYWxpemUgZm9yIG5vbi10ZXh0XG4gIGlmIChlbmNUeXBlcy5sZW5ndGggPiAxICYmIG1hcmt0eXBlICE9PSAndGV4dCcpIHtcbiAgICBpZiAoKCFlbmMueCB8fCAhZW5jLnkpICYmICFlbmMuZ2VvICYmICFlbmMudGV4dCkge1xuICAgICAgZmVhdHVyZXMucHVzaCh7XG4gICAgICAgIHJlYXNvbjogJ3VudXNlZCBwb3NpdGlvbicsXG4gICAgICAgIHNjb3JlOiBVTlVTRURfUE9TSVRJT05cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1hcmsgdHlwZSBzY29yZVxuICBmZWF0dXJlcy5wdXNoKHtcbiAgICByZWFzb246ICdtYXJrdHlwZT0nK21hcmt0eXBlLFxuICAgIHNjb3JlOiBNQVJLX1NDT1JFW21hcmt0eXBlXVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHNjb3JlOiBmZWF0dXJlcy5yZWR1Y2UoZnVuY3Rpb24ocCwgZikge1xuICAgICAgcmV0dXJuIHAgKiBmLnNjb3JlO1xuICAgIH0sIDEpLFxuICAgIGZlYXR1cmVzOiBmZWF0dXJlc1xuICB9O1xufVxuXG5cbnZhciBEID0ge30sIE0gPSB7fSwgQkFEID0gMC4xLCBURVJSSUJMRSA9IDAuMDE7XG5cbkQubWlub3IgPSAwLjAxO1xuRC5wb3MgPSAxO1xuRC5ZX1QgPSAwLjg7XG5ELmZhY2V0X3RleHQgPSAxO1xuRC5mYWNldF9nb29kID0gMC42NzU7IC8vIDwgY29sb3Jfb2ssID4gY29sb3JfYmFkXG5ELmZhY2V0X29rID0gMC41NTtcbkQuZmFjZXRfYmFkID0gMC40O1xuRC5jb2xvcl9nb29kID0gMC43O1xuRC5jb2xvcl9vayA9IDAuNjU7IC8vID4gTS5TaXplXG5ELmNvbG9yX2JhZCA9IDAuMztcbkQuY29sb3Jfc3RhY2sgPSAwLjY7XG5ELnNoYXBlID0gMC42O1xuRC5kZXRhaWwgPSAwLjU7XG5ELmJhZCA9IEJBRDtcbkQudGVycmlibGUgPSBURVJSSUJMRTtcblxuTS5wb3MgPSAxO1xuTS5zaXplID0gMC42O1xuTS5jb2xvciA9IDAuNTtcbk0uYWxwaGEgPSAwLjQ1O1xuTS50ZXh0ID0gMC40O1xuTS5iYWQgPSBCQUQ7XG5NLnRlcnJpYmxlID0gVEVSUklCTEU7XG5cbnJhbmtFbmNvZGluZ3MuZGltZW5zaW9uU2NvcmUgPSBmdW5jdGlvbiAoZmllbGQsIGVuY1R5cGUsIG1hcmt0eXBlLCBzdGF0cywgb3B0KXtcbiAgdmFyIGNhcmRpbmFsaXR5ID0gdmwuZmllbGQuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzKTtcbiAgc3dpdGNoIChlbmNUeXBlKSB7XG4gICAgY2FzZSAneCc6XG4gICAgICBpZihmaWVsZC50eXBlID09PSAnTycpIHJldHVybiBELnBvcyAtIEQubWlub3I7XG4gICAgICByZXR1cm4gRC5wb3M7XG5cbiAgICBjYXNlICd5JzpcbiAgICAgIGlmKGZpZWxkLnR5cGUgPT09ICdPJykgcmV0dXJuIEQucG9zIC0gRC5taW5vcjsgLy9wcmVmZXIgb3JkaW5hbCBvbiB5XG4gICAgICBpZihmaWVsZC50eXBlID09PSAnVCcpIHJldHVybiBELllfVDsgLy8gdGltZSBzaG91bGQgbm90IGJlIG9uIFlcbiAgICAgIHJldHVybiBELnBvcyAtIEQubWlub3I7XG5cbiAgICBjYXNlICdjb2wnOlxuICAgICAgaWYgKG1hcmt0eXBlID09PSAndGV4dCcpIHJldHVybiBELmZhY2V0X3RleHQ7XG4gICAgICAvL3ByZWZlciBjb2x1bW4gb3ZlciByb3cgZHVlIHRvIHNjcm9sbGluZyBpc3N1ZXNcbiAgICAgIHJldHVybiBjYXJkaW5hbGl0eSA8PSBvcHQubWF4R29vZENhcmRpbmFsaXR5Rm9yRmFjZXRzID8gRC5mYWNldF9nb29kIDpcbiAgICAgICAgY2FyZGluYWxpdHkgPD0gb3B0Lm1heENhcmRpbmFsaXR5Rm9yRmFjZXRzID8gRC5mYWNldF9vayA6IEQuZmFjZXRfYmFkO1xuXG4gICAgY2FzZSAncm93JzpcbiAgICAgIGlmIChtYXJrdHlwZSA9PT0gJ3RleHQnKSByZXR1cm4gRC5mYWNldF90ZXh0O1xuICAgICAgcmV0dXJuIChjYXJkaW5hbGl0eSA8PSBvcHQubWF4R29vZENhcmRpbmFsaXR5Rm9yRmFjZXRzID8gRC5mYWNldF9nb29kIDpcbiAgICAgICAgY2FyZGluYWxpdHkgPD0gb3B0Lm1heENhcmRpbmFsaXR5Rm9yRmFjZXRzID8gRC5mYWNldF9vayA6IEQuZmFjZXRfYmFkKSAtIEQubWlub3I7XG5cbiAgICBjYXNlICdjb2xvcic6XG4gICAgICB2YXIgaGFzT3JkZXIgPSAoZmllbGQuYmluICYmIGZpZWxkLnR5cGU9PT0nUScpIHx8IChmaWVsZC5mbiAmJiBmaWVsZC50eXBlPT09J1QnKTtcblxuICAgICAgLy9GSVhNRSBhZGQgc3RhY2tpbmcgb3B0aW9uIG9uY2Ugd2UgaGF2ZSBjb250cm9sIC4uXG4gICAgICB2YXIgaXNTdGFja2VkID0gbWFya3R5cGUgPT09J2JhcicgfHwgbWFya3R5cGUgPT09J2FyZWEnO1xuXG4gICAgICAvLyB0cnVlIG9yZGluYWwgb24gY29sb3IgaXMgY3VycmVudGx5IEJBRCAodW50aWwgd2UgaGF2ZSBnb29kIG9yZGluYWwgY29sb3Igc2NhbGUgc3VwcG9ydClcbiAgICAgIGlmIChoYXNPcmRlcikgcmV0dXJuIEQuY29sb3JfYmFkO1xuXG4gICAgICAvL3N0YWNraW5nIGdldHMgbG93ZXIgc2NvcmVcbiAgICAgIGlmIChpc1N0YWNrZWQpIHJldHVybiBELmNvbG9yX3N0YWNrO1xuXG4gICAgICByZXR1cm4gY2FyZGluYWxpdHkgPD0gb3B0Lm1heEdvb2RDYXJkaW5hbGl0eUZvckNvbG9yID8gRC5jb2xvcl9nb29kOiBjYXJkaW5hbGl0eSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JDb2xvciA/IEQuY29sb3Jfb2sgOiBELmNvbG9yX2JhZDtcbiAgICBjYXNlICdzaGFwZSc6XG4gICAgICByZXR1cm4gY2FyZGluYWxpdHkgPD0gb3B0Lm1heENhcmRpbmFsaXR5Rm9yU2hhcGUgPyBELnNoYXBlIDogVEVSUklCTEU7XG4gICAgY2FzZSAnZGV0YWlsJzpcbiAgICAgIHJldHVybiBELmRldGFpbDtcbiAgfVxuICByZXR1cm4gVEVSUklCTEU7XG59O1xuXG5yYW5rRW5jb2RpbmdzLmRpbWVuc2lvblNjb3JlLmNvbnN0cyA9IEQ7XG5cbnJhbmtFbmNvZGluZ3MubWVhc3VyZVNjb3JlID0gZnVuY3Rpb24gKGZpZWxkLCBlbmNUeXBlLCBtYXJrdHlwZSwgc3RhdHMsIG9wdCkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHN3aXRjaCAoZW5jVHlwZSl7XG4gICAgY2FzZSAneCc6IHJldHVybiBNLnBvcztcbiAgICBjYXNlICd5JzogcmV0dXJuIE0ucG9zO1xuICAgIGNhc2UgJ3NpemUnOlxuICAgICAgaWYgKG1hcmt0eXBlID09PSAnYmFyJykgcmV0dXJuIEJBRDsgLy9zaXplIG9mIGJhciBpcyB2ZXJ5IGJhZFxuICAgICAgaWYgKG1hcmt0eXBlID09PSAndGV4dCcpIHJldHVybiBCQUQ7XG4gICAgICBpZiAobWFya3R5cGUgPT09ICdsaW5lJykgcmV0dXJuIEJBRDtcbiAgICAgIHJldHVybiBNLnNpemU7XG4gICAgY2FzZSAnY29sb3InOiByZXR1cm4gTS5jb2xvcjtcbiAgICBjYXNlICdhbHBoYSc6IHJldHVybiBNLmFscGhhO1xuICAgIGNhc2UgJ3RleHQnOiByZXR1cm4gTS50ZXh0O1xuICB9XG4gIHJldHVybiBCQUQ7XG59O1xuXG5yYW5rRW5jb2RpbmdzLm1lYXN1cmVTY29yZS5jb25zdHMgPSBNO1xuXG5cbnJhbmtFbmNvZGluZ3Muc2NvcmUgPSB7XG4gIGRpbWVuc2lvbjogcmFua0VuY29kaW5ncy5kaW1lbnNpb25TY29yZSxcbiAgbWVhc3VyZTogcmFua0VuY29kaW5ncy5tZWFzdXJlU2NvcmUsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpO1xuXG52YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBnZW46IHt9XG59O1xuXG51dGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudXRpbC5qc29uID0gZnVuY3Rpb24ocywgc3ApIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHMsIG51bGwsIHNwKTtcbn07XG5cbnV0aWwua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgayA9IFtdLCB4O1xuICBmb3IgKHggaW4gb2JqKSBrLnB1c2goeCk7XG4gIHJldHVybiBrO1xufTtcblxudXRpbC5uZXN0ZWRNYXAgPSBmdW5jdGlvbiAoY29sLCBmLCBsZXZlbCwgZmlsdGVyKSB7XG4gIHJldHVybiBsZXZlbCA9PT0gMCA/XG4gICAgY29sLm1hcChmKSA6XG4gICAgY29sLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgciA9IHV0aWwubmVzdGVkTWFwKHYsIGYsIGxldmVsIC0gMSk7XG4gICAgICByZXR1cm4gZmlsdGVyID8gci5maWx0ZXIodXRpbC5ub25FbXB0eSkgOiByO1xuICAgIH0pO1xufTtcblxudXRpbC5uZXN0ZWRSZWR1Y2UgPSBmdW5jdGlvbiAoY29sLCBmLCBsZXZlbCwgZmlsdGVyKSB7XG4gIHJldHVybiBsZXZlbCA9PT0gMCA/XG4gICAgY29sLnJlZHVjZShmLCBbXSkgOlxuICAgIGNvbC5tYXAoZnVuY3Rpb24odikge1xuICAgICAgdmFyIHIgPSB1dGlsLm5lc3RlZFJlZHVjZSh2LCBmLCBsZXZlbCAtIDEpO1xuICAgICAgcmV0dXJuIGZpbHRlciA/IHIuZmlsdGVyKHV0aWwubm9uRW1wdHkpIDogcjtcbiAgICB9KTtcbn07XG5cbnV0aWwubm9uRW1wdHkgPSBmdW5jdGlvbihncnApIHtcbiAgcmV0dXJuICF1dGlsLmlzQXJyYXkoZ3JwKSB8fCBncnAubGVuZ3RoID4gMDtcbn07XG5cblxudXRpbC50cmF2ZXJzZSA9IGZ1bmN0aW9uIChub2RlLCBhcnIpIHtcbiAgaWYgKG5vZGUudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGFyci5wdXNoKG5vZGUudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChub2RlLmxlZnQpIHV0aWwudHJhdmVyc2Uobm9kZS5sZWZ0LCBhcnIpO1xuICAgIGlmIChub2RlLnJpZ2h0KSB1dGlsLnRyYXZlcnNlKG5vZGUucmlnaHQsIGFycik7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbnV0aWwudW5pb24gPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgbyA9IHt9O1xuICBhLmZvckVhY2goZnVuY3Rpb24oeCkgeyBvW3hdID0gdHJ1ZTt9KTtcbiAgYi5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgb1t4XSA9IHRydWU7fSk7XG4gIHJldHVybiB1dGlsLmtleXMobyk7XG59O1xuXG5cbnV0aWwuZ2VuLmdldE9wdCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgLy9tZXJnZSB3aXRoIGRlZmF1bHRcbiAgcmV0dXJuIChvcHQgPyB1dGlsLmtleXMob3B0KSA6IFtdKS5yZWR1Y2UoZnVuY3Rpb24oYywgaykge1xuICAgIGNba10gPSBvcHRba107XG4gICAgcmV0dXJuIGM7XG4gIH0sIE9iamVjdC5jcmVhdGUoY29uc3RzLmdlbi5ERUZBVUxUX09QVCkpO1xufTtcblxuLyoqXG4gKiBwb3dlcnNldCBjb2RlIGZyb20gaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL1Bvd2VyX1NldCNKYXZhU2NyaXB0XG4gKlxuICogICB2YXIgcmVzID0gcG93ZXJzZXQoWzEsMiwzLDRdKTtcbiAqXG4gKiByZXR1cm5zXG4gKlxuICogW1tdLFsxXSxbMl0sWzEsMl0sWzNdLFsxLDNdLFsyLDNdLFsxLDIsM10sWzRdLFsxLDRdLFxuICogWzIsNF0sWzEsMiw0XSxbMyw0XSxbMSwzLDRdLFsyLDMsNF0sWzEsMiwzLDRdXVxuW2VkaXRdXG4qL1xuXG51dGlsLnBvd2Vyc2V0ID0gZnVuY3Rpb24obGlzdCkge1xuICB2YXIgcHMgPSBbXG4gICAgW11cbiAgXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IHBzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBwcy5wdXNoKHBzW2pdLmNvbmNhdChsaXN0W2ldKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcztcbn07XG5cbnV0aWwuY2hvb3NlS29yTGVzcyA9IGZ1bmN0aW9uKGxpc3QsIGspIHtcbiAgdmFyIHN1YnNldCA9IFtbXV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBzdWJzZXQubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBzdWIgPSBzdWJzZXRbal0uY29uY2F0KGxpc3RbaV0pO1xuICAgICAgaWYoc3ViLmxlbmd0aCA8PSBrKXtcbiAgICAgICAgc3Vic2V0LnB1c2goc3ViKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1YnNldDtcbn07XG5cbnV0aWwuY2hvb3NlSyA9IGZ1bmN0aW9uKGxpc3QsIGspIHtcbiAgdmFyIHN1YnNldCA9IFtbXV07XG4gIHZhciBrQXJyYXkgPVtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gc3Vic2V0Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgc3ViID0gc3Vic2V0W2pdLmNvbmNhdChsaXN0W2ldKTtcbiAgICAgIGlmKHN1Yi5sZW5ndGggPCBrKXtcbiAgICAgICAgc3Vic2V0LnB1c2goc3ViKTtcbiAgICAgIH1lbHNlIGlmIChzdWIubGVuZ3RoID09PSBrKXtcbiAgICAgICAga0FycmF5LnB1c2goc3ViKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtBcnJheTtcbn07XG5cbnV0aWwuY3Jvc3MgPSBmdW5jdGlvbihhLGIpe1xuICB2YXIgeCA9IFtdO1xuICBmb3IodmFyIGk9MDsgaTwgYS5sZW5ndGg7IGkrKyl7XG4gICAgZm9yKHZhciBqPTA7ajwgYi5sZW5ndGg7IGorKyl7XG4gICAgICB4LnB1c2goYVtpXS5jb25jYXQoYltqXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn07XG5cbiJdfQ==\n","module.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};","module.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};","var distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n","var distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}","\"use strict\";\n\nmodule.exports = cluster;\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  clusterfck = require('clusterfck'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\ncluster.distance = require('./distance');\n\nfunction cluster(encodings, opt) {\n  // jshint unused:false\n  var dist = cluster.distance.table(encodings);\n\n  var clusterTrees = clusterfck.hcluster(encodings, function(e1, e2) {\n    var s1 = vl.Encoding.shorthand(e1),\n      s2 = vl.Encoding.shorthand(e2);\n    return dist[s1][s2];\n  }, 'average', consts.CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n      return util.traverse(tree, []);\n    })\n   .map(function(cluster) {\n    return cluster.sort(function(encoding1, encoding2) {\n      // sort each cluster -- have the highest score as 1st item\n      return encoding2.score - encoding1.score;\n    });\n  }).filter(function(cluster) {  // filter empty cluster\n    return cluster.length >0;\n  }).sort(function(cluster1, cluster2) {\n    //sort by highest scoring item in each cluster\n    return cluster2[0].score - cluster1[0].score;\n  });\n\n  clusters.dist = dist; //append dist in the array for debugging\n\n  return clusters;\n}","'use strict';\n\nvar c = module.exports = {};\n\nc.SWAPPABLE = 0.05;\nc.DIST_MISSING = 1;\nc.CLUSTER_THRESHOLD = 1;\n\nfunction reduceTupleToTable(r, x) {\n  var a = x[0], b = x[1], d = x[2];\n  r[a] = r[a] || {};\n  r[b] = r[b] || {};\n  r[a][b] = r[b][a] = d;\n  return r;\n}\n\nc.DIST_BY_ENCTYPE = [\n  // positional\n  ['x', 'y', c.SWAPPABLE],\n  ['row', 'col', c.SWAPPABLE],\n\n  // ordinal mark properties\n  ['color', 'shape', c.SWAPPABLE],\n  ['color', 'detail', c.SWAPPABLE],\n  ['detail', 'shape', c.SWAPPABLE],\n\n  // quantitative mark properties\n  ['color', 'alpha', c.SWAPPABLE],\n  ['size', 'alpha', c.SWAPPABLE],\n  ['size', 'color', c.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\nvar distance = {};\nmodule.exports = distance;\n\ndistance.table = function (encodings) {\n  var len = encodings.length,\n    colencs = encodings.map(function(e) { return distance.getEncTypeByColumnName(e); }),\n    shorthands = encodings.map(vl.Encoding.shorthand),\n    diff = {}, i, j;\n\n  for (i = 0; i < len; i++) diff[shorthands[i]] = {};\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      var sj = shorthands[j], si = shorthands[i];\n\n      diff[sj][si] = diff[si][sj] = distance.get(colencs[i], colencs[j]);\n    }\n  }\n  return diff;\n};\n\ndistance.get = function (colenc1, colenc2) {\n  var cols = util.union(vl.keys(colenc1.col), vl.keys(colenc2.col)),\n    dist = 0;\n\n  cols.forEach(function(col) {\n    var e1 = colenc1.col[col], e2 = colenc2.col[col];\n\n    if (e1 && e2) {\n      if (e1.encType != e2.encType) {\n        dist += (consts.DIST_BY_ENCTYPE[e1.encType] || {})[e2.encType] || 1;\n      }\n    } else {\n      dist += consts.DIST_MISSING;\n    }\n  });\n\n  // do not group stacked chart with similar non-stacked chart!\n  var isStack1 = vl.Encoding.isStack(colenc1),\n    isStack2 = vl.Encoding.isStack(colenc2);\n\n  if(isStack1 || isStack2) {\n    if(isStack1 && isStack2) {\n      if(colenc1.enc.color.name !== colenc2.enc.color.name) {\n        dist+=1;\n      }\n    } else {\n      dist+=1; // surely different\n    }\n  }\n  return dist;\n};\n\n// get encoding type by fieldname\ndistance.getEncTypeByColumnName = function(encoding) {\n  var _colenc = {},\n    enc = encoding.enc;\n\n  vl.keys(enc).forEach(function(encType) {\n    var e = vl.duplicate(enc[encType]);\n    e.encType = encType;\n    _colenc[e.name || ''] = e;\n    delete e.name;\n  });\n\n  return {\n    marktype: encoding.marktype,\n    col: _colenc,\n    enc: encoding.enc\n  };\n};","'use strict';\n\nvar consts = module.exports = {\n  gen: {},\n  cluster: {},\n  rank: {}\n};\n\nconsts.gen.projections = {\n  type: 'object',\n  properties: {\n    omitDotPlot: { //FIXME remove this!\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    maxCardinalityForAutoAddOrdinal: {\n      type: 'integer',\n      default: 50,\n      description: 'max cardinality for ordinal field to be considered for auto adding'\n    },\n    alwaysAddHistogram: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nconsts.gen.aggregates = {\n  type: 'object',\n  properties: {\n    config: {\n      type: 'object'\n    },\n    data: {\n      type: 'object'\n    },\n    tableTypes: {\n      type: 'boolean',\n      default: 'both',\n      enum: ['both', 'aggregated', 'disaggregated']\n    },\n    genDimQ: {\n      type: 'string',\n      default: 'auto',\n      enum: ['auto', 'bin', 'cast', 'none'],\n      description: 'Use Q as Dimension either by binning or casting'\n    },\n    minCardinalityForBin: {\n      type: 'integer',\n      default: 20,\n      description: 'minimum cardinality of a field if we were to bin'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitMeasureOnly: {\n      type: 'boolean',\n      default: false,\n      description: 'Omit aggregation with measure(s) only'\n    },\n    omitDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Omit aggregation with dimension(s) only'\n    },\n    addCountForDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Add count when there are dimension(s) only'\n    },\n    aggrList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: [undefined, 'avg']\n    },\n    timeFnList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: ['year']\n    },\n    consistentAutoQ: {\n      type: 'boolean',\n      default: true,\n      description: \"generate similar auto transform for quant\"\n    }\n  }\n};\n\nconsts.gen.encodings = {\n  type: 'object',\n  properties: {\n    marktypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['point', 'bar', 'line', 'area', 'text', 'tick'], //filled_map\n      description: 'allowed marktypes'\n    },\n    encodingTypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['x', 'y', 'row', 'col', 'size', 'color', 'text', 'detail'],\n      description: 'allowed encoding types'\n    },\n    maxGoodCardinalityForFacets: {\n      type: 'integer',\n      default: 5,\n      description: 'maximum cardinality of a field to be put on facet (row/col) effectively'\n    },\n    maxCardinalityForFacets: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of a field to be put on facet (row/col)'\n    },\n    maxGoodCardinalityForColor: {\n      type: 'integer',\n      default: 7,\n      description: 'maximum cardinality of an ordinal field to be put on color effectively'\n    },\n    maxCardinalityForColor: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal field to be put on color'\n    },\n    maxCardinalityForShape: {\n      type: 'integer',\n      default: 6,\n      description: 'maximum cardinality of an ordinal field to be put on shape'\n    },\n    omitTranpose:  {\n      type: 'boolean',\n      default: true,\n      description: 'Eliminate all transpose by (1) keeping horizontal dot plot only (2) for OxQ charts, always put O on Y (3) show only one DxD, MxM (currently sorted by name)'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitDotPlotWithExtraEncoding: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all dot plots with >1 encoding'\n    },\n    omitMultipleRetinalEncodings: {\n      type: 'boolean',\n      default: true,\n      description: 'omit using multiple retinal variables (size, color, alpha, shape)'\n    },\n    omitNonTextAggrWithAllDimsOnFacets: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all aggregated charts (except text tables) with all dims on facets (row, col)'\n    },\n    omitSizeOnBar: {\n      type: 'boolean',\n      default: false,\n      description: 'do not use bar\\'s size'\n    },\n    omitStackedAverage: {\n      type: 'boolean',\n      default: true,\n      description: 'do not stack bar chart with average'\n    },\n    alwaysGenerateTableAsHeatmap: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\n\n\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null);\n\nvar consts = require('../consts');\n\nvar ANY='*';\n\nmodule.exports = genAggregates;\n\nfunction genAggregates(output, fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.aggregates);\n  var tf = new Array(fields.length);\n  var hasO = vl.any(fields, function(f) {\n    return f.type === 'O';\n  });\n\n  function emit(fieldSet) {\n    fieldSet = vl.duplicate(fieldSet);\n    fieldSet.key = vl.field.shorthands(fieldSet);\n    output.push(fieldSet);\n  }\n\n  function checkAndPush() {\n    if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n      var hasMeasure = false, hasDimension = false, hasRaw = false;\n      tf.forEach(function(f) {\n        if (vl.field.isDimension(f)) {\n          hasDimension = true;\n        } else {\n          hasMeasure = true;\n          if (!f.aggr) hasRaw = true;\n        }\n      });\n      if (!hasDimension && !hasRaw && opt.omitMeasureOnly) return;\n      if (!hasMeasure) {\n        if (opt.addCountForDimensionOnly) {\n          tf.push(vl.field.count());\n          emit(tf);\n          tf.pop();\n        }\n        if (opt.omitDimensionOnly) return;\n      }\n    }\n    if (opt.omitDotPlot && tf.length === 1) return;\n    emit(tf);\n  }\n\n  function assignAggrQ(i, hasAggr, autoMode, a) {\n    var canHaveAggr = hasAggr === true || hasAggr === null,\n      cantHaveAggr = hasAggr === false || hasAggr === null;\n    if (a) {\n      if (canHaveAggr) {\n        tf[i].aggr = a;\n        assignField(i + 1, true, autoMode);\n        delete tf[i].aggr;\n      }\n    } else { // if(a === undefined)\n      if (cantHaveAggr) {\n        assignField(i + 1, false, autoMode);\n      }\n    }\n  }\n\n  function assignBinQ(i, hasAggr, autoMode) {\n    tf[i].bin = true;\n    assignField(i + 1, hasAggr, autoMode);\n    delete tf[i].bin;\n  }\n\n  function assignQ(i, hasAggr, autoMode) {\n    var f = fields[i],\n      canHaveAggr = hasAggr === true || hasAggr === null;\n\n    tf[i] = {name: f.name, type: f.type};\n\n    if (f.aggr === 'count') { // if count is included in the selected fields\n      if (canHaveAggr) {\n        tf[i].aggr = f.aggr;\n        assignField(i + 1, true, autoMode);\n      }\n    } else if (f._aggr) {\n      // TODO support array of f._aggrs too\n      assignAggrQ(i, hasAggr, autoMode, f._aggr);\n    } else if (f._raw) {\n      assignAggrQ(i, hasAggr, autoMode, undefined);\n    } else if (f._bin) {\n      assignBinQ(i, hasAggr, autoMode);\n    } else {\n      opt.aggrList.forEach(function(a) {\n        if (!opt.consistentAutoQ || autoMode === ANY || autoMode === a) {\n          assignAggrQ(i, hasAggr, a /*assign autoMode*/, a);\n        }\n      });\n\n      if ((!opt.consistentAutoQ || vl.isin(autoMode, [ANY, 'bin', 'cast', 'autocast'])) && !hasO) {\n        var highCardinality = vl.field.cardinality(f, stats) > opt.minCardinalityForBin;\n\n        var isAuto = opt.genDimQ === 'auto',\n          genBin = opt.genDimQ  === 'bin' || (isAuto && highCardinality),\n          genCast = opt.genDimQ === 'cast' || (isAuto && !highCardinality);\n\n        if (genBin && vl.isin(autoMode, [ANY, 'bin', 'autocast'])) {\n          assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n        }\n        if (genCast && vl.isin(autoMode, [ANY, 'cast', 'autocast'])) {\n          tf[i].type = 'O';\n          assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n          tf[i].type = 'Q';\n        }\n      }\n    }\n  }\n\n  function assignFnT(i, hasAggr, autoMode, fn) {\n    tf[i].fn = fn;\n    assignField(i+1, hasAggr, autoMode);\n    delete tf[i].fn;\n  }\n\n  function assignT(i, hasAggr, autoMode) {\n    var f = fields[i];\n    tf[i] = {name: f.name, type: f.type};\n\n    // TODO support array of f._fns\n    if (f._fn) {\n      assignFnT(i, hasAggr, autoMode, f._fn);\n    } else {\n      opt.timeFnList.forEach(function(fn) {\n        if (fn === undefined) {\n          if (!hasAggr) { // can't aggregate over raw time\n            assignField(i+1, false, autoMode);\n          }\n        } else {\n          assignFnT(i, hasAggr, autoMode, fn);\n        }\n      });\n    }\n\n    // FIXME what if you aggregate time?\n  }\n\n  function assignField(i, hasAggr, autoMode) {\n    if (i === fields.length) { // If all fields are assigned\n      checkAndPush();\n      return;\n    }\n\n    var f = fields[i];\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case 'Q':\n        assignQ(i, hasAggr, autoMode);\n        break;\n\n      case 'T':\n        assignT(i, hasAggr, autoMode);\n        break;\n\n      case 'O':\n        /* falls through */\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr, autoMode);\n        break;\n    }\n  }\n\n  var hasAggr = opt.tableTypes === 'aggregated' ? true : opt.tableTypes === 'disaggregated' ? false : null;\n  assignField(0, hasAggr, ANY);\n\n  return output;\n}\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  genEncs = require('./encs'),\n  getMarktypes = require('./marktypes'),\n  rank = require('../rank/rank'),\n  consts = require('../consts');\n\nmodule.exports = genEncodingsFromFields;\n\nfunction genEncodingsFromFields(output, fields, stats, opt, nested) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  var encs = genEncs([], fields, stats, opt);\n\n  if (nested) {\n    return encs.reduce(function(dict, enc) {\n      dict[enc] = genEncodingsFromEncs([], enc, stats, opt);\n      return dict;\n    }, {});\n  } else {\n    return encs.reduce(function(list, enc) {\n      return genEncodingsFromEncs(list, enc, stats, opt);\n    }, []);\n  }\n}\n\nfunction genEncodingsFromEncs(output, enc, stats, opt) {\n  getMarktypes(enc, stats, opt)\n    .forEach(function(markType) {\n      var e = vl.duplicate({\n          data: opt.data,\n          marktype: markType,\n          enc: enc,\n          config: opt.config\n        }),\n        encoding = finalTouch(e, stats, opt),\n        score = rank.encoding(encoding, stats, opt);\n\n      encoding.score = score.score;\n      encoding.scoreFeatures = score.features;\n      output.push(encoding);\n    });\n  return output;\n}\n\n//FIXME this should be refactors\nfunction finalTouch(encoding, stats, opt) {\n  if (encoding.marktype === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n    encoding.enc.color = encoding.enc.text;\n  }\n\n  // don't include zero if stdev/avg < 0.01\n  // https://github.com/uwdata/visrec/issues/69\n  var enc = encoding.enc;\n  ['x', 'y'].forEach(function(et) {\n    var field = enc[et];\n    if (field && vl.field.isMeasure(field) && !vl.field.isCount(field)) {\n      var stat = stats[field.name];\n      if (stat.stdev / stat.avg < 0.01) {\n        field.scale = {zero: false};\n      }\n    }\n  });\n  return encoding;\n}","\"use strict\";\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('../consts'),\n  genMarkTypes = require('./marktypes'),\n  isDimension = vl.field.isDimension,\n  isMeasure = vl.field.isMeasure;\n\nmodule.exports = genEncs;\n\n// FIXME remove dimension, measure and use information in vega-lite instead!\nvar rules = {\n  x: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dimension: true,\n    multiple: true\n  },\n  col: {\n    dimension: true,\n    multiple: true\n  },\n  shape: {\n    dimension: true,\n    rules: shapeRules\n  },\n  size: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  color: {\n    dimension: true,\n    measure: true,\n    rules: colorRules\n  },\n  alpha: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  text: {\n    measure: true\n  },\n  detail: {\n    dimension: true\n  }\n  //geo: {\n  //  geo: true\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\nfunction retinalEncRules(enc, field, stats, opt) {\n  if (opt.omitMultipleRetinalEncodings) {\n    if (enc.color || enc.size || enc.shape || enc.alpha) return false;\n  }\n  return true;\n}\n\nfunction colorRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  return vl.field.isMeasure(field) ||\n    vl.field.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction shapeRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  if (field.bin && field.type === 'Q') return false;\n  if (field.fn && field.type === 'T') return false;\n  return vl.field.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction dimMeaTransposeRule(enc) {\n  // create horizontal histogram for ordinal\n  if (enc.y.type === 'O' && isMeasure(enc.x)) return true;\n\n  // vertical histogram for Q and T\n  if (isMeasure(enc.y) && (enc.x.type !== 'O' && isDimension(enc.x))) return true;\n\n  return false;\n}\n\nfunction generalRules(enc, stats, opt) {\n  // enc.text is only used for TEXT TABLE\n  if (enc.text) {\n    return genMarkTypes.satisfyRules(enc, 'text', stats, opt);\n  }\n\n  // CARTESIAN PLOT OR MAP\n  if (enc.x || enc.y || enc.geo || enc.arc) {\n\n    if (enc.row || enc.col) { //have facet(s)\n\n      // don't use facets before filling up x,y\n      if (!enc.x || !enc.y) return false;\n\n      if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n        // remove all aggregated charts with all dims on facets (row, col)\n        if (genEncs.isAggrWithAllDimOnFacets(enc)) return false;\n      }\n    }\n\n    if (enc.x && enc.y) {\n      var isDimX = !!isDimension(enc.x),\n        isDimY = !!isDimension(enc.y);\n\n      if (isDimX && isDimY && !vl.enc.isAggregate(enc)) {\n        // FIXME actually check if there would be occlusion #90\n        return false;\n      }\n\n      if (opt.omitTranpose) {\n        if (isDimX ^ isDimY) { // dim x mea\n          if (!dimMeaTransposeRule(enc)) return false;\n        } else if (enc.y.type==='T' || enc.x.type === 'T') {\n          if (enc.y.type==='T' && enc.x.type !== 'T') return false;\n        } else { // show only one OxO, QxQ\n          if (enc.x.name > enc.y.name) return false;\n        }\n      }\n      return true;\n    }\n\n    // DOT PLOTS\n    // // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // one dimension \"count\" is useless\n    if (enc.x && enc.x.aggr == 'count' && !enc.y) return false;\n    if (enc.y && enc.y.aggr == 'count' && !enc.x) return false;\n\n    return true;\n  }\n  return false;\n}\n\ngenEncs.isAggrWithAllDimOnFacets = function (enc) {\n  var hasAggr = false, hasOtherO = false;\n  for (var encType in enc) {\n    var field = enc[encType];\n    if (field.aggr) {\n      hasAggr = true;\n    }\n    if (vl.field.isDimension(field) && (encType !== 'row' && encType !== 'col')) {\n      hasOtherO = true;\n    }\n    if (hasAggr && hasOtherO) break;\n  }\n\n  return hasAggr && !hasOtherO;\n};\n\n\nfunction genEncs(encs, fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  // generate a collection vega-lite's enc\n  var tmpEnc = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fields.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (generalRules(tmpEnc, stats, opt)) {\n        encs.push(vl.duplicate(tmpEnc));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var field = fields[i];\n    for (var j in opt.encodingTypeList) {\n      var et = opt.encodingTypeList[j],\n        isDim = isDimension(field);\n\n      //TODO: support \"multiple\" assignment\n      if (!(et in tmpEnc) && // encoding not used\n        ((isDim && rules[et].dimension) || (!isDim && rules[et].measure)) &&\n        (!rules[et].rules || rules[et].rules(tmpEnc, field, stats, opt))\n      ) {\n        tmpEnc[et] = field;\n        assignField(i + 1);\n        delete tmpEnc[et];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encs;\n}\n","'use strict';\n\nvar util = require('../util');\n\nvar gen = module.exports = {\n  // data variations\n  aggregates: require('./aggregates'),\n  projections: require('./projections'),\n  // encodings / visual variatons\n  encodings: require('./encodings'),\n  encs: require('./encs'),\n  marktypes: require('./marktypes')\n};\n\ngen.charts = function(fields, opt, cfg, flat) {\n  opt = util.gen.getOpt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? gen.aggregates([], fields, opt) : [fields],\n    encs, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggr)) {\n    encs = fieldSets.reduce(function(output, fields) {\n      return gen.encs(output, fields, opt);\n    }, []);\n  } else {\n    encs = fieldSets.map(function(fields) {\n      return gen.encs([], fields, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = util.nestedReduce(encs, function(output, enc) {\n      return gen.marktypes(output, enc, opt, cfg);\n    }, level, true);\n  } else {\n    charts = util.nestedMap(encs, function(enc) {\n      return gen.marktypes([], enc, opt, cfg);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};","\"use strict\";\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('../consts'),\n  isDimension = vl.field.isDimension,\n  isOrdinalScale = vl.field.isOrdinalScale;\n\nvar vlmarktypes = module.exports = getMarktypes;\n\nvar marksRule = vlmarktypes.rule = {\n  point:  pointRule,\n  bar:    barRule,\n  line:   lineRule,\n  area:   areaRule, // area is similar to line\n  text:   textRule,\n  tick:   tickRule\n};\n\nfunction getMarktypes(enc, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n\n  var markTypes = opt.marktypeList.filter(function(markType){\n    return vlmarktypes.satisfyRules(enc, markType, stats, opt);\n  });\n\n  return markTypes;\n}\n\nvlmarktypes.satisfyRules = function (enc, markType, stats, opt) {\n  var mark = vl.compile.marks[markType],\n    reqs = mark.requiredEncoding,\n    support = mark.supportedEncoding;\n\n  for (var i in reqs) { // all required encodings in enc\n    if (!(reqs[i] in enc)) return false;\n  }\n\n  for (var encType in enc) { // all encodings in enc are supported\n    if (!support[encType]) return false;\n  }\n\n  return !marksRule[markType] || marksRule[markType](enc, stats, opt);\n};\n\nfunction facetRule(field, stats, opt) {\n  return vl.field.cardinality(field, stats) <= opt.maxCardinalityForFacets;\n}\n\nfunction facetsRule(enc, stats, opt) {\n  if(enc.row && !facetRule(enc.row, stats, opt)) return false;\n  if(enc.col && !facetRule(enc.col, stats, opt)) return false;\n  return true;\n}\n\nfunction pointRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n  if (enc.x && enc.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    // For OxO\n    if (xIsDim && yIsDim) {\n      // shape doesn't work with both x, y as ordinal\n      if (enc.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (enc.color && isDimension(enc.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (enc.shape) return false;\n  }\n  return true;\n}\n\nfunction tickRule(enc, stats, opt) {\n  // jshint unused:false\n  if (enc.x || enc.y) {\n    if(vl.enc.isAggregate(enc)) return false;\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    return (!xIsDim && (!enc.y || isOrdinalScale(enc.y))) ||\n      (!yIsDim && (!enc.x || isOrdinalScale(enc.x)));\n  }\n  return false;\n}\n\nfunction barRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // need to aggregate on either x or y\n  if (opt.omitSizeOnBar && enc.size !== undefined) return false;\n\n  // FIXME actually check if there would be occlusion #90\n  if (((enc.x.aggr !== undefined) ^ (enc.y.aggr !== undefined)) &&\n      (isDimension(enc.x) ^ isDimension(enc.y))) {\n\n    var aggr = enc.x.aggr || enc.y.aggr;\n    return !(opt.omitStackedAverage && aggr ==='avg' && enc.color);\n  }\n\n  return false;\n}\n\nfunction lineRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // FIXME truly ordinal data is fine here too.\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return enc.x.type == 'T' && enc.x.fn && enc.y.type == 'Q' && enc.y.aggr;\n}\n\nfunction areaRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  if(!lineRule(enc, stats, opt)) return false;\n\n  return !(opt.omitStackedAverage && enc.y.aggr ==='avg' && enc.color);\n}\n\nfunction textRule(enc, stats, opt) {\n  // at least must have row or col and aggregated text values\n  return (enc.row || enc.col) && enc.text && enc.text.aggr && !enc.x && !enc.y && !enc.size &&\n    (!opt.alwaysGenerateTableAsHeatmap || !enc.color);\n}","'use strict';\n\nvar util = require('../util'),\n  consts = require('../consts'),\n  vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  isDimension = vl.field.isDimension;\n\nmodule.exports = projections;\n\n// TODO support other mode of projections generation\n// powerset, chooseK, chooseKorLess are already included in the util\n\n/**\n * fields\n * @param  {[type]} fields array of fields and query information\n * @return {[type]}        [description]\n */\nfunction projections(fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.projections);\n\n  // First categorize field, selected, fieldsToAdd, and save indices\n  var selected = [], fieldsToAdd = [], fieldSets = [],\n    hasSelectedDimension = false,\n    hasSelectedMeasure = false,\n    indices = {};\n\n  fields.forEach(function(field, index){\n    //save indices for stable sort later\n    indices[field.name] = index;\n\n    if (field.selected) {\n      selected.push(field);\n      if (isDimension(field) || field.type ==='T') { // FIXME / HACK\n        hasSelectedDimension = true;\n      } else {\n        hasSelectedMeasure = true;\n      }\n    } else if (field.selected !== false && !vl.field.isCount(field)) {\n      if (vl.field.isDimension(field) &&\n          !opt.maxCardinalityForAutoAddOrdinal &&\n          vl.field.cardinality(field, stats, 15) > opt.maxCardinalityForAutoAddOrdinal\n        ) {\n        return;\n      }\n      fieldsToAdd.push(field);\n    }\n  });\n\n  fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n\n  var setsToAdd = util.chooseKorLess(fieldsToAdd, 1);\n\n  setsToAdd.forEach(function(setToAdd) {\n    var fieldSet = selected.concat(setToAdd);\n    if (fieldSet.length > 0) {\n      if (opt.omitDotPlot && fieldSet.length === 1) return;\n      fieldSets.push(fieldSet);\n    }\n  });\n\n  fieldSets.forEach(function(fieldSet) {\n      // always append projection's key to each projection returned, d3 style.\n    fieldSet.key = projections.key(fieldSet);\n  });\n\n  return fieldSets;\n}\n\nvar typeIsMeasureScore = {\n  O: 0,\n  T: 1,\n  Q: 2\n};\n\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n  return function(a, b){\n    // sort by type of the data\n    if (a.type !== b.type) {\n      if (!hasSelectedDimension) {\n        return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n      } else if (!hasSelectedMeasure) {\n        return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n      }\n    }\n    //make the sort stable\n    return indices[a.name] - indices[b.name];\n  };\n}\n\nprojections.key = function(projection) {\n  return projection.map(function(field) {\n    return vl.field.isCount(field) ? 'count' : field.name;\n  }).join(',');\n};\n\n","'use strict';\n\nvar g = global || window;\n\ng.CHART_TYPES = {\n  TABLE: 'TABLE',\n  BAR: 'BAR',\n  PLOT: 'PLOT',\n  LINE: 'LINE',\n  AREA: 'AREA',\n  MAP: 'MAP',\n  HISTOGRAM: 'HISTOGRAM'\n};\n\ng.ANY_DATA_TYPES = (1 << 4) - 1;","module.exports = {\n  encoding: require('./rankEncodings')\n};\n\n\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  isDimension = vl.field.isDimension;\n\nmodule.exports = rankEncodings;\n\n// bad score not specified in the table above\nvar UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  tick: 0.96,\n  point: 0.95,\n  circle: 0.94,\n  square: 0.94,\n  text: 0.8\n};\n\nfunction rankEncodings(encoding, stats, opt, selected) {\n  var features = [],\n    encTypes = vl.keys(encoding.enc),\n    marktype = encoding.marktype,\n    enc = encoding.enc;\n\n  var encodingMappingByField = vl.enc.reduce(encoding.enc, function(o, field, encType) {\n    var key = vl.field.shorthand(field);\n    var mappings = o[key] = o[key] || [];\n    mappings.push({encType: encType, field: field});\n    return o;\n  }, {});\n\n  // data - encoding mapping score\n  vl.forEach(encodingMappingByField, function(mappings) {\n    var reasons = mappings.map(function(m) {\n        return m.encType + vl.shorthand.assign + vl.field.shorthand(m.field) +\n          ' ' + (selected && selected[m.field.name] ? '[x]' : '[ ]');\n      }),\n      scores = mappings.map(function(m) {\n        var role = vl.field.role(m.field);\n        var score = rankEncodings.score[role](m.field, m.encType, encoding.marktype, stats, opt);\n\n        return !selected || selected[m.field.name] ? score : Math.pow(score, 0.125);\n      });\n\n    features.push({\n      reason: reasons.join(\" | \"),\n      score: Math.max.apply(null, scores)\n    });\n  });\n\n  // plot type\n  if (marktype === 'text') {\n    // TODO\n  } else {\n    if (enc.x && enc.y) {\n      if (isDimension(enc.x) ^ isDimension(enc.y)) {\n        features.push({\n          reason: 'OxQ plot',\n          score: 0.8\n        });\n      }\n    }\n  }\n\n  // penalize not using positional only penalize for non-text\n  if (encTypes.length > 1 && marktype !== 'text') {\n    if ((!enc.x || !enc.y) && !enc.geo && !enc.text) {\n      features.push({\n        reason: 'unused position',\n        score: UNUSED_POSITION\n      });\n    }\n  }\n\n  // mark type score\n  features.push({\n    reason: 'marktype='+marktype,\n    score: MARK_SCORE[marktype]\n  });\n\n  return {\n    score: features.reduce(function(p, f) {\n      return p * f.score;\n    }, 1),\n    features: features\n  };\n}\n\n\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\n\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675; // < color_ok, > color_bad\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65; // > M.Size\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\n\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.alpha = 0.45;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\n\nrankEncodings.dimensionScore = function (field, encType, marktype, stats, opt){\n  var cardinality = vl.field.cardinality(field, stats);\n  switch (encType) {\n    case 'x':\n      if(field.type === 'O') return D.pos - D.minor;\n      return D.pos;\n\n    case 'y':\n      if(field.type === 'O') return D.pos - D.minor; //prefer ordinal on y\n      if(field.type === 'T') return D.Y_T; // time should not be on Y\n      return D.pos - D.minor;\n\n    case 'col':\n      if (marktype === 'text') return D.facet_text;\n      //prefer column over row due to scrolling issues\n      return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n\n    case 'row':\n      if (marktype === 'text') return D.facet_text;\n      return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n\n    case 'color':\n      var hasOrder = (field.bin && field.type==='Q') || (field.fn && field.type==='T');\n\n      //FIXME add stacking option once we have control ..\n      var isStacked = marktype ==='bar' || marktype ==='area';\n\n      // true ordinal on color is currently BAD (until we have good ordinal color scale support)\n      if (hasOrder) return D.color_bad;\n\n      //stacking gets lower score\n      if (isStacked) return D.color_stack;\n\n      return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good: cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n    case 'shape':\n      return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n    case 'detail':\n      return D.detail;\n  }\n  return TERRIBLE;\n};\n\nrankEncodings.dimensionScore.consts = D;\n\nrankEncodings.measureScore = function (field, encType, marktype, stats, opt) {\n  // jshint unused:false\n  switch (encType){\n    case 'x': return M.pos;\n    case 'y': return M.pos;\n    case 'size':\n      if (marktype === 'bar') return BAD; //size of bar is very bad\n      if (marktype === 'text') return BAD;\n      if (marktype === 'line') return BAD;\n      return M.size;\n    case 'color': return M.color;\n    case 'alpha': return M.alpha;\n    case 'text': return M.text;\n  }\n  return BAD;\n};\n\nrankEncodings.measureScore.consts = M;\n\n\nrankEncodings.score = {\n  dimension: rankEncodings.dimensionScore,\n  measure: rankEncodings.measureScore,\n};\n","\"use strict\";\n\nvar consts = require('./consts');\n\nvar util = module.exports = {\n  gen: {}\n};\n\nutil.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) == '[object Array]';\n};\n\nutil.json = function(s, sp) {\n  return JSON.stringify(s, null, sp);\n};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.nestedMap = function (col, f, level, filter) {\n  return level === 0 ?\n    col.map(f) :\n    col.map(function(v) {\n      var r = util.nestedMap(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nestedReduce = function (col, f, level, filter) {\n  return level === 0 ?\n    col.reduce(f, []) :\n    col.map(function(v) {\n      var r = util.nestedReduce(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nonEmpty = function(grp) {\n  return !util.isArray(grp) || grp.length > 0;\n};\n\n\nutil.traverse = function (node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) util.traverse(node.left, arr);\n    if (node.right) util.traverse(node.right, arr);\n  }\n  return arr;\n};\n\nutil.union = function (a, b) {\n  var o = {};\n  a.forEach(function(x) { o[x] = true;});\n  b.forEach(function(x) { o[x] = true;});\n  return util.keys(o);\n};\n\n\nutil.gen.getOpt = function (opt) {\n  //merge with default\n  return (opt ? util.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(consts.gen.DEFAULT_OPT));\n};\n\n/**\n * powerset code from http://rosettacode.org/wiki/Power_Set#JavaScript\n *\n *   var res = powerset([1,2,3,4]);\n *\n * returns\n *\n * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],\n * [2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n[edit]\n*/\n\nutil.powerset = function(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n};\n\nutil.chooseKorLess = function(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length <= k){\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n};\n\nutil.chooseK = function(list, k) {\n  var subset = [[]];\n  var kArray =[];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length < k){\n        subset.push(sub);\n      }else if (sub.length === k){\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n};\n\nutil.cross = function(a,b){\n  var x = [];\n  for(var i=0; i< a.length; i++){\n    for(var j=0;j< b.length; j++){\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n};\n\n"],"sourceRoot":"/source/"}