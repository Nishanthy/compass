{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/clusterfck/lib/clusterfck.js","compass.js","node_modules/clusterfck/lib/distance.js","node_modules/clusterfck/lib/hcluster.js","node_modules/clusterfck/lib/kmeans.js","node_modules/vega-lite/src/globals.js","src/cluster/cluster.js","src/cluster/clusterconsts.js","src/cluster/distance.js","src/consts.js","src/cp","src/gen/aggregates.js","src/gen/encodings.js","src/gen/gen.js","src/gen/marktypes.js","src/gen/projections.js","src/gen/specs.js","src/globals.js","src/rank/rank.js","src/rank/rankEncodings.js","src/util.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","cp","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"hcluster","Kmeans","kmeans","./hcluster","./kmeans",2,"euclidean","v1","v2","total","Math","pow","sqrt","manhattan","abs","max",3,"distances","HierarchicalClustering","distance","linkage","threshold","undefined","Infinity","prototype","cluster","items","snapshotPeriod","snapshotCb","clusters","dists","mins","index","value","key","size","j","dist","merged","mergeClosest","forEach","minKey","min","c1","c2","left","right","splice","ci","key1","key2","snapshot","snapshotCallback","./distance",4,"KMeans","centroids","randomCentroids","points","k","slice","sort","round","random","classify","point","ceil","assignment","Array","iterations","movement","assigned","push","centroid","newCentroid","sum","toJSON","JSON","stringify","fromJSON","json","parse","vectors",5,"AGGREGATE","RAW","STACKED","INDEX","X","Y","ROW","COL","SIZE","SHAPE","COLOR","TEXT","DETAIL","N","O","Q","T",6,"specs","opt","table","clusterTrees","clusterfck","e1","e2","s1","vl","Encoding","shorthand","s2","consts","CLUSTER_THRESHOLD","map","tree","util","traverse","spec1","spec2","_info","score","filter","cluster1","cluster2","../util","./clusterconsts",7,"reduceTupleToTable","x","b","d","c","SWAPPABLE","DIST_MISSING","DIST_BY_ENCTYPE","reduce",8,"len","extendedSpecs","extendSpecWithEncTypeByColumnName","shorthands","diff","sj","si","get","extendedSpec1","extendedSpec2","cols","union","keys","encTypeByField","col","encType","isStack1","isStack","isStack2","encoding","color","name","spec","_encTypeByField","duplicate","marktype",9,"gen","rank","projections","type","properties","omitDotPlot","default","description","maxCardinalityForAutoAddOrdinal","alwaysAddHistogram","aggregates","config","data","tableTypes","enum","genDimQ","minCardinalityForBin","omitMeasureOnly","omitDimensionOnly","addCountForDimensionOnly","aggrList","timeUnitList","consistentAutoQ","encodings","marktypeList","encodingTypeList","maxGoodCardinalityForFacets","maxCardinalityForFacets","maxGoodCardinalityForColor","maxCardinalityForColor","maxCardinalityForShape","omitTranpose","omitDotPlotWithExtraEncoding","omitMultipleRetinalEncodings","omitNonTextAggrWithAllDimsOnFacets","omitOneDimensionCount","omitSizeOnBar","omitStackedAverage","alwaysGenerateTableAsHeatmap",10,"auto","./cluster/cluster","./consts","./gen/gen","./rank/rank","./util",11,"genAggregates","output","fieldDefs","stats","emit","fieldSet","encDef","checkAndPush","hasMeasure","hasDimension","hasRaw","tf","isDimension","aggregate","count","pop","assignAggrQ","hasAggr","autoMode","canHaveAggr","cantHaveAggr","assignField","assignBinQ","bin","assignQ","_aggregate","_raw","_bin","AUTO","isin","hasNorO","highCardinality","cardinality","isAuto","genBin","genCast","assignTimeUnitT","timeUnit","assignT","_timeUnit","schema","extend","any","isTypes","../consts",12,"retinalEncRules","fieldDef","shape","colorRules","isMeasure","shapeRules","dimMeaTransposeRule","y","generalRules","text","genMarkTypes","satisfyRules","geo","arc","row","genEncodings","isAggrWithAllDimOnFacets","isDimX","isDimY","enc","isAggregate","tmpEncoding","isDim","rules","dimension","measure","multiple","detail","hasOtherO","field","../globals","./marktypes",13,"marktypes","charts","flat","getOpt","fieldSets","genAggr","level","encs","nestedReduce","nestedMap","./aggregates","./encodings","./projections","./specs",14,"getMarktypes","markType","vlmarktypes","facetRule","facetsRule","pointRule","xIsDim","yIsDim","tickRule","isOrdinalScale","barRule","aggEitherXorY","eitherXorYisDimOrNull","lineRule","areaRule","textRule","marksRule","rule","bar","line","area","tick","mark","compiler","marks","reqs","requiredEncoding","support","supportedEncoding",15,"selected","fieldsToAdd","hasSelectedDimension","hasSelectedMeasure","indices","isCount","compareFieldsToAdd","setsToAdd","chooseKorLess","setToAdd","concat","typeIsMeasureScore","projection","join",16,"genSpecsFromFieldDefs","nested","dict","genSpecsFromEncodings","list","finalTouch","stat","stdev","mean","scale","zero","../rank/rank",17,"CHART_TYPES","TABLE","BAR","PLOT","LINE","AREA","MAP","HISTOGRAM","ANY_DATA_TYPES","vega-lite/src/globals",18,"./rankEncodings",19,"rankEncodings","features","encTypes","encodingMappingByField","mappings","reasons","m","assign","scores","role","reason","apply","UNUSED_POSITION","MARK_SCORE","p","circle","square","D","M","BAD","TERRIBLE","minor","pos","Y_T","facet_text","facet_good","facet_ok","facet_bad","color_good","color_ok","color_bad","color_stack","bad","terrible","dimensionScore","hasOrder","isStacked","measureScore",20,"isArray","obj","toString","sp","v","nonEmpty","grp","node","arr","Object","create","DEFAULT_OPT","powerset","ps","subset","sub","chooseK","kArray","cross"],"mappings":"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","file":"compass.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.cp = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};\n},{\"./hcluster\":3,\"./kmeans\":4}],2:[function(require,module,exports){\nmodule.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};\n},{}],3:[function(require,module,exports){\nvar distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n\n},{\"./distance\":2}],4:[function(require,module,exports){\nvar distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}\n},{\"./distance\":2}],5:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.AGGREGATE = 'aggregate';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],6:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nmodule.exports = cluster;\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  clusterfck = require('clusterfck'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\ncluster.distance = require('./distance');\n\nfunction cluster(specs, opt) {\n  // jshint unused:false\n  var dist = cluster.distance.table(specs);\n\n  var clusterTrees = clusterfck.hcluster(specs, function(e1, e2) {\n    var s1 = vl.Encoding.shorthand(e1),\n      s2 = vl.Encoding.shorthand(e2);\n    return dist[s1][s2];\n  }, 'average', consts.CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n      return util.traverse(tree, []);\n    })\n   .map(function(cluster) {\n    return cluster.sort(function(spec1, spec2) {\n      // sort each cluster -- have the highest score as 1st item\n      return spec2._info.score - spec1._info.score;\n    });\n  }).filter(function(cluster) {  // filter empty cluster\n    return cluster.length >0;\n  }).sort(function(cluster1, cluster2) {\n    //sort by highest scoring item in each cluster\n    return cluster2[0]._info.score - cluster1[0]._info.score;\n  });\n\n  clusters.dist = dist; //append dist in the array for debugging\n\n  return clusters;\n}\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../util\":20,\"./clusterconsts\":7,\"./distance\":8,\"clusterfck\":1}],7:[function(require,module,exports){\n'use strict';\n\nvar c = module.exports = {};\n\nc.SWAPPABLE = 0.05;\nc.DIST_MISSING = 1;\nc.CLUSTER_THRESHOLD = 1;\n\nfunction reduceTupleToTable(r, x) {\n  var a = x[0], b = x[1], d = x[2];\n  r[a] = r[a] || {};\n  r[b] = r[b] || {};\n  r[a][b] = r[b][a] = d;\n  return r;\n}\n\nc.DIST_BY_ENCTYPE = [\n  // positional\n  ['x', 'y', c.SWAPPABLE],\n  ['row', 'col', c.SWAPPABLE],\n\n  // ordinal mark properties\n  ['color', 'shape', c.SWAPPABLE],\n  ['color', 'detail', c.SWAPPABLE],\n  ['detail', 'shape', c.SWAPPABLE],\n\n  // quantitative mark properties\n  ['size', 'color', c.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n\n},{}],8:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\nvar distance = {};\nmodule.exports = distance;\n\ndistance.table = function (specs) {\n  var len = specs.length,\n    extendedSpecs = specs.map(function(e) { return distance.extendSpecWithEncTypeByColumnName(e); }),\n    shorthands = specs.map(vl.Encoding.shorthand),\n    diff = {}, i, j;\n\n  for (i = 0; i < len; i++) diff[shorthands[i]] = {};\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      var sj = shorthands[j], si = shorthands[i];\n\n      diff[sj][si] = diff[si][sj] = distance.get(extendedSpecs[i], extendedSpecs[j]);\n    }\n  }\n  return diff;\n};\n\ndistance.get = function (extendedSpec1, extendedSpec2) {\n  var cols = util.union(vl.keys(extendedSpec1.encTypeByField), vl.keys(extendedSpec2.encTypeByField)),\n    dist = 0;\n\n  cols.forEach(function(col) {\n    var e1 = extendedSpec1.encTypeByField[col], e2 = extendedSpec2.encTypeByField[col];\n\n    if (e1 && e2) {\n      if (e1.encType != e2.encType) {\n        dist += (consts.DIST_BY_ENCTYPE[e1.encType] || {})[e2.encType] || 1;\n      }\n    } else {\n      dist += consts.DIST_MISSING;\n    }\n  });\n\n  // do not group stacked chart with similar non-stacked chart!\n  var isStack1 = vl.Encoding.isStack(extendedSpec1),\n    isStack2 = vl.Encoding.isStack(extendedSpec2);\n\n  if(isStack1 || isStack2) {\n    if(isStack1 && isStack2) {\n      if(extendedSpec1.encoding.color.name !== extendedSpec2.encoding.color.name) {\n        dist+=1;\n      }\n    } else {\n      dist+=1; // surely different\n    }\n  }\n  return dist;\n};\n\n// get encoding type by fieldname\ndistance.extendSpecWithEncTypeByColumnName = function(spec) {\n  var _encTypeByField = {},\n    encoding = spec.encoding;\n\n  vl.keys(encoding).forEach(function(encType) {\n    var e = vl.duplicate(encoding[encType]);\n    e.encType = encType;\n    _encTypeByField[e.name || ''] = e;\n    delete e.name;\n  });\n\n  return {\n    marktype: spec.marktype,\n    encTypeByField: _encTypeByField,\n    encoding: spec.encoding\n  };\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../util\":20,\"./clusterconsts\":7}],9:[function(require,module,exports){\n'use strict';\n\nvar consts = module.exports = {\n  gen: {},\n  cluster: {},\n  rank: {}\n};\n\nconsts.gen.projections = {\n  type: 'object',\n  properties: {\n    omitDotPlot: { //FIXME remove this!\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    maxCardinalityForAutoAddOrdinal: {\n      type: 'integer',\n      default: 50,\n      description: 'max cardinality for ordinal field to be considered for auto adding'\n    },\n    alwaysAddHistogram: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nconsts.gen.aggregates = {\n  type: 'object',\n  properties: {\n    config: {\n      type: 'object'\n    },\n    data: {\n      type: 'object'\n    },\n    tableTypes: {\n      type: 'boolean',\n      default: 'both',\n      enum: ['both', 'aggregated', 'disaggregated']\n    },\n    genDimQ: {\n      type: 'string',\n      default: 'auto',\n      enum: ['auto', 'bin', 'cast', 'none'],\n      description: 'Use Q as Dimension either by binning or casting'\n    },\n    minCardinalityForBin: {\n      type: 'integer',\n      default: 20,\n      description: 'minimum cardinality of a field if we were to bin'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitMeasureOnly: {\n      type: 'boolean',\n      default: false,\n      description: 'Omit aggregation with measure(s) only'\n    },\n    omitDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Omit aggregation with dimension(s) only'\n    },\n    addCountForDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Add count when there are dimension(s) only'\n    },\n    aggrList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: [undefined, 'mean']\n    },\n    timeUnitList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: ['year']\n    },\n    consistentAutoQ: {\n      type: 'boolean',\n      default: true,\n      description: \"generate similar auto transform for quant\"\n    }\n  }\n};\n\nconsts.gen.encodings = {\n  type: 'object',\n  properties: {\n    marktypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['point', 'bar', 'line', 'area', 'text', 'tick'], //filled_map\n      description: 'allowed marktypes'\n    },\n    encodingTypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['x', 'y', 'row', 'col', 'size', 'color', 'text', 'detail'],\n      description: 'allowed encoding types'\n    },\n    maxGoodCardinalityForFacets: {\n      type: 'integer',\n      default: 5,\n      description: 'maximum cardinality of a field to be put on facet (row/col) effectively'\n    },\n    maxCardinalityForFacets: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of a field to be put on facet (row/col)'\n    },\n    maxGoodCardinalityForColor: {\n      type: 'integer',\n      default: 7,\n      description: 'maximum cardinality of an ordinal field to be put on color effectively'\n    },\n    maxCardinalityForColor: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal field to be put on color'\n    },\n    maxCardinalityForShape: {\n      type: 'integer',\n      default: 6,\n      description: 'maximum cardinality of an ordinal field to be put on shape'\n    },\n    omitTranpose:  {\n      type: 'boolean',\n      default: true,\n      description: 'Eliminate all transpose by (1) keeping horizontal dot plot only (2) for OxQ charts, always put O on Y (3) show only one DxD, MxM (currently sorted by name)'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitDotPlotWithExtraEncoding: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all dot plots with >1 encoding'\n    },\n    omitMultipleRetinalEncodings: {\n      type: 'boolean',\n      default: true,\n      description: 'omit using multiple retinal variables (size, color, shape)'\n    },\n    omitNonTextAggrWithAllDimsOnFacets: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all aggregated charts (except text tables) with all dims on facets (row, col)'\n    },\n    omitOneDimensionCount: {\n      type: 'boolean',\n      default: false,\n      description: 'omit one dimension count'\n    },\n    omitSizeOnBar: {\n      type: 'boolean',\n      default: false,\n      description: 'do not use bar\\'s size'\n    },\n    omitStackedAverage: {\n      type: 'boolean',\n      default: true,\n      description: 'do not stack bar chart with average'\n    },\n    alwaysGenerateTableAsHeatmap: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\n},{}],10:[function(require,module,exports){\nmodule.exports = {\n  consts: require('./consts'),\n  cluster: require('./cluster/cluster'),\n  gen: require('./gen/gen'),\n  rank: require('./rank/rank'),\n  util: require('./util'),\n  auto: \"-, sum\"\n};\n\n\n\n},{\"./cluster/cluster\":6,\"./consts\":9,\"./gen/gen\":13,\"./rank/rank\":18,\"./util\":20}],11:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null);\n\nvar consts = require('../consts');\n\nvar AUTO = '*';\n\nmodule.exports = genAggregates;\n\nfunction genAggregates(output, fieldDefs, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.aggregates);\n  var tf = new Array(fieldDefs.length);\n  var hasNorO = vl.any(fieldDefs, function(f) {\n    return vl.encDef.isTypes(f, [N, O]);\n  });\n\n  function emit(fieldSet) {\n    fieldSet = vl.duplicate(fieldSet);\n    fieldSet.key = vl.encDef.shorthands(fieldSet);\n    output.push(fieldSet);\n  }\n\n  function checkAndPush() {\n    if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n      var hasMeasure = false, hasDimension = false, hasRaw = false;\n      tf.forEach(function(f) {\n        if (vl.encDef.isDimension(f)) {\n          hasDimension = true;\n        } else {\n          hasMeasure = true;\n          if (!f.aggregate) hasRaw = true;\n        }\n      });\n      if (!hasDimension && !hasRaw && opt.omitMeasureOnly) return;\n      if (!hasMeasure) {\n        if (opt.addCountForDimensionOnly) {\n          tf.push(vl.encDef.count());\n          emit(tf);\n          tf.pop();\n        }\n        if (opt.omitDimensionOnly) return;\n      }\n    }\n    if (opt.omitDotPlot && tf.length === 1) return;\n    emit(tf);\n  }\n\n  function assignAggrQ(i, hasAggr, autoMode, a) {\n    var canHaveAggr = hasAggr === true || hasAggr === null,\n      cantHaveAggr = hasAggr === false || hasAggr === null;\n    if (a) {\n      if (canHaveAggr) {\n        tf[i].aggregate = a;\n        assignField(i + 1, true, autoMode);\n        delete tf[i].aggregate;\n      }\n    } else { // if(a === undefined)\n      if (cantHaveAggr) {\n        assignField(i + 1, false, autoMode);\n      }\n    }\n  }\n\n  function assignBinQ(i, hasAggr, autoMode) {\n    tf[i].bin = true;\n    assignField(i + 1, hasAggr, autoMode);\n    delete tf[i].bin;\n  }\n\n  function assignQ(i, hasAggr, autoMode) {\n    var f = fieldDefs[i],\n      canHaveAggr = hasAggr === true || hasAggr === null;\n\n    tf[i] = {name: f.name, type: f.type};\n\n    if (f.aggregate === 'count') { // if count is included in the selected fields\n      if (canHaveAggr) {\n        tf[i].aggregate = f.aggregate;\n        assignField(i + 1, true, autoMode);\n      }\n    } else if (f._aggregate) {\n      // TODO support array of f._aggrs too\n      assignAggrQ(i, hasAggr, autoMode, f._aggregate);\n    } else if (f._raw) {\n      assignAggrQ(i, hasAggr, autoMode, undefined);\n    } else if (f._bin) {\n      assignBinQ(i, hasAggr, autoMode);\n    } else {\n      opt.aggrList.forEach(function(a) {\n        if (!opt.consistentAutoQ || autoMode === AUTO || autoMode === a) {\n          assignAggrQ(i, hasAggr, a /*assign autoMode*/, a);\n        }\n      });\n\n      if ((!opt.consistentAutoQ || vl.isin(autoMode, [AUTO, 'bin', 'cast', 'autocast'])) && !hasNorO) {\n        var highCardinality = vl.encDef.cardinality(f, stats) > opt.minCardinalityForBin;\n\n        var isAuto = opt.genDimQ === 'auto',\n          genBin = opt.genDimQ  === 'bin' || (isAuto && highCardinality),\n          genCast = opt.genDimQ === 'cast' || (isAuto && !highCardinality);\n\n        if (genBin && vl.isin(autoMode, [AUTO, 'bin', 'autocast'])) {\n          assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n        }\n        if (genCast && vl.isin(autoMode, [AUTO, 'cast', 'autocast'])) {\n          tf[i].type = 'O';\n          assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n          tf[i].type = 'Q';\n        }\n      }\n    }\n  }\n\n  function assignTimeUnitT(i, hasAggr, autoMode, timeUnit) {\n    tf[i].timeUnit = timeUnit;\n    assignField(i+1, hasAggr, autoMode);\n    delete tf[i].timeUnit;\n  }\n\n  function assignT(i, hasAggr, autoMode) {\n    var f = fieldDefs[i];\n    tf[i] = {name: f.name, type: f.type};\n\n    // TODO support array of f._timeUnits\n    if (f._timeUnit) {\n      assignTimeUnitT(i, hasAggr, autoMode, f._timeUnit);\n    } else {\n      opt.timeUnitList.forEach(function(timeUnit) {\n        if (timeUnit === undefined) {\n          if (!hasAggr) { // can't aggregate over raw time\n            assignField(i+1, false, autoMode);\n          }\n        } else {\n          assignTimeUnitT(i, hasAggr, autoMode, timeUnit);\n        }\n      });\n    }\n\n    // FIXME what if you aggregate time?\n  }\n\n  function assignField(i, hasAggr, autoMode) {\n    if (i === fieldDefs.length) { // If all fields are assigned\n      checkAndPush();\n      return;\n    }\n\n    var f = fieldDefs[i];\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case Q:\n        assignQ(i, hasAggr, autoMode);\n        break;\n\n      case T:\n        assignT(i, hasAggr, autoMode);\n        break;\n      case O:\n        /* falls through */\n      case N:\n        /* falls through */\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr, autoMode);\n        break;\n    }\n  }\n\n  var hasAggr = opt.tableTypes === 'aggregated' ? true : opt.tableTypes === 'disaggregated' ? false : null;\n  assignField(0, hasAggr, AUTO);\n\n  return output;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":9}],12:[function(require,module,exports){\n(function (global){\n\"use strict\";\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  genMarkTypes = require('./marktypes'),\n  isDimension = vl.encDef.isDimension,\n  isMeasure = vl.encDef.isMeasure;\n\nmodule.exports = genEncodings;\n\n// FIXME remove dimension, measure and use information in vega-lite instead!\nvar rules = {\n  x: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dimension: true,\n    multiple: true\n  },\n  col: {\n    dimension: true,\n    multiple: true\n  },\n  shape: {\n    dimension: true,\n    rules: shapeRules\n  },\n  size: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  color: {\n    dimension: true,\n    measure: true,\n    rules: colorRules\n  },\n  text: {\n    measure: true\n  },\n  detail: {\n    dimension: true\n  }\n  //geo: {\n  //  geo: true\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\nfunction retinalEncRules(encoding, fieldDef, stats, opt) {\n  if (opt.omitMultipleRetinalEncodings) {\n    if (encoding.color || encoding.size || encoding.shape) return false;\n  }\n  return true;\n}\n\nfunction colorRules(encoding, fieldDef, stats, opt) {\n  if(!retinalEncRules(encoding, fieldDef, stats, opt)) return false;\n\n  return vl.encDef.isMeasure(fieldDef) ||\n    vl.encDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction shapeRules(encoding, fieldDef, stats, opt) {\n  if(!retinalEncRules(encoding, fieldDef, stats, opt)) return false;\n\n  if (fieldDef.bin && fieldDef.type === Q) return false;\n  if (fieldDef.timeUnit && fieldDef.type === T) return false;\n  return vl.encDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction dimMeaTransposeRule(encoding) {\n  // create horizontal histogram for ordinal\n  if (vl.encDef.isTypes(encoding.y, [N, O]) && isMeasure(encoding.x)) return true;\n\n  // vertical histogram for Q and T\n  if (isMeasure(encoding.y) && (!vl.encDef.isTypes(encoding.x, [N, O]) && isDimension(encoding.x))) return true;\n\n  return false;\n}\n\nfunction generalRules(encoding, stats, opt) {\n  // enc.text is only used for TEXT TABLE\n  if (encoding.text) {\n    return genMarkTypes.satisfyRules(encoding, TEXT, stats, opt);\n  }\n\n  // CARTESIAN PLOT OR MAP\n  if (encoding.x || encoding.y || encoding.geo || encoding.arc) {\n\n    if (encoding.row || encoding.col) { //have facet(s)\n\n      // don't use facets before filling up x,y\n      if (!encoding.x || !encoding.y) return false;\n\n      if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n        // remove all aggregated charts with all dims on facets (row, col)\n        if (genEncodings.isAggrWithAllDimOnFacets(encoding)) return false;\n      }\n    }\n\n    if (encoding.x && encoding.y) {\n      var isDimX = !!isDimension(encoding.x),\n        isDimY = !!isDimension(encoding.y);\n\n      if (isDimX && isDimY && !vl.enc.isAggregate(encoding)) {\n        // FIXME actually check if there would be occlusion #90\n        return false;\n      }\n\n      if (opt.omitTranpose) {\n        if (isDimX ^ isDimY) { // dim x mea\n          if (!dimMeaTransposeRule(encoding)) return false;\n        } else if (encoding.y.type===T || encoding.x.type === T) {\n          if (encoding.y.type===T && encoding.x.type !== T) return false;\n        } else { // show only one OxO, QxQ\n          if (encoding.x.name > encoding.y.name) return false;\n        }\n      }\n      return true;\n    }\n\n    // DOT PLOTS\n    // // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && encoding.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(encoding).length > 1) return false;\n\n    if (opt.omitOneDimensionCount) {\n      // one dimension \"count\"\n      if (encoding.x && encoding.x.aggregate == 'count' && !encoding.y) return false;\n      if (encoding.y && encoding.y.aggregate == 'count' && !encoding.x) return false;\n    }\n\n    return true;\n  }\n  return false;\n}\n\ngenEncodings.isAggrWithAllDimOnFacets = function (encoding) {\n  var hasAggr = false, hasOtherO = false;\n  for (var encType in encoding) {\n    var field = encoding[encType];\n    if (field.aggregate) {\n      hasAggr = true;\n    }\n    if (vl.encDef.isDimension(field) && (encType !== ROW && encType !== COL)) {\n      hasOtherO = true;\n    }\n    if (hasAggr && hasOtherO) break;\n  }\n\n  return hasAggr && !hasOtherO;\n};\n\n\nfunction genEncodings(encodings, fieldDefs, stats, opt) {\n  // generate a collection vega-lite's enc\n  var tmpEncoding = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fieldDefs.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (generalRules(tmpEncoding, stats, opt)) {\n        encodings.push(vl.duplicate(tmpEncoding));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var fieldDef = fieldDefs[i];\n    for (var j in opt.encodingTypeList) {\n      var encType = opt.encodingTypeList[j],\n        isDim = isDimension(fieldDef);\n\n      //TODO: support \"multiple\" assignment\n      if (!(encType in tmpEncoding) && // encoding not used\n        ((isDim && rules[encType].dimension) || (!isDim && rules[encType].measure)) &&\n        (!rules[encType].rules || rules[encType].rules(tmpEncoding, fieldDef, stats, opt))\n      ) {\n        tmpEncoding[encType] = fieldDef;\n        assignField(i + 1);\n        delete tmpEncoding[encType];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encodings;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../globals\":17,\"./marktypes\":14}],13:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util');\n\n/**\n * Module for generating visualizations\n */\n\nvar gen = module.exports = {\n  // data variations\n  aggregates: require('./aggregates'),\n  projections: require('./projections'),\n  // encodings / visual variations\n  specs: require('./specs'),\n  encodings: require('./encodings'),\n  marktypes: require('./marktypes')\n};\n\n\n// TODO(kanitw): revise if this is still working\ngen.charts = function(fieldDefs, opt, config, flat) {\n  opt = util.gen.getOpt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? gen.aggregates([], fieldDefs, opt) : [fieldDefs],\n    encodings, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggregate)) {\n    encodings = fieldSets.reduce(function(output, fieldDefs) {\n      return gen.encs(output, fieldDefs, opt);\n    }, []);\n  } else {\n    encodings = fieldSets.map(function(fieldDefs) {\n      return gen.encs([], fieldDefs, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = util.nestedReduce(encodings, function(output, encoding) {\n      return gen.marktypes(output, encoding, opt, config);\n    }, level, true);\n  } else {\n    charts = util.nestedMap(encodings, function(encoding) {\n      return gen.marktypes([], encoding, opt, config);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};\n},{\"../util\":20,\"./aggregates\":11,\"./encodings\":12,\"./marktypes\":14,\"./projections\":15,\"./specs\":16}],14:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension,\n  isOrdinalScale = vl.encDef.isOrdinalScale;\n\nvar vlmarktypes = module.exports = getMarktypes;\n\nvar marksRule = vlmarktypes.rule = {\n  point:  pointRule,\n  bar:    barRule,\n  line:   lineRule,\n  area:   areaRule, // area is similar to line\n  text:   textRule,\n  tick:   tickRule\n};\n\nfunction getMarktypes(encoding, stats, opt) {\n  return opt.marktypeList.filter(function(markType){\n    return vlmarktypes.satisfyRules(encoding, markType, stats, opt);\n  });\n}\n\nvlmarktypes.satisfyRules = function (encoding, markType, stats, opt) {\n  var mark = vl.compiler.marks[markType],\n    reqs = mark.requiredEncoding,\n    support = mark.supportedEncoding;\n\n  for (var i in reqs) { // all required encodings in enc\n    if (!(reqs[i] in encoding)) return false;\n  }\n\n  for (var encType in encoding) { // all encodings in enc are supported\n    if (!support[encType]) return false;\n  }\n\n  return !marksRule[markType] || marksRule[markType](encoding, stats, opt);\n};\n\nfunction facetRule(fieldDef, stats, opt) {\n  return vl.encDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForFacets;\n}\n\nfunction facetsRule(encoding, stats, opt) {\n  if(encoding.row && !facetRule(encoding.row, stats, opt)) return false;\n  if(encoding.col && !facetRule(encoding.col, stats, opt)) return false;\n  return true;\n}\n\nfunction pointRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n  if (encoding.x && encoding.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    var xIsDim = isDimension(encoding.x),\n      yIsDim = isDimension(encoding.y);\n\n    // For OxO\n    if (xIsDim && yIsDim) {\n      // shape doesn't work with both x, y as ordinal\n      if (encoding.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (encoding.color && isDimension(encoding.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && encoding.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(encoding).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (encoding.shape) return false;\n  }\n  return true;\n}\n\nfunction tickRule(encoding, stats, opt) {\n  // jshint unused:false\n  if (encoding.x || encoding.y) {\n    if(vl.enc.isAggregate(encoding)) return false;\n\n    var xIsDim = isDimension(encoding.x),\n      yIsDim = isDimension(encoding.y);\n\n    return (!xIsDim && (!encoding.y || isOrdinalScale(encoding.y))) ||\n      (!yIsDim && (!encoding.x || isOrdinalScale(encoding.x)));\n  }\n  return false;\n}\n\nfunction barRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  // bar requires at least x or y\n  if (!encoding.x && !encoding.y) return false;\n\n  if (opt.omitSizeOnBar && encoding.size !== undefined) return false;\n\n  // FIXME actually check if there would be occlusion #90\n  // need to aggregate on either x or y\n  var aggEitherXorY =\n    (!encoding.x || encoding.x.aggregate === undefined) ^\n    (!encoding.y || encoding.y.aggregate === undefined);\n\n\n  if (aggEitherXorY) {\n    var eitherXorYisDimOrNull =\n      (!encoding.x || isDimension(encoding.x)) ^\n      (!encoding.y || isDimension(encoding.y));\n\n    if (eitherXorYisDimOrNull) {\n      var aggregate = encoding.x.aggregate || encoding.y.aggregate;\n      return !(opt.omitStackedAverage && aggregate ==='mean' && encoding.color);\n    }\n  }\n\n  return false;\n}\n\nfunction lineRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // FIXME truly ordinal data is fine here too.\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return encoding.x.type == 'T' && encoding.x.timeUnit && encoding.y.type == 'Q' && encoding.y.aggregate;\n}\n\nfunction areaRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  if(!lineRule(encoding, stats, opt)) return false;\n\n  return !(opt.omitStackedAverage && encoding.y.aggregate ==='mean' && encoding.color);\n}\n\nfunction textRule(encoding, stats, opt) {\n  // at least must have row or col and aggregated text values\n  return (encoding.row || encoding.col) && encoding.text && encoding.text.aggregate && !encoding.x && !encoding.y && !encoding.size &&\n    (!opt.alwaysGenerateTableAsHeatmap || !encoding.color);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],15:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar util = require('../util'),\n  consts = require('../consts'),\n  vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension;\n\nmodule.exports = projections;\n\n// TODO support other mode of projections generation\n// powerset, chooseK, chooseKorLess are already included in the util\n\n/**\n * fields\n * @param  {[type]} fieldDefs array of fields and query information\n * @return {[type]}        [description]\n */\nfunction projections(fieldDefs, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.projections);\n\n  // First categorize field, selected, fieldsToAdd, and save indices\n  var selected = [], fieldsToAdd = [], fieldSets = [],\n    hasSelectedDimension = false,\n    hasSelectedMeasure = false,\n    indices = {};\n\n  fieldDefs.forEach(function(fieldDef, index){\n    //save indices for stable sort later\n    indices[fieldDef.name] = index;\n\n    if (fieldDef.selected) {\n      selected.push(fieldDef);\n      if (isDimension(fieldDef) || fieldDef.type ==='T') { // FIXME / HACK\n        hasSelectedDimension = true;\n      } else {\n        hasSelectedMeasure = true;\n      }\n    } else if (fieldDef.selected !== false && !vl.encDef.isCount(fieldDef)) {\n      if (vl.encDef.isDimension(fieldDef) &&\n          !opt.maxCardinalityForAutoAddOrdinal &&\n          vl.encDef.cardinality(fieldDef, stats, 15) > opt.maxCardinalityForAutoAddOrdinal\n        ) {\n        return;\n      }\n      fieldsToAdd.push(fieldDef);\n    }\n  });\n\n  fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n\n  var setsToAdd = util.chooseKorLess(fieldsToAdd, 1);\n\n  setsToAdd.forEach(function(setToAdd) {\n    var fieldSet = selected.concat(setToAdd);\n    if (fieldSet.length > 0) {\n      if (opt.omitDotPlot && fieldSet.length === 1) return;\n      fieldSets.push(fieldSet);\n    }\n  });\n\n  fieldSets.forEach(function(fieldSet) {\n      // always append projection's key to each projection returned, d3 style.\n    fieldSet.key = projections.key(fieldSet);\n  });\n\n  return fieldSets;\n}\n\nvar typeIsMeasureScore = {\n  N: 0,\n  O: 0,\n  T: 2,\n  Q: 3\n};\n\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n  return function(a, b){\n    // sort by type of the data\n    if (a.type !== b.type) {\n      if (!hasSelectedDimension) {\n        return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n      } else { //if (!hasSelectedMeasure) {\n        return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n      }\n    }\n    //make the sort stable\n    return indices[a.name] - indices[b.name];\n  };\n}\n\nprojections.key = function(projection) {\n  return projection.map(function(field) {\n    return vl.encDef.isCount(field) ? 'count' : field.name;\n  }).join(',');\n};\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":9,\"../util\":20}],16:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  genEncodings = require('./encodings'),\n  getMarktypes = require('./marktypes'),\n  rank = require('../rank/rank'),\n  consts = require('../consts');\n\nmodule.exports = genSpecsFromFieldDefs;\n\n/** Design Encodings for a set of field definition */\n\nfunction genSpecsFromFieldDefs(output, fieldDefs, stats, opt, nested) {\n  // opt must be augmented before being passed to genEncodings or getMarktypes\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  var encodings = genEncodings([], fieldDefs, stats, opt);\n\n  if (nested) {\n    return encodings.reduce(function(dict, encoding) {\n      dict[encoding] = genSpecsFromEncodings([], encoding, stats, opt);\n      return dict;\n    }, {});\n  } else {\n    return encodings.reduce(function(list, encoding) {\n      return genSpecsFromEncodings(list, encoding, stats, opt);\n    }, []);\n  }\n}\n\nfunction genSpecsFromEncodings(output, encoding, stats, opt) {\n  getMarktypes(encoding, stats, opt)\n    .forEach(function(markType) {\n      var spec = vl.duplicate({\n          // Clone config & encoding to unique objects\n          encoding: encoding,\n          config: opt.config\n        });\n\n      spec.marktype = markType;\n      // Data object is the same across charts: pass by reference\n      spec.data = opt.data;\n\n      spec = finalTouch(spec, stats, opt);\n      var score = rank.encoding(spec, stats, opt);\n\n      spec._info = score;\n      output.push(spec);\n    });\n  return output;\n}\n\n//FIXME this should be refactors\nfunction finalTouch(spec, stats, opt) {\n  if (spec.marktype === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n    spec.encoding.color = spec.encoding.text;\n  }\n\n  // don't include zero if stdev/mean < 0.01\n  // https://github.com/uwdata/visrec/issues/69\n  var encoding = spec.encoding;\n  ['x', 'y'].forEach(function(encType) {\n    var field = encoding[encType];\n    if (field && vl.encDef.isMeasure(field) && !vl.encDef.isCount(field)) {\n      var stat = stats[field.name];\n      if (stat && stat.stdev / stat.mean < 0.01) {\n        field.scale = {zero: false};\n      }\n    }\n  });\n  return spec;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":9,\"../rank/rank\":18,\"./encodings\":12,\"./marktypes\":14}],17:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar g = global || window;\n\nrequire('vega-lite/src/globals');\n\ng.CHART_TYPES = {\n  TABLE: 'TABLE',\n  BAR: 'BAR',\n  PLOT: 'PLOT',\n  LINE: 'LINE',\n  AREA: 'AREA',\n  MAP: 'MAP',\n  HISTOGRAM: 'HISTOGRAM'\n};\n\ng.ANY_DATA_TYPES = (1 << 4) - 1;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"vega-lite/src/globals\":5}],18:[function(require,module,exports){\nmodule.exports = {\n  encoding: require('./rankEncodings')\n};\n\n\n\n},{\"./rankEncodings\":19}],19:[function(require,module,exports){\n(function (global){\n'use strict';\n\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension;\n\nmodule.exports = rankEncodings;\n\n// bad score not specified in the table above\nvar UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  tick: 0.96,\n  point: 0.95,\n  circle: 0.94,\n  square: 0.94,\n  text: 0.8\n};\n\nfunction rankEncodings(spec, stats, opt, selected) {\n  var features = [],\n    encTypes = vl.keys(spec.encoding),\n    marktype = spec.marktype,\n    encoding = spec.encoding;\n\n  var encodingMappingByField = vl.enc.reduce(spec.encoding, function(o, fieldDef, encType) {\n    var key = vl.encDef.shorthand(fieldDef);\n    var mappings = o[key] = o[key] || [];\n    mappings.push({encType: encType, field: fieldDef});\n    return o;\n  }, {});\n\n  // data - encoding mapping score\n  vl.forEach(encodingMappingByField, function(mappings) {\n    var reasons = mappings.map(function(m) {\n        return m.encType + vl.shorthand.assign + vl.encDef.shorthand(m.field) +\n          ' ' + (selected && selected[m.field.name] ? '[x]' : '[ ]');\n      }),\n      scores = mappings.map(function(m) {\n        var role = vl.encDef.isDimension(m.field) ? 'dimension' : 'measure';\n\n        var score = rankEncodings.score[role](m.field, m.encType, spec.marktype, stats, opt);\n\n        return !selected || selected[m.field.name] ? score : Math.pow(score, 0.125);\n      });\n\n    features.push({\n      reason: reasons.join(\" | \"),\n      score: Math.max.apply(null, scores)\n    });\n  });\n\n  // plot type\n  if (marktype === TEXT) {\n    // TODO\n  } else {\n    if (encoding.x && encoding.y) {\n      if (isDimension(encoding.x) ^ isDimension(encoding.y)) {\n        features.push({\n          reason: 'OxQ plot',\n          score: 0.8\n        });\n      }\n    }\n  }\n\n  // penalize not using positional only penalize for non-text\n  if (encTypes.length > 1 && marktype !== TEXT) {\n    if ((!encoding.x || !encoding.y) && !encoding.geo && !encoding.text) {\n      features.push({\n        reason: 'unused position',\n        score: UNUSED_POSITION\n      });\n    }\n  }\n\n  // mark type score\n  features.push({\n    reason: 'marktype='+marktype,\n    score: MARK_SCORE[marktype]\n  });\n\n  return {\n    score: features.reduce(function(p, f) {\n      return p * f.score;\n    }, 1),\n    features: features\n  };\n}\n\n\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\n\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675; // < color_ok, > color_bad\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65; // > M.Size\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\n\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\n\nrankEncodings.dimensionScore = function (fieldDef, encType, marktype, stats, opt){\n  var cardinality = vl.encDef.cardinality(fieldDef, stats);\n  switch (encType) {\n    case X:\n      if (vl.encDef.isTypes(fieldDef, [N, O]))  return D.pos - D.minor;\n      return D.pos;\n\n    case Y:\n      if (vl.encDef.isTypes(fieldDef, [N, O])) return D.pos - D.minor; //prefer ordinal on y\n      if (fieldDef.type === T) return D.Y_T; // time should not be on Y\n      return D.pos - D.minor;\n\n    case COL:\n      if (marktype === TEXT) return D.facet_text;\n      //prefer column over row due to scrolling issues\n      return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n\n    case ROW:\n      if (marktype === TEXT) return D.facet_text;\n      return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n\n    case COLOR:\n      var hasOrder = (fieldDef.bin && fieldDef.type===Q) || (fieldDef.timeUnit && fieldDef.type===T);\n\n      //FIXME add stacking option once we have control ..\n      var isStacked = marktype === 'bar' || marktype === 'area';\n\n      // true ordinal on color is currently BAD (until we have good ordinal color scale support)\n      if (hasOrder) return D.color_bad;\n\n      //stacking gets lower score\n      if (isStacked) return D.color_stack;\n\n      return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good: cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n    case SHAPE:\n      return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n    case DETAIL:\n      return D.detail;\n  }\n  return TERRIBLE;\n};\n\nrankEncodings.dimensionScore.consts = D;\n\nrankEncodings.measureScore = function (fieldDef, encType, marktype, stats, opt) {\n  // jshint unused:false\n  switch (encType){\n    case X: return M.pos;\n    case Y: return M.pos;\n    case SIZE:\n      if (marktype === 'bar') return BAD; //size of bar is very bad\n      if (marktype === TEXT) return BAD;\n      if (marktype === 'line') return BAD;\n      return M.size;\n    case COLOR: return M.color;\n    case TEXT: return M.text;\n  }\n  return BAD;\n};\n\nrankEncodings.measureScore.consts = M;\n\n\nrankEncodings.score = {\n  dimension: rankEncodings.dimensionScore,\n  measure: rankEncodings.measureScore,\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../globals\":17}],20:[function(require,module,exports){\n\"use strict\";\n\nvar consts = require('./consts');\n\nvar util = module.exports = {\n  gen: {}\n};\n\nutil.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) == '[object Array]';\n};\n\nutil.json = function(s, sp) {\n  return JSON.stringify(s, null, sp);\n};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.nestedMap = function (col, f, level, filter) {\n  return level === 0 ?\n    col.map(f) :\n    col.map(function(v) {\n      var r = util.nestedMap(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nestedReduce = function (col, f, level, filter) {\n  return level === 0 ?\n    col.reduce(f, []) :\n    col.map(function(v) {\n      var r = util.nestedReduce(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nonEmpty = function(grp) {\n  return !util.isArray(grp) || grp.length > 0;\n};\n\n\nutil.traverse = function (node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) util.traverse(node.left, arr);\n    if (node.right) util.traverse(node.right, arr);\n  }\n  return arr;\n};\n\nutil.union = function (a, b) {\n  var o = {};\n  a.forEach(function(x) { o[x] = true;});\n  b.forEach(function(x) { o[x] = true;});\n  return util.keys(o);\n};\n\n\nutil.gen.getOpt = function (opt) {\n  //merge with default\n  return (opt ? util.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(consts.gen.DEFAULT_OPT));\n};\n\n/**\n * powerset code from http://rosettacode.org/wiki/Power_Set#JavaScript\n *\n *   var res = powerset([1,2,3,4]);\n *\n * returns\n *\n * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],\n * [2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n[edit]\n*/\n\nutil.powerset = function(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n};\n\nutil.chooseKorLess = function(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length <= k){\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n};\n\nutil.chooseK = function(list, k) {\n  var subset = [[]];\n  var kArray =[];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length < k){\n        subset.push(sub);\n      }else if (sub.length === k){\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n};\n\nutil.cross = function(a,b){\n  var x = [];\n  for(var i=0; i< a.length; i++){\n    for(var j=0;j< b.length; j++){\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n};\n\n\n},{\"./consts\":9}]},{},[10])(10)\n});\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY2x1c3RlcmZjay9saWIvY2x1c3RlcmZjay5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9kaXN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9oY2x1c3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9rbWVhbnMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL3NyYy9nbG9iYWxzLmpzIiwic3JjL2NsdXN0ZXIvY2x1c3Rlci5qcyIsInNyYy9jbHVzdGVyL2NsdXN0ZXJjb25zdHMuanMiLCJzcmMvY2x1c3Rlci9kaXN0YW5jZS5qcyIsInNyYy9jb25zdHMuanMiLCJzcmMvY3AiLCJzcmMvZ2VuL2FnZ3JlZ2F0ZXMuanMiLCJzcmMvZ2VuL2VuY29kaW5ncy5qcyIsInNyYy9nZW4vZ2VuLmpzIiwic3JjL2dlbi9tYXJrdHlwZXMuanMiLCJzcmMvZ2VuL3Byb2plY3Rpb25zLmpzIiwic3JjL2dlbi9zcGVjcy5qcyIsInNyYy9nbG9iYWxzLmpzIiwic3JjL3JhbmsvcmFuay5qcyIsInNyYy9yYW5rL3JhbmtFbmNvZGluZ3MuanMiLCJzcmMvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgIGhjbHVzdGVyOiByZXF1aXJlKFwiLi9oY2x1c3RlclwiKSxcbiAgIEttZWFuczogcmVxdWlyZShcIi4va21lYW5zXCIpLFxuICAga21lYW5zOiByZXF1aXJlKFwiLi9rbWVhbnNcIikua21lYW5zXG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBldWNsaWRlYW46IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHRvdGFsICs9IE1hdGgucG93KHYyW2ldIC0gdjFbaV0sIDIpOyAgICAgIFxuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguc3FydCh0b3RhbCk7XG4gICB9LFxuICAgbWFuaGF0dGFuOiBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2MS5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModjJbaV0gLSB2MVtpXSk7ICAgICAgXG4gICAgIH1cbiAgICAgcmV0dXJuIHRvdGFsO1xuICAgfSxcbiAgIG1heDogZnVuY3Rpb24odjEsIHYyKSB7XG4gICAgIHZhciBtYXggPSAwO1xuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCAsIE1hdGguYWJzKHYyW2ldIC0gdjFbaV0pKTsgICAgICBcbiAgICAgfVxuICAgICByZXR1cm4gbWF4O1xuICAgfVxufTsiLCJ2YXIgZGlzdGFuY2VzID0gcmVxdWlyZShcIi4vZGlzdGFuY2VcIik7XG5cbnZhciBIaWVyYXJjaGljYWxDbHVzdGVyaW5nID0gZnVuY3Rpb24oZGlzdGFuY2UsIGxpbmthZ2UsIHRocmVzaG9sZCkge1xuICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgdGhpcy5saW5rYWdlID0gbGlua2FnZTtcbiAgIHRoaXMudGhyZXNob2xkID0gdGhyZXNob2xkID09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhyZXNob2xkO1xufVxuXG5IaWVyYXJjaGljYWxDbHVzdGVyaW5nLnByb3RvdHlwZSA9IHtcbiAgIGNsdXN0ZXIgOiBmdW5jdGlvbihpdGVtcywgc25hcHNob3RQZXJpb2QsIHNuYXBzaG90Q2IpIHtcbiAgICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICAgIHRoaXMuZGlzdHMgPSBbXTsgIC8vIGRpc3RhbmNlcyBiZXR3ZWVuIGVhY2ggcGFpciBvZiBjbHVzdGVyc1xuICAgICAgdGhpcy5taW5zID0gW107IC8vIGNsb3Nlc3QgY2x1c3RlciBmb3IgZWFjaCBjbHVzdGVyXG4gICAgICB0aGlzLmluZGV4ID0gW107IC8vIGtlZXAgYSBoYXNoIG9mIGFsbCBjbHVzdGVycyBieSBrZXlcbiAgICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGNsdXN0ZXIgPSB7XG4gICAgICAgICAgICB2YWx1ZTogaXRlbXNbaV0sXG4gICAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgIH07XG4gICAgICAgICB0aGlzLmNsdXN0ZXJzW2ldID0gY2x1c3RlcjtcbiAgICAgICAgIHRoaXMuaW5kZXhbaV0gPSBjbHVzdGVyO1xuICAgICAgICAgdGhpcy5kaXN0c1tpXSA9IFtdO1xuICAgICAgICAgdGhpcy5taW5zW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBpOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gKGkgPT0gaikgPyBJbmZpbml0eSA6IFxuICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSh0aGlzLmNsdXN0ZXJzW2ldLnZhbHVlLCB0aGlzLmNsdXN0ZXJzW2pdLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZGlzdHNbaV1bal0gPSBkaXN0O1xuICAgICAgICAgICAgdGhpcy5kaXN0c1tqXVtpXSA9IGRpc3Q7XG5cbiAgICAgICAgICAgIGlmIChkaXN0IDwgdGhpcy5kaXN0c1tpXVt0aGlzLm1pbnNbaV1dKSB7XG4gICAgICAgICAgICAgICB0aGlzLm1pbnNbaV0gPSBqOyAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWVyZ2VkID0gdGhpcy5tZXJnZUNsb3Nlc3QoKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChtZXJnZWQpIHtcbiAgICAgICAgaWYgKHNuYXBzaG90Q2IgJiYgKGkrKyAlIHNuYXBzaG90UGVyaW9kKSA9PSAwKSB7XG4gICAgICAgICAgIHNuYXBzaG90Q2IodGhpcy5jbHVzdGVycyk7ICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBtZXJnZWQgPSB0aGlzLm1lcmdlQ2xvc2VzdCgpO1xuICAgICAgfVxuICAgIFxuICAgICAgdGhpcy5jbHVzdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGNsdXN0ZXIpIHtcbiAgICAgICAgLy8gY2xlYW4gdXAgbWV0YWRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuICAgICAgICBkZWxldGUgY2x1c3Rlci5rZXk7XG4gICAgICAgIGRlbGV0ZSBjbHVzdGVyLmluZGV4O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJzO1xuICAgfSxcbiAgXG4gICBtZXJnZUNsb3Nlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gZmluZCB0d28gY2xvc2VzdCBjbHVzdGVycyBmcm9tIGNhY2hlZCBtaW5zXG4gICAgICB2YXIgbWluS2V5ID0gMCwgbWluID0gSW5maW5pdHk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBrZXkgPSB0aGlzLmNsdXN0ZXJzW2ldLmtleSxcbiAgICAgICAgICAgICBkaXN0ID0gdGhpcy5kaXN0c1trZXldW3RoaXMubWluc1trZXldXTtcbiAgICAgICAgIGlmIChkaXN0IDwgbWluKSB7XG4gICAgICAgICAgICBtaW5LZXkgPSBrZXk7XG4gICAgICAgICAgICBtaW4gPSBkaXN0O1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1pbiA+PSB0aGlzLnRocmVzaG9sZCkge1xuICAgICAgICAgcmV0dXJuIGZhbHNlOyAgICAgICAgIFxuICAgICAgfVxuXG4gICAgICB2YXIgYzEgPSB0aGlzLmluZGV4W21pbktleV0sXG4gICAgICAgICAgYzIgPSB0aGlzLmluZGV4W3RoaXMubWluc1ttaW5LZXldXTtcblxuICAgICAgLy8gbWVyZ2UgdHdvIGNsb3Nlc3QgY2x1c3RlcnNcbiAgICAgIHZhciBtZXJnZWQgPSB7XG4gICAgICAgICBsZWZ0OiBjMSxcbiAgICAgICAgIHJpZ2h0OiBjMixcbiAgICAgICAgIGtleTogYzEua2V5LFxuICAgICAgICAgc2l6ZTogYzEuc2l6ZSArIGMyLnNpemVcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuY2x1c3RlcnNbYzEuaW5kZXhdID0gbWVyZ2VkO1xuICAgICAgdGhpcy5jbHVzdGVycy5zcGxpY2UoYzIuaW5kZXgsIDEpO1xuICAgICAgdGhpcy5pbmRleFtjMS5rZXldID0gbWVyZ2VkO1xuXG4gICAgICAvLyB1cGRhdGUgZGlzdGFuY2VzIHdpdGggbmV3IG1lcmdlZCBjbHVzdGVyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBjaSA9IHRoaXMuY2x1c3RlcnNbaV07XG4gICAgICAgICB2YXIgZGlzdDtcbiAgICAgICAgIGlmIChjMS5rZXkgPT0gY2kua2V5KSB7XG4gICAgICAgICAgICBkaXN0ID0gSW5maW5pdHk7ICAgICAgICAgICAgXG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmICh0aGlzLmxpbmthZ2UgPT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgZGlzdCA9IHRoaXMuZGlzdHNbYzEua2V5XVtjaS5rZXldO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzdHNbYzEua2V5XVtjaS5rZXldID4gdGhpcy5kaXN0c1tjMi5rZXldW2NpLmtleV0pIHtcbiAgICAgICAgICAgICAgIGRpc3QgPSB0aGlzLmRpc3RzW2MyLmtleV1bY2kua2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKHRoaXMubGlua2FnZSA9PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgIGRpc3QgPSB0aGlzLmRpc3RzW2MxLmtleV1bY2kua2V5XTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3RzW2MxLmtleV1bY2kua2V5XSA8IHRoaXMuZGlzdHNbYzIua2V5XVtjaS5rZXldKSB7XG4gICAgICAgICAgICAgICBkaXN0ID0gdGhpcy5kaXN0c1tjMi5rZXldW2NpLmtleV07ICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKHRoaXMubGlua2FnZSA9PSBcImF2ZXJhZ2VcIikge1xuICAgICAgICAgICAgZGlzdCA9ICh0aGlzLmRpc3RzW2MxLmtleV1bY2kua2V5XSAqIGMxLnNpemVcbiAgICAgICAgICAgICAgICAgICArIHRoaXMuZGlzdHNbYzIua2V5XVtjaS5rZXldICogYzIuc2l6ZSkgLyAoYzEuc2l6ZSArIGMyLnNpemUpO1xuICAgICAgICAgfVxuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkaXN0ID0gdGhpcy5kaXN0YW5jZShjaS52YWx1ZSwgYzEudmFsdWUpOyAgICAgICAgICAgIFxuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLmRpc3RzW2MxLmtleV1bY2kua2V5XSA9IHRoaXMuZGlzdHNbY2kua2V5XVtjMS5rZXldID0gZGlzdDtcbiAgICAgIH1cblxuICAgIFxuICAgICAgLy8gdXBkYXRlIGNhY2hlZCBtaW5zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBrZXkxID0gdGhpcy5jbHVzdGVyc1tpXS5rZXk7ICAgICAgICBcbiAgICAgICAgIGlmICh0aGlzLm1pbnNba2V5MV0gPT0gYzEua2V5IHx8IHRoaXMubWluc1trZXkxXSA9PSBjMi5rZXkpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBrZXkxO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNsdXN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICB2YXIga2V5MiA9IHRoaXMuY2x1c3RlcnNbal0ua2V5O1xuICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzdHNba2V5MV1ba2V5Ml0gPCB0aGlzLmRpc3RzW2tleTFdW21pbl0pIHtcbiAgICAgICAgICAgICAgICAgIG1pbiA9IGtleTI7ICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1pbnNba2V5MV0gPSBtaW47XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLmNsdXN0ZXJzW2ldLmluZGV4ID0gaTtcbiAgICAgIH1cbiAgICBcbiAgICAgIC8vIGNsZWFuIHVwIG1ldGFkYXRhIHVzZWQgZm9yIGNsdXN0ZXJpbmdcbiAgICAgIGRlbGV0ZSBjMS5rZXk7IGRlbGV0ZSBjMi5rZXk7XG4gICAgICBkZWxldGUgYzEuaW5kZXg7IGRlbGV0ZSBjMi5pbmRleDtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICB9XG59XG5cbnZhciBoY2x1c3RlciA9IGZ1bmN0aW9uKGl0ZW1zLCBkaXN0YW5jZSwgbGlua2FnZSwgdGhyZXNob2xkLCBzbmFwc2hvdCwgc25hcHNob3RDYWxsYmFjaykge1xuICAgZGlzdGFuY2UgPSBkaXN0YW5jZSB8fCBcImV1Y2xpZGVhblwiO1xuICAgbGlua2FnZSA9IGxpbmthZ2UgfHwgXCJhdmVyYWdlXCI7XG5cbiAgIGlmICh0eXBlb2YgZGlzdGFuY2UgPT0gXCJzdHJpbmdcIikge1xuICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlc1tkaXN0YW5jZV07XG4gICB9XG4gICB2YXIgY2x1c3RlcnMgPSAobmV3IEhpZXJhcmNoaWNhbENsdXN0ZXJpbmcoZGlzdGFuY2UsIGxpbmthZ2UsIHRocmVzaG9sZCkpXG4gICAgICAgICAgICAgICAgICAuY2x1c3RlcihpdGVtcywgc25hcHNob3QsIHNuYXBzaG90Q2FsbGJhY2spO1xuICAgICAgXG4gICBpZiAodGhyZXNob2xkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjbHVzdGVyc1swXTsgLy8gYWxsIGNsdXN0ZXJlZCBpbnRvIG9uZVxuICAgfVxuICAgcmV0dXJuIGNsdXN0ZXJzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhjbHVzdGVyO1xuIiwidmFyIGRpc3RhbmNlcyA9IHJlcXVpcmUoXCIuL2Rpc3RhbmNlXCIpO1xuXG5mdW5jdGlvbiBLTWVhbnMoY2VudHJvaWRzKSB7XG4gICB0aGlzLmNlbnRyb2lkcyA9IGNlbnRyb2lkcyB8fCBbXTtcbn1cblxuS01lYW5zLnByb3RvdHlwZS5yYW5kb21DZW50cm9pZHMgPSBmdW5jdGlvbihwb2ludHMsIGspIHtcbiAgIHZhciBjZW50cm9pZHMgPSBwb2ludHMuc2xpY2UoMCk7IC8vIGNvcHlcbiAgIGNlbnRyb2lkcy5zb3J0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkpIC0gMC41KTtcbiAgIH0pO1xuICAgcmV0dXJuIGNlbnRyb2lkcy5zbGljZSgwLCBrKTtcbn1cblxuS01lYW5zLnByb3RvdHlwZS5jbGFzc2lmeSA9IGZ1bmN0aW9uKHBvaW50LCBkaXN0YW5jZSkge1xuICAgdmFyIG1pbiA9IEluZmluaXR5LFxuICAgICAgIGluZGV4ID0gMDtcblxuICAgZGlzdGFuY2UgPSBkaXN0YW5jZSB8fCBcImV1Y2xpZGVhblwiO1xuICAgaWYgKHR5cGVvZiBkaXN0YW5jZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlc1tkaXN0YW5jZV07XG4gICB9XG5cbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jZW50cm9pZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaXN0ID0gZGlzdGFuY2UocG9pbnQsIHRoaXMuY2VudHJvaWRzW2ldKTtcbiAgICAgIGlmIChkaXN0IDwgbWluKSB7XG4gICAgICAgICBtaW4gPSBkaXN0O1xuICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgfVxuICAgfVxuXG4gICByZXR1cm4gaW5kZXg7XG59XG5cbktNZWFucy5wcm90b3R5cGUuY2x1c3RlciA9IGZ1bmN0aW9uKHBvaW50cywgaywgZGlzdGFuY2UsIHNuYXBzaG90UGVyaW9kLCBzbmFwc2hvdENiKSB7XG4gICBrID0gayB8fCBNYXRoLm1heCgyLCBNYXRoLmNlaWwoTWF0aC5zcXJ0KHBvaW50cy5sZW5ndGggLyAyKSkpO1xuXG4gICBkaXN0YW5jZSA9IGRpc3RhbmNlIHx8IFwiZXVjbGlkZWFuXCI7XG4gICBpZiAodHlwZW9mIGRpc3RhbmNlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2VzW2Rpc3RhbmNlXTtcbiAgIH1cblxuICAgdGhpcy5jZW50cm9pZHMgPSB0aGlzLnJhbmRvbUNlbnRyb2lkcyhwb2ludHMsIGspO1xuXG4gICB2YXIgYXNzaWdubWVudCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoKTtcbiAgIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShrKTtcblxuICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgdmFyIG1vdmVtZW50ID0gdHJ1ZTtcbiAgIHdoaWxlIChtb3ZlbWVudCkge1xuICAgICAgLy8gdXBkYXRlIHBvaW50LXRvLWNlbnRyb2lkIGFzc2lnbm1lbnRzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgYXNzaWdubWVudFtpXSA9IHRoaXMuY2xhc3NpZnkocG9pbnRzW2ldLCBkaXN0YW5jZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBsb2NhdGlvbiBvZiBlYWNoIGNlbnRyb2lkXG4gICAgICBtb3ZlbWVudCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrOyBqKyspIHtcbiAgICAgICAgIHZhciBhc3NpZ25lZCA9IFtdO1xuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3NpZ25tZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXNzaWdubWVudFtpXSA9PSBqKSB7XG4gICAgICAgICAgICAgICBhc3NpZ25lZC5wdXNoKHBvaW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICghYXNzaWduZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIGNlbnRyb2lkID0gdGhpcy5jZW50cm9pZHNbal07XG4gICAgICAgICB2YXIgbmV3Q2VudHJvaWQgPSBuZXcgQXJyYXkoY2VudHJvaWQubGVuZ3RoKTtcblxuICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBjZW50cm9pZC5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzc2lnbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICBzdW0gKz0gYXNzaWduZWRbaV1bZ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdDZW50cm9pZFtnXSA9IHN1bSAvIGFzc2lnbmVkLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKG5ld0NlbnRyb2lkW2ddICE9IGNlbnRyb2lkW2ddKSB7XG4gICAgICAgICAgICAgICBtb3ZlbWVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuY2VudHJvaWRzW2pdID0gbmV3Q2VudHJvaWQ7XG4gICAgICAgICBjbHVzdGVyc1tqXSA9IGFzc2lnbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoc25hcHNob3RDYiAmJiAoaXRlcmF0aW9ucysrICUgc25hcHNob3RQZXJpb2QgPT0gMCkpIHtcbiAgICAgICAgIHNuYXBzaG90Q2IoY2x1c3RlcnMpO1xuICAgICAgfVxuICAgfVxuXG4gICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbktNZWFucy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5jZW50cm9pZHMpO1xufVxuXG5LTWVhbnMucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24oanNvbikge1xuICAgdGhpcy5jZW50cm9pZHMgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS01lYW5zO1xuXG5tb2R1bGUuZXhwb3J0cy5rbWVhbnMgPSBmdW5jdGlvbih2ZWN0b3JzLCBrKSB7XG4gICByZXR1cm4gKG5ldyBLTWVhbnMoKSkuY2x1c3Rlcih2ZWN0b3JzLCBrKTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8vIGRlY2xhcmUgZ2xvYmFsIGNvbnN0YW50XG52YXIgZyA9IGdsb2JhbCB8fCB3aW5kb3c7XG5cbmcuQUdHUkVHQVRFID0gJ2FnZ3JlZ2F0ZSc7XG5nLlJBVyA9ICdyYXcnO1xuZy5TVEFDS0VEID0gJ3N0YWNrZWQnO1xuZy5JTkRFWCA9ICdpbmRleCc7XG5cbmcuWCA9ICd4JztcbmcuWSA9ICd5JztcbmcuUk9XID0gJ3Jvdyc7XG5nLkNPTCA9ICdjb2wnO1xuZy5TSVpFID0gJ3NpemUnO1xuZy5TSEFQRSA9ICdzaGFwZSc7XG5nLkNPTE9SID0gJ2NvbG9yJztcbmcuVEVYVCA9ICd0ZXh0JztcbmcuREVUQUlMID0gJ2RldGFpbCc7XG5cbmcuTiA9ICdOJztcbmcuTyA9ICdPJztcbmcuUSA9ICdRJztcbmcuVCA9ICdUJztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsdXN0ZXI7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2bCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmwnXSA6IG51bGwpLFxuICBjbHVzdGVyZmNrID0gcmVxdWlyZSgnY2x1c3RlcmZjaycpLFxuICBjb25zdHMgPSByZXF1aXJlKCcuL2NsdXN0ZXJjb25zdHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuY2x1c3Rlci5kaXN0YW5jZSA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKTtcblxuZnVuY3Rpb24gY2x1c3RlcihzcGVjcywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIGRpc3QgPSBjbHVzdGVyLmRpc3RhbmNlLnRhYmxlKHNwZWNzKTtcblxuICB2YXIgY2x1c3RlclRyZWVzID0gY2x1c3RlcmZjay5oY2x1c3RlcihzcGVjcywgZnVuY3Rpb24oZTEsIGUyKSB7XG4gICAgdmFyIHMxID0gdmwuRW5jb2Rpbmcuc2hvcnRoYW5kKGUxKSxcbiAgICAgIHMyID0gdmwuRW5jb2Rpbmcuc2hvcnRoYW5kKGUyKTtcbiAgICByZXR1cm4gZGlzdFtzMV1bczJdO1xuICB9LCAnYXZlcmFnZScsIGNvbnN0cy5DTFVTVEVSX1RIUkVTSE9MRCk7XG5cbiAgdmFyIGNsdXN0ZXJzID0gY2x1c3RlclRyZWVzLm1hcChmdW5jdGlvbih0cmVlKSB7XG4gICAgICByZXR1cm4gdXRpbC50cmF2ZXJzZSh0cmVlLCBbXSk7XG4gICAgfSlcbiAgIC5tYXAoZnVuY3Rpb24oY2x1c3Rlcikge1xuICAgIHJldHVybiBjbHVzdGVyLnNvcnQoZnVuY3Rpb24oc3BlYzEsIHNwZWMyKSB7XG4gICAgICAvLyBzb3J0IGVhY2ggY2x1c3RlciAtLSBoYXZlIHRoZSBoaWdoZXN0IHNjb3JlIGFzIDFzdCBpdGVtXG4gICAgICByZXR1cm4gc3BlYzIuX2luZm8uc2NvcmUgLSBzcGVjMS5faW5mby5zY29yZTtcbiAgICB9KTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uKGNsdXN0ZXIpIHsgIC8vIGZpbHRlciBlbXB0eSBjbHVzdGVyXG4gICAgcmV0dXJuIGNsdXN0ZXIubGVuZ3RoID4wO1xuICB9KS5zb3J0KGZ1bmN0aW9uKGNsdXN0ZXIxLCBjbHVzdGVyMikge1xuICAgIC8vc29ydCBieSBoaWdoZXN0IHNjb3JpbmcgaXRlbSBpbiBlYWNoIGNsdXN0ZXJcbiAgICByZXR1cm4gY2x1c3RlcjJbMF0uX2luZm8uc2NvcmUgLSBjbHVzdGVyMVswXS5faW5mby5zY29yZTtcbiAgfSk7XG5cbiAgY2x1c3RlcnMuZGlzdCA9IGRpc3Q7IC8vYXBwZW5kIGRpc3QgaW4gdGhlIGFycmF5IGZvciBkZWJ1Z2dpbmdcblxuICByZXR1cm4gY2x1c3RlcnM7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmMuU1dBUFBBQkxFID0gMC4wNTtcbmMuRElTVF9NSVNTSU5HID0gMTtcbmMuQ0xVU1RFUl9USFJFU0hPTEQgPSAxO1xuXG5mdW5jdGlvbiByZWR1Y2VUdXBsZVRvVGFibGUociwgeCkge1xuICB2YXIgYSA9IHhbMF0sIGIgPSB4WzFdLCBkID0geFsyXTtcbiAgclthXSA9IHJbYV0gfHwge307XG4gIHJbYl0gPSByW2JdIHx8IHt9O1xuICByW2FdW2JdID0gcltiXVthXSA9IGQ7XG4gIHJldHVybiByO1xufVxuXG5jLkRJU1RfQllfRU5DVFlQRSA9IFtcbiAgLy8gcG9zaXRpb25hbFxuICBbJ3gnLCAneScsIGMuU1dBUFBBQkxFXSxcbiAgWydyb3cnLCAnY29sJywgYy5TV0FQUEFCTEVdLFxuXG4gIC8vIG9yZGluYWwgbWFyayBwcm9wZXJ0aWVzXG4gIFsnY29sb3InLCAnc2hhcGUnLCBjLlNXQVBQQUJMRV0sXG4gIFsnY29sb3InLCAnZGV0YWlsJywgYy5TV0FQUEFCTEVdLFxuICBbJ2RldGFpbCcsICdzaGFwZScsIGMuU1dBUFBBQkxFXSxcblxuICAvLyBxdWFudGl0YXRpdmUgbWFyayBwcm9wZXJ0aWVzXG4gIFsnc2l6ZScsICdjb2xvcicsIGMuU1dBUFBBQkxFXVxuXS5yZWR1Y2UocmVkdWNlVHVwbGVUb1RhYmxlLCB7fSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2bCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmwnXSA6IG51bGwpLFxuICBjb25zdHMgPSByZXF1aXJlKCcuL2NsdXN0ZXJjb25zdHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIGRpc3RhbmNlID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGRpc3RhbmNlO1xuXG5kaXN0YW5jZS50YWJsZSA9IGZ1bmN0aW9uIChzcGVjcykge1xuICB2YXIgbGVuID0gc3BlY3MubGVuZ3RoLFxuICAgIGV4dGVuZGVkU3BlY3MgPSBzcGVjcy5tYXAoZnVuY3Rpb24oZSkgeyByZXR1cm4gZGlzdGFuY2UuZXh0ZW5kU3BlY1dpdGhFbmNUeXBlQnlDb2x1bW5OYW1lKGUpOyB9KSxcbiAgICBzaG9ydGhhbmRzID0gc3BlY3MubWFwKHZsLkVuY29kaW5nLnNob3J0aGFuZCksXG4gICAgZGlmZiA9IHt9LCBpLCBqO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgZGlmZltzaG9ydGhhbmRzW2ldXSA9IHt9O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBzaiA9IHNob3J0aGFuZHNbal0sIHNpID0gc2hvcnRoYW5kc1tpXTtcblxuICAgICAgZGlmZltzal1bc2ldID0gZGlmZltzaV1bc2pdID0gZGlzdGFuY2UuZ2V0KGV4dGVuZGVkU3BlY3NbaV0sIGV4dGVuZGVkU3BlY3Nbal0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn07XG5cbmRpc3RhbmNlLmdldCA9IGZ1bmN0aW9uIChleHRlbmRlZFNwZWMxLCBleHRlbmRlZFNwZWMyKSB7XG4gIHZhciBjb2xzID0gdXRpbC51bmlvbih2bC5rZXlzKGV4dGVuZGVkU3BlYzEuZW5jVHlwZUJ5RmllbGQpLCB2bC5rZXlzKGV4dGVuZGVkU3BlYzIuZW5jVHlwZUJ5RmllbGQpKSxcbiAgICBkaXN0ID0gMDtcblxuICBjb2xzLmZvckVhY2goZnVuY3Rpb24oY29sKSB7XG4gICAgdmFyIGUxID0gZXh0ZW5kZWRTcGVjMS5lbmNUeXBlQnlGaWVsZFtjb2xdLCBlMiA9IGV4dGVuZGVkU3BlYzIuZW5jVHlwZUJ5RmllbGRbY29sXTtcblxuICAgIGlmIChlMSAmJiBlMikge1xuICAgICAgaWYgKGUxLmVuY1R5cGUgIT0gZTIuZW5jVHlwZSkge1xuICAgICAgICBkaXN0ICs9IChjb25zdHMuRElTVF9CWV9FTkNUWVBFW2UxLmVuY1R5cGVdIHx8IHt9KVtlMi5lbmNUeXBlXSB8fCAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXN0ICs9IGNvbnN0cy5ESVNUX01JU1NJTkc7XG4gICAgfVxuICB9KTtcblxuICAvLyBkbyBub3QgZ3JvdXAgc3RhY2tlZCBjaGFydCB3aXRoIHNpbWlsYXIgbm9uLXN0YWNrZWQgY2hhcnQhXG4gIHZhciBpc1N0YWNrMSA9IHZsLkVuY29kaW5nLmlzU3RhY2soZXh0ZW5kZWRTcGVjMSksXG4gICAgaXNTdGFjazIgPSB2bC5FbmNvZGluZy5pc1N0YWNrKGV4dGVuZGVkU3BlYzIpO1xuXG4gIGlmKGlzU3RhY2sxIHx8IGlzU3RhY2syKSB7XG4gICAgaWYoaXNTdGFjazEgJiYgaXNTdGFjazIpIHtcbiAgICAgIGlmKGV4dGVuZGVkU3BlYzEuZW5jb2RpbmcuY29sb3IubmFtZSAhPT0gZXh0ZW5kZWRTcGVjMi5lbmNvZGluZy5jb2xvci5uYW1lKSB7XG4gICAgICAgIGRpc3QrPTE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3QrPTE7IC8vIHN1cmVseSBkaWZmZXJlbnRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpc3Q7XG59O1xuXG4vLyBnZXQgZW5jb2RpbmcgdHlwZSBieSBmaWVsZG5hbWVcbmRpc3RhbmNlLmV4dGVuZFNwZWNXaXRoRW5jVHlwZUJ5Q29sdW1uTmFtZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgdmFyIF9lbmNUeXBlQnlGaWVsZCA9IHt9LFxuICAgIGVuY29kaW5nID0gc3BlYy5lbmNvZGluZztcblxuICB2bC5rZXlzKGVuY29kaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICB2YXIgZSA9IHZsLmR1cGxpY2F0ZShlbmNvZGluZ1tlbmNUeXBlXSk7XG4gICAgZS5lbmNUeXBlID0gZW5jVHlwZTtcbiAgICBfZW5jVHlwZUJ5RmllbGRbZS5uYW1lIHx8ICcnXSA9IGU7XG4gICAgZGVsZXRlIGUubmFtZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtYXJrdHlwZTogc3BlYy5tYXJrdHlwZSxcbiAgICBlbmNUeXBlQnlGaWVsZDogX2VuY1R5cGVCeUZpZWxkLFxuICAgIGVuY29kaW5nOiBzcGVjLmVuY29kaW5nXG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbnN0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBnZW46IHt9LFxuICBjbHVzdGVyOiB7fSxcbiAgcmFuazoge31cbn07XG5cbmNvbnN0cy5nZW4ucHJvamVjdGlvbnMgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgb21pdERvdFBsb3Q6IHsgLy9GSVhNRSByZW1vdmUgdGhpcyFcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICdyZW1vdmUgYWxsIGRvdCBwbG90cydcbiAgICB9LFxuICAgIG1heENhcmRpbmFsaXR5Rm9yQXV0b0FkZE9yZGluYWw6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDUwLFxuICAgICAgZGVzY3JpcHRpb246ICdtYXggY2FyZGluYWxpdHkgZm9yIG9yZGluYWwgZmllbGQgdG8gYmUgY29uc2lkZXJlZCBmb3IgYXV0byBhZGRpbmcnXG4gICAgfSxcbiAgICBhbHdheXNBZGRIaXN0b2dyYW06IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0cy5nZW4uYWdncmVnYXRlcyA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBjb25maWc6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0J1xuICAgIH0sXG4gICAgdGFibGVUeXBlczoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogJ2JvdGgnLFxuICAgICAgZW51bTogWydib3RoJywgJ2FnZ3JlZ2F0ZWQnLCAnZGlzYWdncmVnYXRlZCddXG4gICAgfSxcbiAgICBnZW5EaW1ROiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdhdXRvJyxcbiAgICAgIGVudW06IFsnYXV0bycsICdiaW4nLCAnY2FzdCcsICdub25lJ10sXG4gICAgICBkZXNjcmlwdGlvbjogJ1VzZSBRIGFzIERpbWVuc2lvbiBlaXRoZXIgYnkgYmlubmluZyBvciBjYXN0aW5nJ1xuICAgIH0sXG4gICAgbWluQ2FyZGluYWxpdHlGb3JCaW46IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwLFxuICAgICAgZGVzY3JpcHRpb246ICdtaW5pbXVtIGNhcmRpbmFsaXR5IG9mIGEgZmllbGQgaWYgd2Ugd2VyZSB0byBiaW4nXG4gICAgfSxcbiAgICBvbWl0RG90UGxvdDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ3JlbW92ZSBhbGwgZG90IHBsb3RzJ1xuICAgIH0sXG4gICAgb21pdE1lYXN1cmVPbmx5OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnT21pdCBhZ2dyZWdhdGlvbiB3aXRoIG1lYXN1cmUocykgb25seSdcbiAgICB9LFxuICAgIG9taXREaW1lbnNpb25Pbmx5OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdPbWl0IGFnZ3JlZ2F0aW9uIHdpdGggZGltZW5zaW9uKHMpIG9ubHknXG4gICAgfSxcbiAgICBhZGRDb3VudEZvckRpbWVuc2lvbk9ubHk6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ0FkZCBjb3VudCB3aGVuIHRoZXJlIGFyZSBkaW1lbnNpb24ocykgb25seSdcbiAgICB9LFxuICAgIGFnZ3JMaXN0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogWydzdHJpbmcnXVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFt1bmRlZmluZWQsICdtZWFuJ11cbiAgICB9LFxuICAgIHRpbWVVbml0TGlzdDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6IFsnc3RyaW5nJ11cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBbJ3llYXInXVxuICAgIH0sXG4gICAgY29uc2lzdGVudEF1dG9ROiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246IFwiZ2VuZXJhdGUgc2ltaWxhciBhdXRvIHRyYW5zZm9ybSBmb3IgcXVhbnRcIlxuICAgIH1cbiAgfVxufTtcblxuY29uc3RzLmdlbi5lbmNvZGluZ3MgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbWFya3R5cGVMaXN0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICBkZWZhdWx0OiBbJ3BvaW50JywgJ2JhcicsICdsaW5lJywgJ2FyZWEnLCAndGV4dCcsICd0aWNrJ10sIC8vZmlsbGVkX21hcFxuICAgICAgZGVzY3JpcHRpb246ICdhbGxvd2VkIG1hcmt0eXBlcydcbiAgICB9LFxuICAgIGVuY29kaW5nVHlwZUxpc3Q6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICAgIGRlZmF1bHQ6IFsneCcsICd5JywgJ3JvdycsICdjb2wnLCAnc2l6ZScsICdjb2xvcicsICd0ZXh0JywgJ2RldGFpbCddLFxuICAgICAgZGVzY3JpcHRpb246ICdhbGxvd2VkIGVuY29kaW5nIHR5cGVzJ1xuICAgIH0sXG4gICAgbWF4R29vZENhcmRpbmFsaXR5Rm9yRmFjZXRzOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA1LFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIGNhcmRpbmFsaXR5IG9mIGEgZmllbGQgdG8gYmUgcHV0IG9uIGZhY2V0IChyb3cvY29sKSBlZmZlY3RpdmVseSdcbiAgICB9LFxuICAgIG1heENhcmRpbmFsaXR5Rm9yRmFjZXRzOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMCxcbiAgICAgIGRlc2NyaXB0aW9uOiAnbWF4aW11bSBjYXJkaW5hbGl0eSBvZiBhIGZpZWxkIHRvIGJlIHB1dCBvbiBmYWNldCAocm93L2NvbCknXG4gICAgfSxcbiAgICBtYXhHb29kQ2FyZGluYWxpdHlGb3JDb2xvcjoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnbWF4aW11bSBjYXJkaW5hbGl0eSBvZiBhbiBvcmRpbmFsIGZpZWxkIHRvIGJlIHB1dCBvbiBjb2xvciBlZmZlY3RpdmVseSdcbiAgICB9LFxuICAgIG1heENhcmRpbmFsaXR5Rm9yQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwLFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIGNhcmRpbmFsaXR5IG9mIGFuIG9yZGluYWwgZmllbGQgdG8gYmUgcHV0IG9uIGNvbG9yJ1xuICAgIH0sXG4gICAgbWF4Q2FyZGluYWxpdHlGb3JTaGFwZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNixcbiAgICAgIGRlc2NyaXB0aW9uOiAnbWF4aW11bSBjYXJkaW5hbGl0eSBvZiBhbiBvcmRpbmFsIGZpZWxkIHRvIGJlIHB1dCBvbiBzaGFwZSdcbiAgICB9LFxuICAgIG9taXRUcmFucG9zZTogIHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ0VsaW1pbmF0ZSBhbGwgdHJhbnNwb3NlIGJ5ICgxKSBrZWVwaW5nIGhvcml6b250YWwgZG90IHBsb3Qgb25seSAoMikgZm9yIE94USBjaGFydHMsIGFsd2F5cyBwdXQgTyBvbiBZICgzKSBzaG93IG9ubHkgb25lIER4RCwgTXhNIChjdXJyZW50bHkgc29ydGVkIGJ5IG5hbWUpJ1xuICAgIH0sXG4gICAgb21pdERvdFBsb3Q6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICdyZW1vdmUgYWxsIGRvdCBwbG90cydcbiAgICB9LFxuICAgIG9taXREb3RQbG90V2l0aEV4dHJhRW5jb2Rpbmc6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ3JlbW92ZSBhbGwgZG90IHBsb3RzIHdpdGggPjEgZW5jb2RpbmcnXG4gICAgfSxcbiAgICBvbWl0TXVsdGlwbGVSZXRpbmFsRW5jb2RpbmdzOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdvbWl0IHVzaW5nIG11bHRpcGxlIHJldGluYWwgdmFyaWFibGVzIChzaXplLCBjb2xvciwgc2hhcGUpJ1xuICAgIH0sXG4gICAgb21pdE5vblRleHRBZ2dyV2l0aEFsbERpbXNPbkZhY2V0czoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAncmVtb3ZlIGFsbCBhZ2dyZWdhdGVkIGNoYXJ0cyAoZXhjZXB0IHRleHQgdGFibGVzKSB3aXRoIGFsbCBkaW1zIG9uIGZhY2V0cyAocm93LCBjb2wpJ1xuICAgIH0sXG4gICAgb21pdE9uZURpbWVuc2lvbkNvdW50OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnb21pdCBvbmUgZGltZW5zaW9uIGNvdW50J1xuICAgIH0sXG4gICAgb21pdFNpemVPbkJhcjoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ2RvIG5vdCB1c2UgYmFyXFwncyBzaXplJ1xuICAgIH0sXG4gICAgb21pdFN0YWNrZWRBdmVyYWdlOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdkbyBub3Qgc3RhY2sgYmFyIGNoYXJ0IHdpdGggYXZlcmFnZSdcbiAgICB9LFxuICAgIGFsd2F5c0dlbmVyYXRlVGFibGVBc0hlYXRtYXA6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uc3RzOiByZXF1aXJlKCcuL2NvbnN0cycpLFxuICBjbHVzdGVyOiByZXF1aXJlKCcuL2NsdXN0ZXIvY2x1c3RlcicpLFxuICBnZW46IHJlcXVpcmUoJy4vZ2VuL2dlbicpLFxuICByYW5rOiByZXF1aXJlKCcuL3JhbmsvcmFuaycpLFxuICB1dGlsOiByZXF1aXJlKCcuL3V0aWwnKSxcbiAgYXV0bzogXCItLCBzdW1cIlxufTtcblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2bCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmwnXSA6IG51bGwpO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi4vY29uc3RzJyk7XG5cbnZhciBBVVRPID0gJyonO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbkFnZ3JlZ2F0ZXM7XG5cbmZ1bmN0aW9uIGdlbkFnZ3JlZ2F0ZXMob3V0cHV0LCBmaWVsZERlZnMsIHN0YXRzLCBvcHQpIHtcbiAgb3B0ID0gdmwuc2NoZW1hLnV0aWwuZXh0ZW5kKG9wdHx8e30sIGNvbnN0cy5nZW4uYWdncmVnYXRlcyk7XG4gIHZhciB0ZiA9IG5ldyBBcnJheShmaWVsZERlZnMubGVuZ3RoKTtcbiAgdmFyIGhhc05vck8gPSB2bC5hbnkoZmllbGREZWZzLCBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHZsLmVuY0RlZi5pc1R5cGVzKGYsIFtOLCBPXSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGVtaXQoZmllbGRTZXQpIHtcbiAgICBmaWVsZFNldCA9IHZsLmR1cGxpY2F0ZShmaWVsZFNldCk7XG4gICAgZmllbGRTZXQua2V5ID0gdmwuZW5jRGVmLnNob3J0aGFuZHMoZmllbGRTZXQpO1xuICAgIG91dHB1dC5wdXNoKGZpZWxkU2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQW5kUHVzaCgpIHtcbiAgICBpZiAob3B0Lm9taXRNZWFzdXJlT25seSB8fCBvcHQub21pdERpbWVuc2lvbk9ubHkpIHtcbiAgICAgIHZhciBoYXNNZWFzdXJlID0gZmFsc2UsIGhhc0RpbWVuc2lvbiA9IGZhbHNlLCBoYXNSYXcgPSBmYWxzZTtcbiAgICAgIHRmLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICBpZiAodmwuZW5jRGVmLmlzRGltZW5zaW9uKGYpKSB7XG4gICAgICAgICAgaGFzRGltZW5zaW9uID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIWYuYWdncmVnYXRlKSBoYXNSYXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghaGFzRGltZW5zaW9uICYmICFoYXNSYXcgJiYgb3B0Lm9taXRNZWFzdXJlT25seSkgcmV0dXJuO1xuICAgICAgaWYgKCFoYXNNZWFzdXJlKSB7XG4gICAgICAgIGlmIChvcHQuYWRkQ291bnRGb3JEaW1lbnNpb25Pbmx5KSB7XG4gICAgICAgICAgdGYucHVzaCh2bC5lbmNEZWYuY291bnQoKSk7XG4gICAgICAgICAgZW1pdCh0Zik7XG4gICAgICAgICAgdGYucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdC5vbWl0RGltZW5zaW9uT25seSkgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0Lm9taXREb3RQbG90ICYmIHRmLmxlbmd0aCA9PT0gMSkgcmV0dXJuO1xuICAgIGVtaXQodGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduQWdnclEoaSwgaGFzQWdnciwgYXV0b01vZGUsIGEpIHtcbiAgICB2YXIgY2FuSGF2ZUFnZ3IgPSBoYXNBZ2dyID09PSB0cnVlIHx8IGhhc0FnZ3IgPT09IG51bGwsXG4gICAgICBjYW50SGF2ZUFnZ3IgPSBoYXNBZ2dyID09PSBmYWxzZSB8fCBoYXNBZ2dyID09PSBudWxsO1xuICAgIGlmIChhKSB7XG4gICAgICBpZiAoY2FuSGF2ZUFnZ3IpIHtcbiAgICAgICAgdGZbaV0uYWdncmVnYXRlID0gYTtcbiAgICAgICAgYXNzaWduRmllbGQoaSArIDEsIHRydWUsIGF1dG9Nb2RlKTtcbiAgICAgICAgZGVsZXRlIHRmW2ldLmFnZ3JlZ2F0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBpZihhID09PSB1bmRlZmluZWQpXG4gICAgICBpZiAoY2FudEhhdmVBZ2dyKSB7XG4gICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCBmYWxzZSwgYXV0b01vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnbkJpblEoaSwgaGFzQWdnciwgYXV0b01vZGUpIHtcbiAgICB0ZltpXS5iaW4gPSB0cnVlO1xuICAgIGFzc2lnbkZpZWxkKGkgKyAxLCBoYXNBZ2dyLCBhdXRvTW9kZSk7XG4gICAgZGVsZXRlIHRmW2ldLmJpbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnblEoaSwgaGFzQWdnciwgYXV0b01vZGUpIHtcbiAgICB2YXIgZiA9IGZpZWxkRGVmc1tpXSxcbiAgICAgIGNhbkhhdmVBZ2dyID0gaGFzQWdnciA9PT0gdHJ1ZSB8fCBoYXNBZ2dyID09PSBudWxsO1xuXG4gICAgdGZbaV0gPSB7bmFtZTogZi5uYW1lLCB0eXBlOiBmLnR5cGV9O1xuXG4gICAgaWYgKGYuYWdncmVnYXRlID09PSAnY291bnQnKSB7IC8vIGlmIGNvdW50IGlzIGluY2x1ZGVkIGluIHRoZSBzZWxlY3RlZCBmaWVsZHNcbiAgICAgIGlmIChjYW5IYXZlQWdncikge1xuICAgICAgICB0ZltpXS5hZ2dyZWdhdGUgPSBmLmFnZ3JlZ2F0ZTtcbiAgICAgICAgYXNzaWduRmllbGQoaSArIDEsIHRydWUsIGF1dG9Nb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGYuX2FnZ3JlZ2F0ZSkge1xuICAgICAgLy8gVE9ETyBzdXBwb3J0IGFycmF5IG9mIGYuX2FnZ3JzIHRvb1xuICAgICAgYXNzaWduQWdnclEoaSwgaGFzQWdnciwgYXV0b01vZGUsIGYuX2FnZ3JlZ2F0ZSk7XG4gICAgfSBlbHNlIGlmIChmLl9yYXcpIHtcbiAgICAgIGFzc2lnbkFnZ3JRKGksIGhhc0FnZ3IsIGF1dG9Nb2RlLCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSBpZiAoZi5fYmluKSB7XG4gICAgICBhc3NpZ25CaW5RKGksIGhhc0FnZ3IsIGF1dG9Nb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0LmFnZ3JMaXN0LmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgICBpZiAoIW9wdC5jb25zaXN0ZW50QXV0b1EgfHwgYXV0b01vZGUgPT09IEFVVE8gfHwgYXV0b01vZGUgPT09IGEpIHtcbiAgICAgICAgICBhc3NpZ25BZ2dyUShpLCBoYXNBZ2dyLCBhIC8qYXNzaWduIGF1dG9Nb2RlKi8sIGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCghb3B0LmNvbnNpc3RlbnRBdXRvUSB8fCB2bC5pc2luKGF1dG9Nb2RlLCBbQVVUTywgJ2JpbicsICdjYXN0JywgJ2F1dG9jYXN0J10pKSAmJiAhaGFzTm9yTykge1xuICAgICAgICB2YXIgaGlnaENhcmRpbmFsaXR5ID0gdmwuZW5jRGVmLmNhcmRpbmFsaXR5KGYsIHN0YXRzKSA+IG9wdC5taW5DYXJkaW5hbGl0eUZvckJpbjtcblxuICAgICAgICB2YXIgaXNBdXRvID0gb3B0LmdlbkRpbVEgPT09ICdhdXRvJyxcbiAgICAgICAgICBnZW5CaW4gPSBvcHQuZ2VuRGltUSAgPT09ICdiaW4nIHx8IChpc0F1dG8gJiYgaGlnaENhcmRpbmFsaXR5KSxcbiAgICAgICAgICBnZW5DYXN0ID0gb3B0LmdlbkRpbVEgPT09ICdjYXN0JyB8fCAoaXNBdXRvICYmICFoaWdoQ2FyZGluYWxpdHkpO1xuXG4gICAgICAgIGlmIChnZW5CaW4gJiYgdmwuaXNpbihhdXRvTW9kZSwgW0FVVE8sICdiaW4nLCAnYXV0b2Nhc3QnXSkpIHtcbiAgICAgICAgICBhc3NpZ25CaW5RKGksIGhhc0FnZ3IsIGlzQXV0byA/ICdhdXRvY2FzdCcgOiAnYmluJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbkNhc3QgJiYgdmwuaXNpbihhdXRvTW9kZSwgW0FVVE8sICdjYXN0JywgJ2F1dG9jYXN0J10pKSB7XG4gICAgICAgICAgdGZbaV0udHlwZSA9ICdPJztcbiAgICAgICAgICBhc3NpZ25GaWVsZChpICsgMSwgaGFzQWdnciwgaXNBdXRvID8gJ2F1dG9jYXN0JyA6ICdjYXN0Jyk7XG4gICAgICAgICAgdGZbaV0udHlwZSA9ICdRJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnblRpbWVVbml0VChpLCBoYXNBZ2dyLCBhdXRvTW9kZSwgdGltZVVuaXQpIHtcbiAgICB0ZltpXS50aW1lVW5pdCA9IHRpbWVVbml0O1xuICAgIGFzc2lnbkZpZWxkKGkrMSwgaGFzQWdnciwgYXV0b01vZGUpO1xuICAgIGRlbGV0ZSB0ZltpXS50aW1lVW5pdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnblQoaSwgaGFzQWdnciwgYXV0b01vZGUpIHtcbiAgICB2YXIgZiA9IGZpZWxkRGVmc1tpXTtcbiAgICB0ZltpXSA9IHtuYW1lOiBmLm5hbWUsIHR5cGU6IGYudHlwZX07XG5cbiAgICAvLyBUT0RPIHN1cHBvcnQgYXJyYXkgb2YgZi5fdGltZVVuaXRzXG4gICAgaWYgKGYuX3RpbWVVbml0KSB7XG4gICAgICBhc3NpZ25UaW1lVW5pdFQoaSwgaGFzQWdnciwgYXV0b01vZGUsIGYuX3RpbWVVbml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0LnRpbWVVbml0TGlzdC5mb3JFYWNoKGZ1bmN0aW9uKHRpbWVVbml0KSB7XG4gICAgICAgIGlmICh0aW1lVW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCFoYXNBZ2dyKSB7IC8vIGNhbid0IGFnZ3JlZ2F0ZSBvdmVyIHJhdyB0aW1lXG4gICAgICAgICAgICBhc3NpZ25GaWVsZChpKzEsIGZhbHNlLCBhdXRvTW9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblRpbWVVbml0VChpLCBoYXNBZ2dyLCBhdXRvTW9kZSwgdGltZVVuaXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRSB3aGF0IGlmIHlvdSBhZ2dyZWdhdGUgdGltZT9cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnbkZpZWxkKGksIGhhc0FnZ3IsIGF1dG9Nb2RlKSB7XG4gICAgaWYgKGkgPT09IGZpZWxkRGVmcy5sZW5ndGgpIHsgLy8gSWYgYWxsIGZpZWxkcyBhcmUgYXNzaWduZWRcbiAgICAgIGNoZWNrQW5kUHVzaCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmID0gZmllbGREZWZzW2ldO1xuICAgIC8vIE90aGVyd2lzZSwgYXNzaWduIGktdGggZmllbGRcbiAgICBzd2l0Y2ggKGYudHlwZSkge1xuICAgICAgLy9UT0RPIFwiRFwiLCBcIkdcIlxuICAgICAgY2FzZSBROlxuICAgICAgICBhc3NpZ25RKGksIGhhc0FnZ3IsIGF1dG9Nb2RlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVDpcbiAgICAgICAgYXNzaWduVChpLCBoYXNBZ2dyLCBhdXRvTW9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBPOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE46XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRmW2ldID0gZjtcbiAgICAgICAgYXNzaWduRmllbGQoaSArIDEsIGhhc0FnZ3IsIGF1dG9Nb2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhc0FnZ3IgPSBvcHQudGFibGVUeXBlcyA9PT0gJ2FnZ3JlZ2F0ZWQnID8gdHJ1ZSA6IG9wdC50YWJsZVR5cGVzID09PSAnZGlzYWdncmVnYXRlZCcgPyBmYWxzZSA6IG51bGw7XG4gIGFzc2lnbkZpZWxkKDAsIGhhc0FnZ3IsIEFVVE8pO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3ZsJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2bCddIDogbnVsbCksXG4gIGdlbk1hcmtUeXBlcyA9IHJlcXVpcmUoJy4vbWFya3R5cGVzJyksXG4gIGlzRGltZW5zaW9uID0gdmwuZW5jRGVmLmlzRGltZW5zaW9uLFxuICBpc01lYXN1cmUgPSB2bC5lbmNEZWYuaXNNZWFzdXJlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbkVuY29kaW5ncztcblxuLy8gRklYTUUgcmVtb3ZlIGRpbWVuc2lvbiwgbWVhc3VyZSBhbmQgdXNlIGluZm9ybWF0aW9uIGluIHZlZ2EtbGl0ZSBpbnN0ZWFkIVxudmFyIHJ1bGVzID0ge1xuICB4OiB7XG4gICAgZGltZW5zaW9uOiB0cnVlLFxuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgbXVsdGlwbGU6IHRydWUgLy9GSVhNRSBzaG91bGQgYWxsb3cgbXVsdGlwbGUgb25seSBmb3IgUSwgVFxuICB9LFxuICB5OiB7XG4gICAgZGltZW5zaW9uOiB0cnVlLFxuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgbXVsdGlwbGU6IHRydWUgLy9GSVhNRSBzaG91bGQgYWxsb3cgbXVsdGlwbGUgb25seSBmb3IgUSwgVFxuICB9LFxuICByb3c6IHtcbiAgICBkaW1lbnNpb246IHRydWUsXG4gICAgbXVsdGlwbGU6IHRydWVcbiAgfSxcbiAgY29sOiB7XG4gICAgZGltZW5zaW9uOiB0cnVlLFxuICAgIG11bHRpcGxlOiB0cnVlXG4gIH0sXG4gIHNoYXBlOiB7XG4gICAgZGltZW5zaW9uOiB0cnVlLFxuICAgIHJ1bGVzOiBzaGFwZVJ1bGVzXG4gIH0sXG4gIHNpemU6IHtcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIHJ1bGVzOiByZXRpbmFsRW5jUnVsZXNcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBkaW1lbnNpb246IHRydWUsXG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBydWxlczogY29sb3JSdWxlc1xuICB9LFxuICB0ZXh0OiB7XG4gICAgbWVhc3VyZTogdHJ1ZVxuICB9LFxuICBkZXRhaWw6IHtcbiAgICBkaW1lbnNpb246IHRydWVcbiAgfVxuICAvL2dlbzoge1xuICAvLyAgZ2VvOiB0cnVlXG4gIC8vfSxcbiAgLy9hcmM6IHsgLy8gcGllXG4gIC8vXG4gIC8vfVxufTtcblxuZnVuY3Rpb24gcmV0aW5hbEVuY1J1bGVzKGVuY29kaW5nLCBmaWVsZERlZiwgc3RhdHMsIG9wdCkge1xuICBpZiAob3B0Lm9taXRNdWx0aXBsZVJldGluYWxFbmNvZGluZ3MpIHtcbiAgICBpZiAoZW5jb2RpbmcuY29sb3IgfHwgZW5jb2Rpbmcuc2l6ZSB8fCBlbmNvZGluZy5zaGFwZSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb2xvclJ1bGVzKGVuY29kaW5nLCBmaWVsZERlZiwgc3RhdHMsIG9wdCkge1xuICBpZighcmV0aW5hbEVuY1J1bGVzKGVuY29kaW5nLCBmaWVsZERlZiwgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdmwuZW5jRGVmLmlzTWVhc3VyZShmaWVsZERlZikgfHxcbiAgICB2bC5lbmNEZWYuY2FyZGluYWxpdHkoZmllbGREZWYsIHN0YXRzKSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JDb2xvcjtcbn1cblxuZnVuY3Rpb24gc2hhcGVSdWxlcyhlbmNvZGluZywgZmllbGREZWYsIHN0YXRzLCBvcHQpIHtcbiAgaWYoIXJldGluYWxFbmNSdWxlcyhlbmNvZGluZywgZmllbGREZWYsIHN0YXRzLCBvcHQpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGZpZWxkRGVmLmJpbiAmJiBmaWVsZERlZi50eXBlID09PSBRKSByZXR1cm4gZmFsc2U7XG4gIGlmIChmaWVsZERlZi50aW1lVW5pdCAmJiBmaWVsZERlZi50eXBlID09PSBUKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB2bC5lbmNEZWYuY2FyZGluYWxpdHkoZmllbGREZWYsIHN0YXRzKSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JDb2xvcjtcbn1cblxuZnVuY3Rpb24gZGltTWVhVHJhbnNwb3NlUnVsZShlbmNvZGluZykge1xuICAvLyBjcmVhdGUgaG9yaXpvbnRhbCBoaXN0b2dyYW0gZm9yIG9yZGluYWxcbiAgaWYgKHZsLmVuY0RlZi5pc1R5cGVzKGVuY29kaW5nLnksIFtOLCBPXSkgJiYgaXNNZWFzdXJlKGVuY29kaW5nLngpKSByZXR1cm4gdHJ1ZTtcblxuICAvLyB2ZXJ0aWNhbCBoaXN0b2dyYW0gZm9yIFEgYW5kIFRcbiAgaWYgKGlzTWVhc3VyZShlbmNvZGluZy55KSAmJiAoIXZsLmVuY0RlZi5pc1R5cGVzKGVuY29kaW5nLngsIFtOLCBPXSkgJiYgaXNEaW1lbnNpb24oZW5jb2RpbmcueCkpKSByZXR1cm4gdHJ1ZTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYWxSdWxlcyhlbmNvZGluZywgc3RhdHMsIG9wdCkge1xuICAvLyBlbmMudGV4dCBpcyBvbmx5IHVzZWQgZm9yIFRFWFQgVEFCTEVcbiAgaWYgKGVuY29kaW5nLnRleHQpIHtcbiAgICByZXR1cm4gZ2VuTWFya1R5cGVzLnNhdGlzZnlSdWxlcyhlbmNvZGluZywgVEVYVCwgc3RhdHMsIG9wdCk7XG4gIH1cblxuICAvLyBDQVJURVNJQU4gUExPVCBPUiBNQVBcbiAgaWYgKGVuY29kaW5nLnggfHwgZW5jb2RpbmcueSB8fCBlbmNvZGluZy5nZW8gfHwgZW5jb2RpbmcuYXJjKSB7XG5cbiAgICBpZiAoZW5jb2Rpbmcucm93IHx8IGVuY29kaW5nLmNvbCkgeyAvL2hhdmUgZmFjZXQocylcblxuICAgICAgLy8gZG9uJ3QgdXNlIGZhY2V0cyBiZWZvcmUgZmlsbGluZyB1cCB4LHlcbiAgICAgIGlmICghZW5jb2RpbmcueCB8fCAhZW5jb2RpbmcueSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAob3B0Lm9taXROb25UZXh0QWdncldpdGhBbGxEaW1zT25GYWNldHMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBhZ2dyZWdhdGVkIGNoYXJ0cyB3aXRoIGFsbCBkaW1zIG9uIGZhY2V0cyAocm93LCBjb2wpXG4gICAgICAgIGlmIChnZW5FbmNvZGluZ3MuaXNBZ2dyV2l0aEFsbERpbU9uRmFjZXRzKGVuY29kaW5nKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmNvZGluZy54ICYmIGVuY29kaW5nLnkpIHtcbiAgICAgIHZhciBpc0RpbVggPSAhIWlzRGltZW5zaW9uKGVuY29kaW5nLngpLFxuICAgICAgICBpc0RpbVkgPSAhIWlzRGltZW5zaW9uKGVuY29kaW5nLnkpO1xuXG4gICAgICBpZiAoaXNEaW1YICYmIGlzRGltWSAmJiAhdmwuZW5jLmlzQWdncmVnYXRlKGVuY29kaW5nKSkge1xuICAgICAgICAvLyBGSVhNRSBhY3R1YWxseSBjaGVjayBpZiB0aGVyZSB3b3VsZCBiZSBvY2NsdXNpb24gIzkwXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdC5vbWl0VHJhbnBvc2UpIHtcbiAgICAgICAgaWYgKGlzRGltWCBeIGlzRGltWSkgeyAvLyBkaW0geCBtZWFcbiAgICAgICAgICBpZiAoIWRpbU1lYVRyYW5zcG9zZVJ1bGUoZW5jb2RpbmcpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcueS50eXBlPT09VCB8fCBlbmNvZGluZy54LnR5cGUgPT09IFQpIHtcbiAgICAgICAgICBpZiAoZW5jb2RpbmcueS50eXBlPT09VCAmJiBlbmNvZGluZy54LnR5cGUgIT09IFQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHsgLy8gc2hvdyBvbmx5IG9uZSBPeE8sIFF4UVxuICAgICAgICAgIGlmIChlbmNvZGluZy54Lm5hbWUgPiBlbmNvZGluZy55Lm5hbWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRE9UIFBMT1RTXG4gICAgLy8gLy8gcGxvdCB3aXRoIG9uZSBheGlzID0gZG90IHBsb3RcbiAgICBpZiAob3B0Lm9taXREb3RQbG90KSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBEb3QgcGxvdCBzaG91bGQgYWx3YXlzIGJlIGhvcml6b250YWxcbiAgICBpZiAob3B0Lm9taXRUcmFucG9zZSAmJiBlbmNvZGluZy55KSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBkb3QgcGxvdCBzaG91bGRuJ3QgaGF2ZSBvdGhlciBlbmNvZGluZ1xuICAgIGlmIChvcHQub21pdERvdFBsb3RXaXRoRXh0cmFFbmNvZGluZyAmJiB2bC5rZXlzKGVuY29kaW5nKS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob3B0Lm9taXRPbmVEaW1lbnNpb25Db3VudCkge1xuICAgICAgLy8gb25lIGRpbWVuc2lvbiBcImNvdW50XCJcbiAgICAgIGlmIChlbmNvZGluZy54ICYmIGVuY29kaW5nLnguYWdncmVnYXRlID09ICdjb3VudCcgJiYgIWVuY29kaW5nLnkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChlbmNvZGluZy55ICYmIGVuY29kaW5nLnkuYWdncmVnYXRlID09ICdjb3VudCcgJiYgIWVuY29kaW5nLngpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmdlbkVuY29kaW5ncy5pc0FnZ3JXaXRoQWxsRGltT25GYWNldHMgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgdmFyIGhhc0FnZ3IgPSBmYWxzZSwgaGFzT3RoZXJPID0gZmFsc2U7XG4gIGZvciAodmFyIGVuY1R5cGUgaW4gZW5jb2RpbmcpIHtcbiAgICB2YXIgZmllbGQgPSBlbmNvZGluZ1tlbmNUeXBlXTtcbiAgICBpZiAoZmllbGQuYWdncmVnYXRlKSB7XG4gICAgICBoYXNBZ2dyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZsLmVuY0RlZi5pc0RpbWVuc2lvbihmaWVsZCkgJiYgKGVuY1R5cGUgIT09IFJPVyAmJiBlbmNUeXBlICE9PSBDT0wpKSB7XG4gICAgICBoYXNPdGhlck8gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGFzQWdnciAmJiBoYXNPdGhlck8pIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGhhc0FnZ3IgJiYgIWhhc090aGVyTztcbn07XG5cblxuZnVuY3Rpb24gZ2VuRW5jb2RpbmdzKGVuY29kaW5ncywgZmllbGREZWZzLCBzdGF0cywgb3B0KSB7XG4gIC8vIGdlbmVyYXRlIGEgY29sbGVjdGlvbiB2ZWdhLWxpdGUncyBlbmNcbiAgdmFyIHRtcEVuY29kaW5nID0ge307XG5cbiAgZnVuY3Rpb24gYXNzaWduRmllbGQoaSkge1xuICAgIC8vIElmIGFsbCBmaWVsZHMgYXJlIGFzc2lnbmVkLCBzYXZlXG4gICAgaWYgKGkgPT09IGZpZWxkRGVmcy5sZW5ndGgpIHtcbiAgICAgIC8vIGF0IHRoZSBtaW5pbWFsIGFsbCBjaGFydCBzaG91bGQgaGF2ZSB4LCB5LCBnZW8sIHRleHQgb3IgYXJjXG4gICAgICBpZiAoZ2VuZXJhbFJ1bGVzKHRtcEVuY29kaW5nLCBzdGF0cywgb3B0KSkge1xuICAgICAgICBlbmNvZGluZ3MucHVzaCh2bC5kdXBsaWNhdGUodG1wRW5jb2RpbmcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGFzc2lnbiBpLXRoIGZpZWxkXG4gICAgdmFyIGZpZWxkRGVmID0gZmllbGREZWZzW2ldO1xuICAgIGZvciAodmFyIGogaW4gb3B0LmVuY29kaW5nVHlwZUxpc3QpIHtcbiAgICAgIHZhciBlbmNUeXBlID0gb3B0LmVuY29kaW5nVHlwZUxpc3Rbal0sXG4gICAgICAgIGlzRGltID0gaXNEaW1lbnNpb24oZmllbGREZWYpO1xuXG4gICAgICAvL1RPRE86IHN1cHBvcnQgXCJtdWx0aXBsZVwiIGFzc2lnbm1lbnRcbiAgICAgIGlmICghKGVuY1R5cGUgaW4gdG1wRW5jb2RpbmcpICYmIC8vIGVuY29kaW5nIG5vdCB1c2VkXG4gICAgICAgICgoaXNEaW0gJiYgcnVsZXNbZW5jVHlwZV0uZGltZW5zaW9uKSB8fCAoIWlzRGltICYmIHJ1bGVzW2VuY1R5cGVdLm1lYXN1cmUpKSAmJlxuICAgICAgICAoIXJ1bGVzW2VuY1R5cGVdLnJ1bGVzIHx8IHJ1bGVzW2VuY1R5cGVdLnJ1bGVzKHRtcEVuY29kaW5nLCBmaWVsZERlZiwgc3RhdHMsIG9wdCkpXG4gICAgICApIHtcbiAgICAgICAgdG1wRW5jb2RpbmdbZW5jVHlwZV0gPSBmaWVsZERlZjtcbiAgICAgICAgYXNzaWduRmllbGQoaSArIDEpO1xuICAgICAgICBkZWxldGUgdG1wRW5jb2RpbmdbZW5jVHlwZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXNzaWduRmllbGQoMCk7XG5cbiAgcmV0dXJuIGVuY29kaW5ncztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8qKlxuICogTW9kdWxlIGZvciBnZW5lcmF0aW5nIHZpc3VhbGl6YXRpb25zXG4gKi9cblxudmFyIGdlbiA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBkYXRhIHZhcmlhdGlvbnNcbiAgYWdncmVnYXRlczogcmVxdWlyZSgnLi9hZ2dyZWdhdGVzJyksXG4gIHByb2plY3Rpb25zOiByZXF1aXJlKCcuL3Byb2plY3Rpb25zJyksXG4gIC8vIGVuY29kaW5ncyAvIHZpc3VhbCB2YXJpYXRpb25zXG4gIHNwZWNzOiByZXF1aXJlKCcuL3NwZWNzJyksXG4gIGVuY29kaW5nczogcmVxdWlyZSgnLi9lbmNvZGluZ3MnKSxcbiAgbWFya3R5cGVzOiByZXF1aXJlKCcuL21hcmt0eXBlcycpXG59O1xuXG5cbi8vIFRPRE8oa2FuaXR3KTogcmV2aXNlIGlmIHRoaXMgaXMgc3RpbGwgd29ya2luZ1xuZ2VuLmNoYXJ0cyA9IGZ1bmN0aW9uKGZpZWxkRGVmcywgb3B0LCBjb25maWcsIGZsYXQpIHtcbiAgb3B0ID0gdXRpbC5nZW4uZ2V0T3B0KG9wdCk7XG4gIGZsYXQgPSBmbGF0ID09PSB1bmRlZmluZWQgPyB7ZW5jb2RpbmdzOiAxfSA6IGZsYXQ7XG5cbiAgLy8gVE9ETyBnZW5lcmF0ZVxuXG4gIC8vIGdlbmVyYXRlIHBlcm11dGF0aW9uIG9mIGVuY29kaW5nIG1hcHBpbmdzXG4gIHZhciBmaWVsZFNldHMgPSBvcHQuZ2VuQWdnciA/IGdlbi5hZ2dyZWdhdGVzKFtdLCBmaWVsZERlZnMsIG9wdCkgOiBbZmllbGREZWZzXSxcbiAgICBlbmNvZGluZ3MsIGNoYXJ0cywgbGV2ZWwgPSAwO1xuXG4gIGlmIChmbGF0ID09PSB0cnVlIHx8IChmbGF0ICYmIGZsYXQuYWdncmVnYXRlKSkge1xuICAgIGVuY29kaW5ncyA9IGZpZWxkU2V0cy5yZWR1Y2UoZnVuY3Rpb24ob3V0cHV0LCBmaWVsZERlZnMpIHtcbiAgICAgIHJldHVybiBnZW4uZW5jcyhvdXRwdXQsIGZpZWxkRGVmcywgb3B0KTtcbiAgICB9LCBbXSk7XG4gIH0gZWxzZSB7XG4gICAgZW5jb2RpbmdzID0gZmllbGRTZXRzLm1hcChmdW5jdGlvbihmaWVsZERlZnMpIHtcbiAgICAgIHJldHVybiBnZW4uZW5jcyhbXSwgZmllbGREZWZzLCBvcHQpO1xuICAgIH0sIHRydWUpO1xuICAgIGxldmVsICs9IDE7XG4gIH1cblxuICBpZiAoZmxhdCA9PT0gdHJ1ZSB8fCAoZmxhdCAmJiBmbGF0LmVuY29kaW5ncykpIHtcbiAgICBjaGFydHMgPSB1dGlsLm5lc3RlZFJlZHVjZShlbmNvZGluZ3MsIGZ1bmN0aW9uKG91dHB1dCwgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiBnZW4ubWFya3R5cGVzKG91dHB1dCwgZW5jb2RpbmcsIG9wdCwgY29uZmlnKTtcbiAgICB9LCBsZXZlbCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnRzID0gdXRpbC5uZXN0ZWRNYXAoZW5jb2RpbmdzLCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgcmV0dXJuIGdlbi5tYXJrdHlwZXMoW10sIGVuY29kaW5nLCBvcHQsIGNvbmZpZyk7XG4gICAgfSwgbGV2ZWwsIHRydWUpO1xuICAgIGxldmVsICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0cztcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2bCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmwnXSA6IG51bGwpLFxuICBpc0RpbWVuc2lvbiA9IHZsLmVuY0RlZi5pc0RpbWVuc2lvbixcbiAgaXNPcmRpbmFsU2NhbGUgPSB2bC5lbmNEZWYuaXNPcmRpbmFsU2NhbGU7XG5cbnZhciB2bG1hcmt0eXBlcyA9IG1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3R5cGVzO1xuXG52YXIgbWFya3NSdWxlID0gdmxtYXJrdHlwZXMucnVsZSA9IHtcbiAgcG9pbnQ6ICBwb2ludFJ1bGUsXG4gIGJhcjogICAgYmFyUnVsZSxcbiAgbGluZTogICBsaW5lUnVsZSxcbiAgYXJlYTogICBhcmVhUnVsZSwgLy8gYXJlYSBpcyBzaW1pbGFyIHRvIGxpbmVcbiAgdGV4dDogICB0ZXh0UnVsZSxcbiAgdGljazogICB0aWNrUnVsZVxufTtcblxuZnVuY3Rpb24gZ2V0TWFya3R5cGVzKGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIHJldHVybiBvcHQubWFya3R5cGVMaXN0LmZpbHRlcihmdW5jdGlvbihtYXJrVHlwZSl7XG4gICAgcmV0dXJuIHZsbWFya3R5cGVzLnNhdGlzZnlSdWxlcyhlbmNvZGluZywgbWFya1R5cGUsIHN0YXRzLCBvcHQpO1xuICB9KTtcbn1cblxudmxtYXJrdHlwZXMuc2F0aXNmeVJ1bGVzID0gZnVuY3Rpb24gKGVuY29kaW5nLCBtYXJrVHlwZSwgc3RhdHMsIG9wdCkge1xuICB2YXIgbWFyayA9IHZsLmNvbXBpbGVyLm1hcmtzW21hcmtUeXBlXSxcbiAgICByZXFzID0gbWFyay5yZXF1aXJlZEVuY29kaW5nLFxuICAgIHN1cHBvcnQgPSBtYXJrLnN1cHBvcnRlZEVuY29kaW5nO1xuXG4gIGZvciAodmFyIGkgaW4gcmVxcykgeyAvLyBhbGwgcmVxdWlyZWQgZW5jb2RpbmdzIGluIGVuY1xuICAgIGlmICghKHJlcXNbaV0gaW4gZW5jb2RpbmcpKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBlbmNUeXBlIGluIGVuY29kaW5nKSB7IC8vIGFsbCBlbmNvZGluZ3MgaW4gZW5jIGFyZSBzdXBwb3J0ZWRcbiAgICBpZiAoIXN1cHBvcnRbZW5jVHlwZV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhbWFya3NSdWxlW21hcmtUeXBlXSB8fCBtYXJrc1J1bGVbbWFya1R5cGVdKGVuY29kaW5nLCBzdGF0cywgb3B0KTtcbn07XG5cbmZ1bmN0aW9uIGZhY2V0UnVsZShmaWVsZERlZiwgc3RhdHMsIG9wdCkge1xuICByZXR1cm4gdmwuZW5jRGVmLmNhcmRpbmFsaXR5KGZpZWxkRGVmLCBzdGF0cykgPD0gb3B0Lm1heENhcmRpbmFsaXR5Rm9yRmFjZXRzO1xufVxuXG5mdW5jdGlvbiBmYWNldHNSdWxlKGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIGlmKGVuY29kaW5nLnJvdyAmJiAhZmFjZXRSdWxlKGVuY29kaW5nLnJvdywgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcbiAgaWYoZW5jb2RpbmcuY29sICYmICFmYWNldFJ1bGUoZW5jb2RpbmcuY29sLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcG9pbnRSdWxlKGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIGlmKCFmYWNldHNSdWxlKGVuY29kaW5nLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZW5jb2RpbmcueCAmJiBlbmNvZGluZy55KSB7XG4gICAgLy8gaGF2ZSBib3RoIHggJiB5ID09PiBzY2F0dGVyIHBsb3QgLyBidWJibGUgcGxvdFxuXG4gICAgdmFyIHhJc0RpbSA9IGlzRGltZW5zaW9uKGVuY29kaW5nLngpLFxuICAgICAgeUlzRGltID0gaXNEaW1lbnNpb24oZW5jb2RpbmcueSk7XG5cbiAgICAvLyBGb3IgT3hPXG4gICAgaWYgKHhJc0RpbSAmJiB5SXNEaW0pIHtcbiAgICAgIC8vIHNoYXBlIGRvZXNuJ3Qgd29yayB3aXRoIGJvdGggeCwgeSBhcyBvcmRpbmFsXG4gICAgICBpZiAoZW5jb2Rpbmcuc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPKGthbml0dyk6IGNoZWNrIHRoYXQgdGhlcmUgaXMgcXVhbnQgYXQgbGVhc3QgLi4uXG4gICAgICBpZiAoZW5jb2RpbmcuY29sb3IgJiYgaXNEaW1lbnNpb24oZW5jb2RpbmcuY29sb3IpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIHsgLy8gcGxvdCB3aXRoIG9uZSBheGlzID0gZG90IHBsb3RcbiAgICBpZiAob3B0Lm9taXREb3RQbG90KSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBEb3QgcGxvdCBzaG91bGQgYWx3YXlzIGJlIGhvcml6b250YWxcbiAgICBpZiAob3B0Lm9taXRUcmFucG9zZSAmJiBlbmNvZGluZy55KSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBkb3QgcGxvdCBzaG91bGRuJ3QgaGF2ZSBvdGhlciBlbmNvZGluZ1xuICAgIGlmIChvcHQub21pdERvdFBsb3RXaXRoRXh0cmFFbmNvZGluZyAmJiB2bC5rZXlzKGVuY29kaW5nKS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBkb3QgcGxvdCB3aXRoIHNoYXBlIGlzIG5vbi1zZW5zZVxuICAgIGlmIChlbmNvZGluZy5zaGFwZSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB0aWNrUnVsZShlbmNvZGluZywgc3RhdHMsIG9wdCkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIGlmIChlbmNvZGluZy54IHx8IGVuY29kaW5nLnkpIHtcbiAgICBpZih2bC5lbmMuaXNBZ2dyZWdhdGUoZW5jb2RpbmcpKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgeElzRGltID0gaXNEaW1lbnNpb24oZW5jb2RpbmcueCksXG4gICAgICB5SXNEaW0gPSBpc0RpbWVuc2lvbihlbmNvZGluZy55KTtcblxuICAgIHJldHVybiAoIXhJc0RpbSAmJiAoIWVuY29kaW5nLnkgfHwgaXNPcmRpbmFsU2NhbGUoZW5jb2RpbmcueSkpKSB8fFxuICAgICAgKCF5SXNEaW0gJiYgKCFlbmNvZGluZy54IHx8IGlzT3JkaW5hbFNjYWxlKGVuY29kaW5nLngpKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBiYXJSdWxlKGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIGlmKCFmYWNldHNSdWxlKGVuY29kaW5nLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGJhciByZXF1aXJlcyBhdCBsZWFzdCB4IG9yIHlcbiAgaWYgKCFlbmNvZGluZy54ICYmICFlbmNvZGluZy55KSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKG9wdC5vbWl0U2l6ZU9uQmFyICYmIGVuY29kaW5nLnNpemUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIEZJWE1FIGFjdHVhbGx5IGNoZWNrIGlmIHRoZXJlIHdvdWxkIGJlIG9jY2x1c2lvbiAjOTBcbiAgLy8gbmVlZCB0byBhZ2dyZWdhdGUgb24gZWl0aGVyIHggb3IgeVxuICB2YXIgYWdnRWl0aGVyWG9yWSA9XG4gICAgKCFlbmNvZGluZy54IHx8IGVuY29kaW5nLnguYWdncmVnYXRlID09PSB1bmRlZmluZWQpIF5cbiAgICAoIWVuY29kaW5nLnkgfHwgZW5jb2RpbmcueS5hZ2dyZWdhdGUgPT09IHVuZGVmaW5lZCk7XG5cblxuICBpZiAoYWdnRWl0aGVyWG9yWSkge1xuICAgIHZhciBlaXRoZXJYb3JZaXNEaW1Pck51bGwgPVxuICAgICAgKCFlbmNvZGluZy54IHx8IGlzRGltZW5zaW9uKGVuY29kaW5nLngpKSBeXG4gICAgICAoIWVuY29kaW5nLnkgfHwgaXNEaW1lbnNpb24oZW5jb2RpbmcueSkpO1xuXG4gICAgaWYgKGVpdGhlclhvcllpc0RpbU9yTnVsbCkge1xuICAgICAgdmFyIGFnZ3JlZ2F0ZSA9IGVuY29kaW5nLnguYWdncmVnYXRlIHx8IGVuY29kaW5nLnkuYWdncmVnYXRlO1xuICAgICAgcmV0dXJuICEob3B0Lm9taXRTdGFja2VkQXZlcmFnZSAmJiBhZ2dyZWdhdGUgPT09J21lYW4nICYmIGVuY29kaW5nLmNvbG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpbmVSdWxlKGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIGlmKCFmYWNldHNSdWxlKGVuY29kaW5nLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFRPRE8oa2FuaXR3KTogYWRkIG9taXRWZXJ0aWNhbExpbmUgYXMgY29uZmlnXG5cbiAgLy8gRklYTUUgdHJ1bHkgb3JkaW5hbCBkYXRhIGlzIGZpbmUgaGVyZSB0b28uXG4gIC8vIExpbmUgY2hhcnQgc2hvdWxkIGJlIG9ubHkgaG9yaXpvbnRhbFxuICAvLyBhbmQgdXNlIG9ubHkgdGVtcG9yYWwgZGF0YVxuICByZXR1cm4gZW5jb2RpbmcueC50eXBlID09ICdUJyAmJiBlbmNvZGluZy54LnRpbWVVbml0ICYmIGVuY29kaW5nLnkudHlwZSA9PSAnUScgJiYgZW5jb2RpbmcueS5hZ2dyZWdhdGU7XG59XG5cbmZ1bmN0aW9uIGFyZWFSdWxlKGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIGlmKCFmYWNldHNSdWxlKGVuY29kaW5nLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmKCFsaW5lUnVsZShlbmNvZGluZywgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gIShvcHQub21pdFN0YWNrZWRBdmVyYWdlICYmIGVuY29kaW5nLnkuYWdncmVnYXRlID09PSdtZWFuJyAmJiBlbmNvZGluZy5jb2xvcik7XG59XG5cbmZ1bmN0aW9uIHRleHRSdWxlKGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIC8vIGF0IGxlYXN0IG11c3QgaGF2ZSByb3cgb3IgY29sIGFuZCBhZ2dyZWdhdGVkIHRleHQgdmFsdWVzXG4gIHJldHVybiAoZW5jb2Rpbmcucm93IHx8IGVuY29kaW5nLmNvbCkgJiYgZW5jb2RpbmcudGV4dCAmJiBlbmNvZGluZy50ZXh0LmFnZ3JlZ2F0ZSAmJiAhZW5jb2RpbmcueCAmJiAhZW5jb2RpbmcueSAmJiAhZW5jb2Rpbmcuc2l6ZSAmJlxuICAgICghb3B0LmFsd2F5c0dlbmVyYXRlVGFibGVBc0hlYXRtYXAgfHwgIWVuY29kaW5nLmNvbG9yKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIGNvbnN0cyA9IHJlcXVpcmUoJy4uL2NvbnN0cycpLFxuICB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2bCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmwnXSA6IG51bGwpLFxuICBpc0RpbWVuc2lvbiA9IHZsLmVuY0RlZi5pc0RpbWVuc2lvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBwcm9qZWN0aW9ucztcblxuLy8gVE9ETyBzdXBwb3J0IG90aGVyIG1vZGUgb2YgcHJvamVjdGlvbnMgZ2VuZXJhdGlvblxuLy8gcG93ZXJzZXQsIGNob29zZUssIGNob29zZUtvckxlc3MgYXJlIGFscmVhZHkgaW5jbHVkZWQgaW4gdGhlIHV0aWxcblxuLyoqXG4gKiBmaWVsZHNcbiAqIEBwYXJhbSAge1t0eXBlXX0gZmllbGREZWZzIGFycmF5IG9mIGZpZWxkcyBhbmQgcXVlcnkgaW5mb3JtYXRpb25cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gcHJvamVjdGlvbnMoZmllbGREZWZzLCBzdGF0cywgb3B0KSB7XG4gIG9wdCA9IHZsLnNjaGVtYS51dGlsLmV4dGVuZChvcHR8fHt9LCBjb25zdHMuZ2VuLnByb2plY3Rpb25zKTtcblxuICAvLyBGaXJzdCBjYXRlZ29yaXplIGZpZWxkLCBzZWxlY3RlZCwgZmllbGRzVG9BZGQsIGFuZCBzYXZlIGluZGljZXNcbiAgdmFyIHNlbGVjdGVkID0gW10sIGZpZWxkc1RvQWRkID0gW10sIGZpZWxkU2V0cyA9IFtdLFxuICAgIGhhc1NlbGVjdGVkRGltZW5zaW9uID0gZmFsc2UsXG4gICAgaGFzU2VsZWN0ZWRNZWFzdXJlID0gZmFsc2UsXG4gICAgaW5kaWNlcyA9IHt9O1xuXG4gIGZpZWxkRGVmcy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkRGVmLCBpbmRleCl7XG4gICAgLy9zYXZlIGluZGljZXMgZm9yIHN0YWJsZSBzb3J0IGxhdGVyXG4gICAgaW5kaWNlc1tmaWVsZERlZi5uYW1lXSA9IGluZGV4O1xuXG4gICAgaWYgKGZpZWxkRGVmLnNlbGVjdGVkKSB7XG4gICAgICBzZWxlY3RlZC5wdXNoKGZpZWxkRGVmKTtcbiAgICAgIGlmIChpc0RpbWVuc2lvbihmaWVsZERlZikgfHwgZmllbGREZWYudHlwZSA9PT0nVCcpIHsgLy8gRklYTUUgLyBIQUNLXG4gICAgICAgIGhhc1NlbGVjdGVkRGltZW5zaW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1NlbGVjdGVkTWVhc3VyZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWVsZERlZi5zZWxlY3RlZCAhPT0gZmFsc2UgJiYgIXZsLmVuY0RlZi5pc0NvdW50KGZpZWxkRGVmKSkge1xuICAgICAgaWYgKHZsLmVuY0RlZi5pc0RpbWVuc2lvbihmaWVsZERlZikgJiZcbiAgICAgICAgICAhb3B0Lm1heENhcmRpbmFsaXR5Rm9yQXV0b0FkZE9yZGluYWwgJiZcbiAgICAgICAgICB2bC5lbmNEZWYuY2FyZGluYWxpdHkoZmllbGREZWYsIHN0YXRzLCAxNSkgPiBvcHQubWF4Q2FyZGluYWxpdHlGb3JBdXRvQWRkT3JkaW5hbFxuICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmllbGRzVG9BZGQucHVzaChmaWVsZERlZik7XG4gICAgfVxuICB9KTtcblxuICBmaWVsZHNUb0FkZC5zb3J0KGNvbXBhcmVGaWVsZHNUb0FkZChoYXNTZWxlY3RlZERpbWVuc2lvbiwgaGFzU2VsZWN0ZWRNZWFzdXJlLCBpbmRpY2VzKSk7XG5cbiAgdmFyIHNldHNUb0FkZCA9IHV0aWwuY2hvb3NlS29yTGVzcyhmaWVsZHNUb0FkZCwgMSk7XG5cbiAgc2V0c1RvQWRkLmZvckVhY2goZnVuY3Rpb24oc2V0VG9BZGQpIHtcbiAgICB2YXIgZmllbGRTZXQgPSBzZWxlY3RlZC5jb25jYXQoc2V0VG9BZGQpO1xuICAgIGlmIChmaWVsZFNldC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAob3B0Lm9taXREb3RQbG90ICYmIGZpZWxkU2V0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuO1xuICAgICAgZmllbGRTZXRzLnB1c2goZmllbGRTZXQpO1xuICAgIH1cbiAgfSk7XG5cbiAgZmllbGRTZXRzLmZvckVhY2goZnVuY3Rpb24oZmllbGRTZXQpIHtcbiAgICAgIC8vIGFsd2F5cyBhcHBlbmQgcHJvamVjdGlvbidzIGtleSB0byBlYWNoIHByb2plY3Rpb24gcmV0dXJuZWQsIGQzIHN0eWxlLlxuICAgIGZpZWxkU2V0LmtleSA9IHByb2plY3Rpb25zLmtleShmaWVsZFNldCk7XG4gIH0pO1xuXG4gIHJldHVybiBmaWVsZFNldHM7XG59XG5cbnZhciB0eXBlSXNNZWFzdXJlU2NvcmUgPSB7XG4gIE46IDAsXG4gIE86IDAsXG4gIFQ6IDIsXG4gIFE6IDNcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVGaWVsZHNUb0FkZChoYXNTZWxlY3RlZERpbWVuc2lvbiwgaGFzU2VsZWN0ZWRNZWFzdXJlLCBpbmRpY2VzKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAvLyBzb3J0IGJ5IHR5cGUgb2YgdGhlIGRhdGFcbiAgICBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICAgIGlmICghaGFzU2VsZWN0ZWREaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVJc01lYXN1cmVTY29yZVthLnR5cGVdIC0gdHlwZUlzTWVhc3VyZVNjb3JlW2IudHlwZV07XG4gICAgICB9IGVsc2UgeyAvL2lmICghaGFzU2VsZWN0ZWRNZWFzdXJlKSB7XG4gICAgICAgIHJldHVybiB0eXBlSXNNZWFzdXJlU2NvcmVbYi50eXBlXSAtIHR5cGVJc01lYXN1cmVTY29yZVthLnR5cGVdO1xuICAgICAgfVxuICAgIH1cbiAgICAvL21ha2UgdGhlIHNvcnQgc3RhYmxlXG4gICAgcmV0dXJuIGluZGljZXNbYS5uYW1lXSAtIGluZGljZXNbYi5uYW1lXTtcbiAgfTtcbn1cblxucHJvamVjdGlvbnMua2V5ID0gZnVuY3Rpb24ocHJvamVjdGlvbikge1xuICByZXR1cm4gcHJvamVjdGlvbi5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICByZXR1cm4gdmwuZW5jRGVmLmlzQ291bnQoZmllbGQpID8gJ2NvdW50JyA6IGZpZWxkLm5hbWU7XG4gIH0pLmpvaW4oJywnKTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3ZsJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2bCddIDogbnVsbCksXG4gIGdlbkVuY29kaW5ncyA9IHJlcXVpcmUoJy4vZW5jb2RpbmdzJyksXG4gIGdldE1hcmt0eXBlcyA9IHJlcXVpcmUoJy4vbWFya3R5cGVzJyksXG4gIHJhbmsgPSByZXF1aXJlKCcuLi9yYW5rL3JhbmsnKSxcbiAgY29uc3RzID0gcmVxdWlyZSgnLi4vY29uc3RzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuU3BlY3NGcm9tRmllbGREZWZzO1xuXG4vKiogRGVzaWduIEVuY29kaW5ncyBmb3IgYSBzZXQgb2YgZmllbGQgZGVmaW5pdGlvbiAqL1xuXG5mdW5jdGlvbiBnZW5TcGVjc0Zyb21GaWVsZERlZnMob3V0cHV0LCBmaWVsZERlZnMsIHN0YXRzLCBvcHQsIG5lc3RlZCkge1xuICAvLyBvcHQgbXVzdCBiZSBhdWdtZW50ZWQgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byBnZW5FbmNvZGluZ3Mgb3IgZ2V0TWFya3R5cGVzXG4gIG9wdCA9IHZsLnNjaGVtYS51dGlsLmV4dGVuZChvcHR8fHt9LCBjb25zdHMuZ2VuLmVuY29kaW5ncyk7XG4gIHZhciBlbmNvZGluZ3MgPSBnZW5FbmNvZGluZ3MoW10sIGZpZWxkRGVmcywgc3RhdHMsIG9wdCk7XG5cbiAgaWYgKG5lc3RlZCkge1xuICAgIHJldHVybiBlbmNvZGluZ3MucmVkdWNlKGZ1bmN0aW9uKGRpY3QsIGVuY29kaW5nKSB7XG4gICAgICBkaWN0W2VuY29kaW5nXSA9IGdlblNwZWNzRnJvbUVuY29kaW5ncyhbXSwgZW5jb2RpbmcsIHN0YXRzLCBvcHQpO1xuICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgfSwge30pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbmNvZGluZ3MucmVkdWNlKGZ1bmN0aW9uKGxpc3QsIGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gZ2VuU3BlY3NGcm9tRW5jb2RpbmdzKGxpc3QsIGVuY29kaW5nLCBzdGF0cywgb3B0KTtcbiAgICB9LCBbXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU3BlY3NGcm9tRW5jb2RpbmdzKG91dHB1dCwgZW5jb2RpbmcsIHN0YXRzLCBvcHQpIHtcbiAgZ2V0TWFya3R5cGVzKGVuY29kaW5nLCBzdGF0cywgb3B0KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG1hcmtUeXBlKSB7XG4gICAgICB2YXIgc3BlYyA9IHZsLmR1cGxpY2F0ZSh7XG4gICAgICAgICAgLy8gQ2xvbmUgY29uZmlnICYgZW5jb2RpbmcgdG8gdW5pcXVlIG9iamVjdHNcbiAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICAgICAgY29uZmlnOiBvcHQuY29uZmlnXG4gICAgICAgIH0pO1xuXG4gICAgICBzcGVjLm1hcmt0eXBlID0gbWFya1R5cGU7XG4gICAgICAvLyBEYXRhIG9iamVjdCBpcyB0aGUgc2FtZSBhY3Jvc3MgY2hhcnRzOiBwYXNzIGJ5IHJlZmVyZW5jZVxuICAgICAgc3BlYy5kYXRhID0gb3B0LmRhdGE7XG5cbiAgICAgIHNwZWMgPSBmaW5hbFRvdWNoKHNwZWMsIHN0YXRzLCBvcHQpO1xuICAgICAgdmFyIHNjb3JlID0gcmFuay5lbmNvZGluZyhzcGVjLCBzdGF0cywgb3B0KTtcblxuICAgICAgc3BlYy5faW5mbyA9IHNjb3JlO1xuICAgICAgb3V0cHV0LnB1c2goc3BlYyk7XG4gICAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vRklYTUUgdGhpcyBzaG91bGQgYmUgcmVmYWN0b3JzXG5mdW5jdGlvbiBmaW5hbFRvdWNoKHNwZWMsIHN0YXRzLCBvcHQpIHtcbiAgaWYgKHNwZWMubWFya3R5cGUgPT09ICd0ZXh0JyAmJiBvcHQuYWx3YXlzR2VuZXJhdGVUYWJsZUFzSGVhdG1hcCkge1xuICAgIHNwZWMuZW5jb2RpbmcuY29sb3IgPSBzcGVjLmVuY29kaW5nLnRleHQ7XG4gIH1cblxuICAvLyBkb24ndCBpbmNsdWRlIHplcm8gaWYgc3RkZXYvbWVhbiA8IDAuMDFcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3V3ZGF0YS92aXNyZWMvaXNzdWVzLzY5XG4gIHZhciBlbmNvZGluZyA9IHNwZWMuZW5jb2Rpbmc7XG4gIFsneCcsICd5J10uZm9yRWFjaChmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgdmFyIGZpZWxkID0gZW5jb2RpbmdbZW5jVHlwZV07XG4gICAgaWYgKGZpZWxkICYmIHZsLmVuY0RlZi5pc01lYXN1cmUoZmllbGQpICYmICF2bC5lbmNEZWYuaXNDb3VudChmaWVsZCkpIHtcbiAgICAgIHZhciBzdGF0ID0gc3RhdHNbZmllbGQubmFtZV07XG4gICAgICBpZiAoc3RhdCAmJiBzdGF0LnN0ZGV2IC8gc3RhdC5tZWFuIDwgMC4wMSkge1xuICAgICAgICBmaWVsZC5zY2FsZSA9IHt6ZXJvOiBmYWxzZX07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNwZWM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnID0gZ2xvYmFsIHx8IHdpbmRvdztcblxucmVxdWlyZSgndmVnYS1saXRlL3NyYy9nbG9iYWxzJyk7XG5cbmcuQ0hBUlRfVFlQRVMgPSB7XG4gIFRBQkxFOiAnVEFCTEUnLFxuICBCQVI6ICdCQVInLFxuICBQTE9UOiAnUExPVCcsXG4gIExJTkU6ICdMSU5FJyxcbiAgQVJFQTogJ0FSRUEnLFxuICBNQVA6ICdNQVAnLFxuICBISVNUT0dSQU06ICdISVNUT0dSQU0nXG59O1xuXG5nLkFOWV9EQVRBX1RZUEVTID0gKDEgPDwgNCkgLSAxOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGluZzogcmVxdWlyZSgnLi9yYW5rRW5jb2RpbmdzJylcbn07XG5cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2bCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmwnXSA6IG51bGwpLFxuICBpc0RpbWVuc2lvbiA9IHZsLmVuY0RlZi5pc0RpbWVuc2lvbjtcblxubW9kdWxlLmV4cG9ydHMgPSByYW5rRW5jb2RpbmdzO1xuXG4vLyBiYWQgc2NvcmUgbm90IHNwZWNpZmllZCBpbiB0aGUgdGFibGUgYWJvdmVcbnZhciBVTlVTRURfUE9TSVRJT04gPSAwLjU7XG5cbnZhciBNQVJLX1NDT1JFID0ge1xuICBsaW5lOiAwLjk5LFxuICBhcmVhOiAwLjk4LFxuICBiYXI6IDAuOTcsXG4gIHRpY2s6IDAuOTYsXG4gIHBvaW50OiAwLjk1LFxuICBjaXJjbGU6IDAuOTQsXG4gIHNxdWFyZTogMC45NCxcbiAgdGV4dDogMC44XG59O1xuXG5mdW5jdGlvbiByYW5rRW5jb2RpbmdzKHNwZWMsIHN0YXRzLCBvcHQsIHNlbGVjdGVkKSB7XG4gIHZhciBmZWF0dXJlcyA9IFtdLFxuICAgIGVuY1R5cGVzID0gdmwua2V5cyhzcGVjLmVuY29kaW5nKSxcbiAgICBtYXJrdHlwZSA9IHNwZWMubWFya3R5cGUsXG4gICAgZW5jb2RpbmcgPSBzcGVjLmVuY29kaW5nO1xuXG4gIHZhciBlbmNvZGluZ01hcHBpbmdCeUZpZWxkID0gdmwuZW5jLnJlZHVjZShzcGVjLmVuY29kaW5nLCBmdW5jdGlvbihvLCBmaWVsZERlZiwgZW5jVHlwZSkge1xuICAgIHZhciBrZXkgPSB2bC5lbmNEZWYuc2hvcnRoYW5kKGZpZWxkRGVmKTtcbiAgICB2YXIgbWFwcGluZ3MgPSBvW2tleV0gPSBvW2tleV0gfHwgW107XG4gICAgbWFwcGluZ3MucHVzaCh7ZW5jVHlwZTogZW5jVHlwZSwgZmllbGQ6IGZpZWxkRGVmfSk7XG4gICAgcmV0dXJuIG87XG4gIH0sIHt9KTtcblxuICAvLyBkYXRhIC0gZW5jb2RpbmcgbWFwcGluZyBzY29yZVxuICB2bC5mb3JFYWNoKGVuY29kaW5nTWFwcGluZ0J5RmllbGQsIGZ1bmN0aW9uKG1hcHBpbmdzKSB7XG4gICAgdmFyIHJlYXNvbnMgPSBtYXBwaW5ncy5tYXAoZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gbS5lbmNUeXBlICsgdmwuc2hvcnRoYW5kLmFzc2lnbiArIHZsLmVuY0RlZi5zaG9ydGhhbmQobS5maWVsZCkgK1xuICAgICAgICAgICcgJyArIChzZWxlY3RlZCAmJiBzZWxlY3RlZFttLmZpZWxkLm5hbWVdID8gJ1t4XScgOiAnWyBdJyk7XG4gICAgICB9KSxcbiAgICAgIHNjb3JlcyA9IG1hcHBpbmdzLm1hcChmdW5jdGlvbihtKSB7XG4gICAgICAgIHZhciByb2xlID0gdmwuZW5jRGVmLmlzRGltZW5zaW9uKG0uZmllbGQpID8gJ2RpbWVuc2lvbicgOiAnbWVhc3VyZSc7XG5cbiAgICAgICAgdmFyIHNjb3JlID0gcmFua0VuY29kaW5ncy5zY29yZVtyb2xlXShtLmZpZWxkLCBtLmVuY1R5cGUsIHNwZWMubWFya3R5cGUsIHN0YXRzLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiAhc2VsZWN0ZWQgfHwgc2VsZWN0ZWRbbS5maWVsZC5uYW1lXSA/IHNjb3JlIDogTWF0aC5wb3coc2NvcmUsIDAuMTI1KTtcbiAgICAgIH0pO1xuXG4gICAgZmVhdHVyZXMucHVzaCh7XG4gICAgICByZWFzb246IHJlYXNvbnMuam9pbihcIiB8IFwiKSxcbiAgICAgIHNjb3JlOiBNYXRoLm1heC5hcHBseShudWxsLCBzY29yZXMpXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHBsb3QgdHlwZVxuICBpZiAobWFya3R5cGUgPT09IFRFWFQpIHtcbiAgICAvLyBUT0RPXG4gIH0gZWxzZSB7XG4gICAgaWYgKGVuY29kaW5nLnggJiYgZW5jb2RpbmcueSkge1xuICAgICAgaWYgKGlzRGltZW5zaW9uKGVuY29kaW5nLngpIF4gaXNEaW1lbnNpb24oZW5jb2RpbmcueSkpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgcmVhc29uOiAnT3hRIHBsb3QnLFxuICAgICAgICAgIHNjb3JlOiAwLjhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcGVuYWxpemUgbm90IHVzaW5nIHBvc2l0aW9uYWwgb25seSBwZW5hbGl6ZSBmb3Igbm9uLXRleHRcbiAgaWYgKGVuY1R5cGVzLmxlbmd0aCA+IDEgJiYgbWFya3R5cGUgIT09IFRFWFQpIHtcbiAgICBpZiAoKCFlbmNvZGluZy54IHx8ICFlbmNvZGluZy55KSAmJiAhZW5jb2RpbmcuZ2VvICYmICFlbmNvZGluZy50ZXh0KSB7XG4gICAgICBmZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgcmVhc29uOiAndW51c2VkIHBvc2l0aW9uJyxcbiAgICAgICAgc2NvcmU6IFVOVVNFRF9QT1NJVElPTlxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gbWFyayB0eXBlIHNjb3JlXG4gIGZlYXR1cmVzLnB1c2goe1xuICAgIHJlYXNvbjogJ21hcmt0eXBlPScrbWFya3R5cGUsXG4gICAgc2NvcmU6IE1BUktfU0NPUkVbbWFya3R5cGVdXG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgc2NvcmU6IGZlYXR1cmVzLnJlZHVjZShmdW5jdGlvbihwLCBmKSB7XG4gICAgICByZXR1cm4gcCAqIGYuc2NvcmU7XG4gICAgfSwgMSksXG4gICAgZmVhdHVyZXM6IGZlYXR1cmVzXG4gIH07XG59XG5cblxudmFyIEQgPSB7fSwgTSA9IHt9LCBCQUQgPSAwLjEsIFRFUlJJQkxFID0gMC4wMTtcblxuRC5taW5vciA9IDAuMDE7XG5ELnBvcyA9IDE7XG5ELllfVCA9IDAuODtcbkQuZmFjZXRfdGV4dCA9IDE7XG5ELmZhY2V0X2dvb2QgPSAwLjY3NTsgLy8gPCBjb2xvcl9vaywgPiBjb2xvcl9iYWRcbkQuZmFjZXRfb2sgPSAwLjU1O1xuRC5mYWNldF9iYWQgPSAwLjQ7XG5ELmNvbG9yX2dvb2QgPSAwLjc7XG5ELmNvbG9yX29rID0gMC42NTsgLy8gPiBNLlNpemVcbkQuY29sb3JfYmFkID0gMC4zO1xuRC5jb2xvcl9zdGFjayA9IDAuNjtcbkQuc2hhcGUgPSAwLjY7XG5ELmRldGFpbCA9IDAuNTtcbkQuYmFkID0gQkFEO1xuRC50ZXJyaWJsZSA9IFRFUlJJQkxFO1xuXG5NLnBvcyA9IDE7XG5NLnNpemUgPSAwLjY7XG5NLmNvbG9yID0gMC41O1xuTS50ZXh0ID0gMC40O1xuTS5iYWQgPSBCQUQ7XG5NLnRlcnJpYmxlID0gVEVSUklCTEU7XG5cbnJhbmtFbmNvZGluZ3MuZGltZW5zaW9uU2NvcmUgPSBmdW5jdGlvbiAoZmllbGREZWYsIGVuY1R5cGUsIG1hcmt0eXBlLCBzdGF0cywgb3B0KXtcbiAgdmFyIGNhcmRpbmFsaXR5ID0gdmwuZW5jRGVmLmNhcmRpbmFsaXR5KGZpZWxkRGVmLCBzdGF0cyk7XG4gIHN3aXRjaCAoZW5jVHlwZSkge1xuICAgIGNhc2UgWDpcbiAgICAgIGlmICh2bC5lbmNEZWYuaXNUeXBlcyhmaWVsZERlZiwgW04sIE9dKSkgIHJldHVybiBELnBvcyAtIEQubWlub3I7XG4gICAgICByZXR1cm4gRC5wb3M7XG5cbiAgICBjYXNlIFk6XG4gICAgICBpZiAodmwuZW5jRGVmLmlzVHlwZXMoZmllbGREZWYsIFtOLCBPXSkpIHJldHVybiBELnBvcyAtIEQubWlub3I7IC8vcHJlZmVyIG9yZGluYWwgb24geVxuICAgICAgaWYgKGZpZWxkRGVmLnR5cGUgPT09IFQpIHJldHVybiBELllfVDsgLy8gdGltZSBzaG91bGQgbm90IGJlIG9uIFlcbiAgICAgIHJldHVybiBELnBvcyAtIEQubWlub3I7XG5cbiAgICBjYXNlIENPTDpcbiAgICAgIGlmIChtYXJrdHlwZSA9PT0gVEVYVCkgcmV0dXJuIEQuZmFjZXRfdGV4dDtcbiAgICAgIC8vcHJlZmVyIGNvbHVtbiBvdmVyIHJvdyBkdWUgdG8gc2Nyb2xsaW5nIGlzc3Vlc1xuICAgICAgcmV0dXJuIGNhcmRpbmFsaXR5IDw9IG9wdC5tYXhHb29kQ2FyZGluYWxpdHlGb3JGYWNldHMgPyBELmZhY2V0X2dvb2QgOlxuICAgICAgICBjYXJkaW5hbGl0eSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JGYWNldHMgPyBELmZhY2V0X29rIDogRC5mYWNldF9iYWQ7XG5cbiAgICBjYXNlIFJPVzpcbiAgICAgIGlmIChtYXJrdHlwZSA9PT0gVEVYVCkgcmV0dXJuIEQuZmFjZXRfdGV4dDtcbiAgICAgIHJldHVybiAoY2FyZGluYWxpdHkgPD0gb3B0Lm1heEdvb2RDYXJkaW5hbGl0eUZvckZhY2V0cyA/IEQuZmFjZXRfZ29vZCA6XG4gICAgICAgIGNhcmRpbmFsaXR5IDw9IG9wdC5tYXhDYXJkaW5hbGl0eUZvckZhY2V0cyA/IEQuZmFjZXRfb2sgOiBELmZhY2V0X2JhZCkgLSBELm1pbm9yO1xuXG4gICAgY2FzZSBDT0xPUjpcbiAgICAgIHZhciBoYXNPcmRlciA9IChmaWVsZERlZi5iaW4gJiYgZmllbGREZWYudHlwZT09PVEpIHx8IChmaWVsZERlZi50aW1lVW5pdCAmJiBmaWVsZERlZi50eXBlPT09VCk7XG5cbiAgICAgIC8vRklYTUUgYWRkIHN0YWNraW5nIG9wdGlvbiBvbmNlIHdlIGhhdmUgY29udHJvbCAuLlxuICAgICAgdmFyIGlzU3RhY2tlZCA9IG1hcmt0eXBlID09PSAnYmFyJyB8fCBtYXJrdHlwZSA9PT0gJ2FyZWEnO1xuXG4gICAgICAvLyB0cnVlIG9yZGluYWwgb24gY29sb3IgaXMgY3VycmVudGx5IEJBRCAodW50aWwgd2UgaGF2ZSBnb29kIG9yZGluYWwgY29sb3Igc2NhbGUgc3VwcG9ydClcbiAgICAgIGlmIChoYXNPcmRlcikgcmV0dXJuIEQuY29sb3JfYmFkO1xuXG4gICAgICAvL3N0YWNraW5nIGdldHMgbG93ZXIgc2NvcmVcbiAgICAgIGlmIChpc1N0YWNrZWQpIHJldHVybiBELmNvbG9yX3N0YWNrO1xuXG4gICAgICByZXR1cm4gY2FyZGluYWxpdHkgPD0gb3B0Lm1heEdvb2RDYXJkaW5hbGl0eUZvckNvbG9yID8gRC5jb2xvcl9nb29kOiBjYXJkaW5hbGl0eSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JDb2xvciA/IEQuY29sb3Jfb2sgOiBELmNvbG9yX2JhZDtcbiAgICBjYXNlIFNIQVBFOlxuICAgICAgcmV0dXJuIGNhcmRpbmFsaXR5IDw9IG9wdC5tYXhDYXJkaW5hbGl0eUZvclNoYXBlID8gRC5zaGFwZSA6IFRFUlJJQkxFO1xuICAgIGNhc2UgREVUQUlMOlxuICAgICAgcmV0dXJuIEQuZGV0YWlsO1xuICB9XG4gIHJldHVybiBURVJSSUJMRTtcbn07XG5cbnJhbmtFbmNvZGluZ3MuZGltZW5zaW9uU2NvcmUuY29uc3RzID0gRDtcblxucmFua0VuY29kaW5ncy5tZWFzdXJlU2NvcmUgPSBmdW5jdGlvbiAoZmllbGREZWYsIGVuY1R5cGUsIG1hcmt0eXBlLCBzdGF0cywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgc3dpdGNoIChlbmNUeXBlKXtcbiAgICBjYXNlIFg6IHJldHVybiBNLnBvcztcbiAgICBjYXNlIFk6IHJldHVybiBNLnBvcztcbiAgICBjYXNlIFNJWkU6XG4gICAgICBpZiAobWFya3R5cGUgPT09ICdiYXInKSByZXR1cm4gQkFEOyAvL3NpemUgb2YgYmFyIGlzIHZlcnkgYmFkXG4gICAgICBpZiAobWFya3R5cGUgPT09IFRFWFQpIHJldHVybiBCQUQ7XG4gICAgICBpZiAobWFya3R5cGUgPT09ICdsaW5lJykgcmV0dXJuIEJBRDtcbiAgICAgIHJldHVybiBNLnNpemU7XG4gICAgY2FzZSBDT0xPUjogcmV0dXJuIE0uY29sb3I7XG4gICAgY2FzZSBURVhUOiByZXR1cm4gTS50ZXh0O1xuICB9XG4gIHJldHVybiBCQUQ7XG59O1xuXG5yYW5rRW5jb2RpbmdzLm1lYXN1cmVTY29yZS5jb25zdHMgPSBNO1xuXG5cbnJhbmtFbmNvZGluZ3Muc2NvcmUgPSB7XG4gIGRpbWVuc2lvbjogcmFua0VuY29kaW5ncy5kaW1lbnNpb25TY29yZSxcbiAgbWVhc3VyZTogcmFua0VuY29kaW5ncy5tZWFzdXJlU2NvcmUsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpO1xuXG52YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBnZW46IHt9XG59O1xuXG51dGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudXRpbC5qc29uID0gZnVuY3Rpb24ocywgc3ApIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHMsIG51bGwsIHNwKTtcbn07XG5cbnV0aWwua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgayA9IFtdLCB4O1xuICBmb3IgKHggaW4gb2JqKSBrLnB1c2goeCk7XG4gIHJldHVybiBrO1xufTtcblxudXRpbC5uZXN0ZWRNYXAgPSBmdW5jdGlvbiAoY29sLCBmLCBsZXZlbCwgZmlsdGVyKSB7XG4gIHJldHVybiBsZXZlbCA9PT0gMCA/XG4gICAgY29sLm1hcChmKSA6XG4gICAgY29sLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgciA9IHV0aWwubmVzdGVkTWFwKHYsIGYsIGxldmVsIC0gMSk7XG4gICAgICByZXR1cm4gZmlsdGVyID8gci5maWx0ZXIodXRpbC5ub25FbXB0eSkgOiByO1xuICAgIH0pO1xufTtcblxudXRpbC5uZXN0ZWRSZWR1Y2UgPSBmdW5jdGlvbiAoY29sLCBmLCBsZXZlbCwgZmlsdGVyKSB7XG4gIHJldHVybiBsZXZlbCA9PT0gMCA/XG4gICAgY29sLnJlZHVjZShmLCBbXSkgOlxuICAgIGNvbC5tYXAoZnVuY3Rpb24odikge1xuICAgICAgdmFyIHIgPSB1dGlsLm5lc3RlZFJlZHVjZSh2LCBmLCBsZXZlbCAtIDEpO1xuICAgICAgcmV0dXJuIGZpbHRlciA/IHIuZmlsdGVyKHV0aWwubm9uRW1wdHkpIDogcjtcbiAgICB9KTtcbn07XG5cbnV0aWwubm9uRW1wdHkgPSBmdW5jdGlvbihncnApIHtcbiAgcmV0dXJuICF1dGlsLmlzQXJyYXkoZ3JwKSB8fCBncnAubGVuZ3RoID4gMDtcbn07XG5cblxudXRpbC50cmF2ZXJzZSA9IGZ1bmN0aW9uIChub2RlLCBhcnIpIHtcbiAgaWYgKG5vZGUudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGFyci5wdXNoKG5vZGUudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChub2RlLmxlZnQpIHV0aWwudHJhdmVyc2Uobm9kZS5sZWZ0LCBhcnIpO1xuICAgIGlmIChub2RlLnJpZ2h0KSB1dGlsLnRyYXZlcnNlKG5vZGUucmlnaHQsIGFycik7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbnV0aWwudW5pb24gPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgbyA9IHt9O1xuICBhLmZvckVhY2goZnVuY3Rpb24oeCkgeyBvW3hdID0gdHJ1ZTt9KTtcbiAgYi5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgb1t4XSA9IHRydWU7fSk7XG4gIHJldHVybiB1dGlsLmtleXMobyk7XG59O1xuXG5cbnV0aWwuZ2VuLmdldE9wdCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgLy9tZXJnZSB3aXRoIGRlZmF1bHRcbiAgcmV0dXJuIChvcHQgPyB1dGlsLmtleXMob3B0KSA6IFtdKS5yZWR1Y2UoZnVuY3Rpb24oYywgaykge1xuICAgIGNba10gPSBvcHRba107XG4gICAgcmV0dXJuIGM7XG4gIH0sIE9iamVjdC5jcmVhdGUoY29uc3RzLmdlbi5ERUZBVUxUX09QVCkpO1xufTtcblxuLyoqXG4gKiBwb3dlcnNldCBjb2RlIGZyb20gaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL1Bvd2VyX1NldCNKYXZhU2NyaXB0XG4gKlxuICogICB2YXIgcmVzID0gcG93ZXJzZXQoWzEsMiwzLDRdKTtcbiAqXG4gKiByZXR1cm5zXG4gKlxuICogW1tdLFsxXSxbMl0sWzEsMl0sWzNdLFsxLDNdLFsyLDNdLFsxLDIsM10sWzRdLFsxLDRdLFxuICogWzIsNF0sWzEsMiw0XSxbMyw0XSxbMSwzLDRdLFsyLDMsNF0sWzEsMiwzLDRdXVxuW2VkaXRdXG4qL1xuXG51dGlsLnBvd2Vyc2V0ID0gZnVuY3Rpb24obGlzdCkge1xuICB2YXIgcHMgPSBbXG4gICAgW11cbiAgXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IHBzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBwcy5wdXNoKHBzW2pdLmNvbmNhdChsaXN0W2ldKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcztcbn07XG5cbnV0aWwuY2hvb3NlS29yTGVzcyA9IGZ1bmN0aW9uKGxpc3QsIGspIHtcbiAgdmFyIHN1YnNldCA9IFtbXV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBzdWJzZXQubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBzdWIgPSBzdWJzZXRbal0uY29uY2F0KGxpc3RbaV0pO1xuICAgICAgaWYoc3ViLmxlbmd0aCA8PSBrKXtcbiAgICAgICAgc3Vic2V0LnB1c2goc3ViKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1YnNldDtcbn07XG5cbnV0aWwuY2hvb3NlSyA9IGZ1bmN0aW9uKGxpc3QsIGspIHtcbiAgdmFyIHN1YnNldCA9IFtbXV07XG4gIHZhciBrQXJyYXkgPVtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gc3Vic2V0Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgc3ViID0gc3Vic2V0W2pdLmNvbmNhdChsaXN0W2ldKTtcbiAgICAgIGlmKHN1Yi5sZW5ndGggPCBrKXtcbiAgICAgICAgc3Vic2V0LnB1c2goc3ViKTtcbiAgICAgIH1lbHNlIGlmIChzdWIubGVuZ3RoID09PSBrKXtcbiAgICAgICAga0FycmF5LnB1c2goc3ViKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtBcnJheTtcbn07XG5cbnV0aWwuY3Jvc3MgPSBmdW5jdGlvbihhLGIpe1xuICB2YXIgeCA9IFtdO1xuICBmb3IodmFyIGk9MDsgaTwgYS5sZW5ndGg7IGkrKyl7XG4gICAgZm9yKHZhciBqPTA7ajwgYi5sZW5ndGg7IGorKyl7XG4gICAgICB4LnB1c2goYVtpXS5jb25jYXQoYltqXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn07XG5cbiJdfQ==\n","module.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};","var distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n","var distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.AGGREGATE = 'aggregate';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n","\"use strict\";\n\nmodule.exports = cluster;\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  clusterfck = require('clusterfck'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\ncluster.distance = require('./distance');\n\nfunction cluster(specs, opt) {\n  // jshint unused:false\n  var dist = cluster.distance.table(specs);\n\n  var clusterTrees = clusterfck.hcluster(specs, function(e1, e2) {\n    var s1 = vl.Encoding.shorthand(e1),\n      s2 = vl.Encoding.shorthand(e2);\n    return dist[s1][s2];\n  }, 'average', consts.CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n      return util.traverse(tree, []);\n    })\n   .map(function(cluster) {\n    return cluster.sort(function(spec1, spec2) {\n      // sort each cluster -- have the highest score as 1st item\n      return spec2._info.score - spec1._info.score;\n    });\n  }).filter(function(cluster) {  // filter empty cluster\n    return cluster.length >0;\n  }).sort(function(cluster1, cluster2) {\n    //sort by highest scoring item in each cluster\n    return cluster2[0]._info.score - cluster1[0]._info.score;\n  });\n\n  clusters.dist = dist; //append dist in the array for debugging\n\n  return clusters;\n}","'use strict';\n\nvar c = module.exports = {};\n\nc.SWAPPABLE = 0.05;\nc.DIST_MISSING = 1;\nc.CLUSTER_THRESHOLD = 1;\n\nfunction reduceTupleToTable(r, x) {\n  var a = x[0], b = x[1], d = x[2];\n  r[a] = r[a] || {};\n  r[b] = r[b] || {};\n  r[a][b] = r[b][a] = d;\n  return r;\n}\n\nc.DIST_BY_ENCTYPE = [\n  // positional\n  ['x', 'y', c.SWAPPABLE],\n  ['row', 'col', c.SWAPPABLE],\n\n  // ordinal mark properties\n  ['color', 'shape', c.SWAPPABLE],\n  ['color', 'detail', c.SWAPPABLE],\n  ['detail', 'shape', c.SWAPPABLE],\n\n  // quantitative mark properties\n  ['size', 'color', c.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\nvar distance = {};\nmodule.exports = distance;\n\ndistance.table = function (specs) {\n  var len = specs.length,\n    extendedSpecs = specs.map(function(e) { return distance.extendSpecWithEncTypeByColumnName(e); }),\n    shorthands = specs.map(vl.Encoding.shorthand),\n    diff = {}, i, j;\n\n  for (i = 0; i < len; i++) diff[shorthands[i]] = {};\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      var sj = shorthands[j], si = shorthands[i];\n\n      diff[sj][si] = diff[si][sj] = distance.get(extendedSpecs[i], extendedSpecs[j]);\n    }\n  }\n  return diff;\n};\n\ndistance.get = function (extendedSpec1, extendedSpec2) {\n  var cols = util.union(vl.keys(extendedSpec1.encTypeByField), vl.keys(extendedSpec2.encTypeByField)),\n    dist = 0;\n\n  cols.forEach(function(col) {\n    var e1 = extendedSpec1.encTypeByField[col], e2 = extendedSpec2.encTypeByField[col];\n\n    if (e1 && e2) {\n      if (e1.encType != e2.encType) {\n        dist += (consts.DIST_BY_ENCTYPE[e1.encType] || {})[e2.encType] || 1;\n      }\n    } else {\n      dist += consts.DIST_MISSING;\n    }\n  });\n\n  // do not group stacked chart with similar non-stacked chart!\n  var isStack1 = vl.Encoding.isStack(extendedSpec1),\n    isStack2 = vl.Encoding.isStack(extendedSpec2);\n\n  if(isStack1 || isStack2) {\n    if(isStack1 && isStack2) {\n      if(extendedSpec1.encoding.color.name !== extendedSpec2.encoding.color.name) {\n        dist+=1;\n      }\n    } else {\n      dist+=1; // surely different\n    }\n  }\n  return dist;\n};\n\n// get encoding type by fieldname\ndistance.extendSpecWithEncTypeByColumnName = function(spec) {\n  var _encTypeByField = {},\n    encoding = spec.encoding;\n\n  vl.keys(encoding).forEach(function(encType) {\n    var e = vl.duplicate(encoding[encType]);\n    e.encType = encType;\n    _encTypeByField[e.name || ''] = e;\n    delete e.name;\n  });\n\n  return {\n    marktype: spec.marktype,\n    encTypeByField: _encTypeByField,\n    encoding: spec.encoding\n  };\n};","'use strict';\n\nvar consts = module.exports = {\n  gen: {},\n  cluster: {},\n  rank: {}\n};\n\nconsts.gen.projections = {\n  type: 'object',\n  properties: {\n    omitDotPlot: { //FIXME remove this!\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    maxCardinalityForAutoAddOrdinal: {\n      type: 'integer',\n      default: 50,\n      description: 'max cardinality for ordinal field to be considered for auto adding'\n    },\n    alwaysAddHistogram: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nconsts.gen.aggregates = {\n  type: 'object',\n  properties: {\n    config: {\n      type: 'object'\n    },\n    data: {\n      type: 'object'\n    },\n    tableTypes: {\n      type: 'boolean',\n      default: 'both',\n      enum: ['both', 'aggregated', 'disaggregated']\n    },\n    genDimQ: {\n      type: 'string',\n      default: 'auto',\n      enum: ['auto', 'bin', 'cast', 'none'],\n      description: 'Use Q as Dimension either by binning or casting'\n    },\n    minCardinalityForBin: {\n      type: 'integer',\n      default: 20,\n      description: 'minimum cardinality of a field if we were to bin'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitMeasureOnly: {\n      type: 'boolean',\n      default: false,\n      description: 'Omit aggregation with measure(s) only'\n    },\n    omitDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Omit aggregation with dimension(s) only'\n    },\n    addCountForDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Add count when there are dimension(s) only'\n    },\n    aggrList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: [undefined, 'mean']\n    },\n    timeUnitList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: ['year']\n    },\n    consistentAutoQ: {\n      type: 'boolean',\n      default: true,\n      description: \"generate similar auto transform for quant\"\n    }\n  }\n};\n\nconsts.gen.encodings = {\n  type: 'object',\n  properties: {\n    marktypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['point', 'bar', 'line', 'area', 'text', 'tick'], //filled_map\n      description: 'allowed marktypes'\n    },\n    encodingTypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['x', 'y', 'row', 'col', 'size', 'color', 'text', 'detail'],\n      description: 'allowed encoding types'\n    },\n    maxGoodCardinalityForFacets: {\n      type: 'integer',\n      default: 5,\n      description: 'maximum cardinality of a field to be put on facet (row/col) effectively'\n    },\n    maxCardinalityForFacets: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of a field to be put on facet (row/col)'\n    },\n    maxGoodCardinalityForColor: {\n      type: 'integer',\n      default: 7,\n      description: 'maximum cardinality of an ordinal field to be put on color effectively'\n    },\n    maxCardinalityForColor: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal field to be put on color'\n    },\n    maxCardinalityForShape: {\n      type: 'integer',\n      default: 6,\n      description: 'maximum cardinality of an ordinal field to be put on shape'\n    },\n    omitTranpose:  {\n      type: 'boolean',\n      default: true,\n      description: 'Eliminate all transpose by (1) keeping horizontal dot plot only (2) for OxQ charts, always put O on Y (3) show only one DxD, MxM (currently sorted by name)'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitDotPlotWithExtraEncoding: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all dot plots with >1 encoding'\n    },\n    omitMultipleRetinalEncodings: {\n      type: 'boolean',\n      default: true,\n      description: 'omit using multiple retinal variables (size, color, shape)'\n    },\n    omitNonTextAggrWithAllDimsOnFacets: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all aggregated charts (except text tables) with all dims on facets (row, col)'\n    },\n    omitOneDimensionCount: {\n      type: 'boolean',\n      default: false,\n      description: 'omit one dimension count'\n    },\n    omitSizeOnBar: {\n      type: 'boolean',\n      default: false,\n      description: 'do not use bar\\'s size'\n    },\n    omitStackedAverage: {\n      type: 'boolean',\n      default: true,\n      description: 'do not stack bar chart with average'\n    },\n    alwaysGenerateTableAsHeatmap: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n","module.exports = {\n  consts: require('./consts'),\n  cluster: require('./cluster/cluster'),\n  gen: require('./gen/gen'),\n  rank: require('./rank/rank'),\n  util: require('./util'),\n  auto: \"-, sum\"\n};\n\n\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null);\n\nvar consts = require('../consts');\n\nvar AUTO = '*';\n\nmodule.exports = genAggregates;\n\nfunction genAggregates(output, fieldDefs, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.aggregates);\n  var tf = new Array(fieldDefs.length);\n  var hasNorO = vl.any(fieldDefs, function(f) {\n    return vl.encDef.isTypes(f, [N, O]);\n  });\n\n  function emit(fieldSet) {\n    fieldSet = vl.duplicate(fieldSet);\n    fieldSet.key = vl.encDef.shorthands(fieldSet);\n    output.push(fieldSet);\n  }\n\n  function checkAndPush() {\n    if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n      var hasMeasure = false, hasDimension = false, hasRaw = false;\n      tf.forEach(function(f) {\n        if (vl.encDef.isDimension(f)) {\n          hasDimension = true;\n        } else {\n          hasMeasure = true;\n          if (!f.aggregate) hasRaw = true;\n        }\n      });\n      if (!hasDimension && !hasRaw && opt.omitMeasureOnly) return;\n      if (!hasMeasure) {\n        if (opt.addCountForDimensionOnly) {\n          tf.push(vl.encDef.count());\n          emit(tf);\n          tf.pop();\n        }\n        if (opt.omitDimensionOnly) return;\n      }\n    }\n    if (opt.omitDotPlot && tf.length === 1) return;\n    emit(tf);\n  }\n\n  function assignAggrQ(i, hasAggr, autoMode, a) {\n    var canHaveAggr = hasAggr === true || hasAggr === null,\n      cantHaveAggr = hasAggr === false || hasAggr === null;\n    if (a) {\n      if (canHaveAggr) {\n        tf[i].aggregate = a;\n        assignField(i + 1, true, autoMode);\n        delete tf[i].aggregate;\n      }\n    } else { // if(a === undefined)\n      if (cantHaveAggr) {\n        assignField(i + 1, false, autoMode);\n      }\n    }\n  }\n\n  function assignBinQ(i, hasAggr, autoMode) {\n    tf[i].bin = true;\n    assignField(i + 1, hasAggr, autoMode);\n    delete tf[i].bin;\n  }\n\n  function assignQ(i, hasAggr, autoMode) {\n    var f = fieldDefs[i],\n      canHaveAggr = hasAggr === true || hasAggr === null;\n\n    tf[i] = {name: f.name, type: f.type};\n\n    if (f.aggregate === 'count') { // if count is included in the selected fields\n      if (canHaveAggr) {\n        tf[i].aggregate = f.aggregate;\n        assignField(i + 1, true, autoMode);\n      }\n    } else if (f._aggregate) {\n      // TODO support array of f._aggrs too\n      assignAggrQ(i, hasAggr, autoMode, f._aggregate);\n    } else if (f._raw) {\n      assignAggrQ(i, hasAggr, autoMode, undefined);\n    } else if (f._bin) {\n      assignBinQ(i, hasAggr, autoMode);\n    } else {\n      opt.aggrList.forEach(function(a) {\n        if (!opt.consistentAutoQ || autoMode === AUTO || autoMode === a) {\n          assignAggrQ(i, hasAggr, a /*assign autoMode*/, a);\n        }\n      });\n\n      if ((!opt.consistentAutoQ || vl.isin(autoMode, [AUTO, 'bin', 'cast', 'autocast'])) && !hasNorO) {\n        var highCardinality = vl.encDef.cardinality(f, stats) > opt.minCardinalityForBin;\n\n        var isAuto = opt.genDimQ === 'auto',\n          genBin = opt.genDimQ  === 'bin' || (isAuto && highCardinality),\n          genCast = opt.genDimQ === 'cast' || (isAuto && !highCardinality);\n\n        if (genBin && vl.isin(autoMode, [AUTO, 'bin', 'autocast'])) {\n          assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n        }\n        if (genCast && vl.isin(autoMode, [AUTO, 'cast', 'autocast'])) {\n          tf[i].type = 'O';\n          assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n          tf[i].type = 'Q';\n        }\n      }\n    }\n  }\n\n  function assignTimeUnitT(i, hasAggr, autoMode, timeUnit) {\n    tf[i].timeUnit = timeUnit;\n    assignField(i+1, hasAggr, autoMode);\n    delete tf[i].timeUnit;\n  }\n\n  function assignT(i, hasAggr, autoMode) {\n    var f = fieldDefs[i];\n    tf[i] = {name: f.name, type: f.type};\n\n    // TODO support array of f._timeUnits\n    if (f._timeUnit) {\n      assignTimeUnitT(i, hasAggr, autoMode, f._timeUnit);\n    } else {\n      opt.timeUnitList.forEach(function(timeUnit) {\n        if (timeUnit === undefined) {\n          if (!hasAggr) { // can't aggregate over raw time\n            assignField(i+1, false, autoMode);\n          }\n        } else {\n          assignTimeUnitT(i, hasAggr, autoMode, timeUnit);\n        }\n      });\n    }\n\n    // FIXME what if you aggregate time?\n  }\n\n  function assignField(i, hasAggr, autoMode) {\n    if (i === fieldDefs.length) { // If all fields are assigned\n      checkAndPush();\n      return;\n    }\n\n    var f = fieldDefs[i];\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case Q:\n        assignQ(i, hasAggr, autoMode);\n        break;\n\n      case T:\n        assignT(i, hasAggr, autoMode);\n        break;\n      case O:\n        /* falls through */\n      case N:\n        /* falls through */\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr, autoMode);\n        break;\n    }\n  }\n\n  var hasAggr = opt.tableTypes === 'aggregated' ? true : opt.tableTypes === 'disaggregated' ? false : null;\n  assignField(0, hasAggr, AUTO);\n\n  return output;\n}\n","\"use strict\";\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  genMarkTypes = require('./marktypes'),\n  isDimension = vl.encDef.isDimension,\n  isMeasure = vl.encDef.isMeasure;\n\nmodule.exports = genEncodings;\n\n// FIXME remove dimension, measure and use information in vega-lite instead!\nvar rules = {\n  x: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dimension: true,\n    multiple: true\n  },\n  col: {\n    dimension: true,\n    multiple: true\n  },\n  shape: {\n    dimension: true,\n    rules: shapeRules\n  },\n  size: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  color: {\n    dimension: true,\n    measure: true,\n    rules: colorRules\n  },\n  text: {\n    measure: true\n  },\n  detail: {\n    dimension: true\n  }\n  //geo: {\n  //  geo: true\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\nfunction retinalEncRules(encoding, fieldDef, stats, opt) {\n  if (opt.omitMultipleRetinalEncodings) {\n    if (encoding.color || encoding.size || encoding.shape) return false;\n  }\n  return true;\n}\n\nfunction colorRules(encoding, fieldDef, stats, opt) {\n  if(!retinalEncRules(encoding, fieldDef, stats, opt)) return false;\n\n  return vl.encDef.isMeasure(fieldDef) ||\n    vl.encDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction shapeRules(encoding, fieldDef, stats, opt) {\n  if(!retinalEncRules(encoding, fieldDef, stats, opt)) return false;\n\n  if (fieldDef.bin && fieldDef.type === Q) return false;\n  if (fieldDef.timeUnit && fieldDef.type === T) return false;\n  return vl.encDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction dimMeaTransposeRule(encoding) {\n  // create horizontal histogram for ordinal\n  if (vl.encDef.isTypes(encoding.y, [N, O]) && isMeasure(encoding.x)) return true;\n\n  // vertical histogram for Q and T\n  if (isMeasure(encoding.y) && (!vl.encDef.isTypes(encoding.x, [N, O]) && isDimension(encoding.x))) return true;\n\n  return false;\n}\n\nfunction generalRules(encoding, stats, opt) {\n  // enc.text is only used for TEXT TABLE\n  if (encoding.text) {\n    return genMarkTypes.satisfyRules(encoding, TEXT, stats, opt);\n  }\n\n  // CARTESIAN PLOT OR MAP\n  if (encoding.x || encoding.y || encoding.geo || encoding.arc) {\n\n    if (encoding.row || encoding.col) { //have facet(s)\n\n      // don't use facets before filling up x,y\n      if (!encoding.x || !encoding.y) return false;\n\n      if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n        // remove all aggregated charts with all dims on facets (row, col)\n        if (genEncodings.isAggrWithAllDimOnFacets(encoding)) return false;\n      }\n    }\n\n    if (encoding.x && encoding.y) {\n      var isDimX = !!isDimension(encoding.x),\n        isDimY = !!isDimension(encoding.y);\n\n      if (isDimX && isDimY && !vl.enc.isAggregate(encoding)) {\n        // FIXME actually check if there would be occlusion #90\n        return false;\n      }\n\n      if (opt.omitTranpose) {\n        if (isDimX ^ isDimY) { // dim x mea\n          if (!dimMeaTransposeRule(encoding)) return false;\n        } else if (encoding.y.type===T || encoding.x.type === T) {\n          if (encoding.y.type===T && encoding.x.type !== T) return false;\n        } else { // show only one OxO, QxQ\n          if (encoding.x.name > encoding.y.name) return false;\n        }\n      }\n      return true;\n    }\n\n    // DOT PLOTS\n    // // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && encoding.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(encoding).length > 1) return false;\n\n    if (opt.omitOneDimensionCount) {\n      // one dimension \"count\"\n      if (encoding.x && encoding.x.aggregate == 'count' && !encoding.y) return false;\n      if (encoding.y && encoding.y.aggregate == 'count' && !encoding.x) return false;\n    }\n\n    return true;\n  }\n  return false;\n}\n\ngenEncodings.isAggrWithAllDimOnFacets = function (encoding) {\n  var hasAggr = false, hasOtherO = false;\n  for (var encType in encoding) {\n    var field = encoding[encType];\n    if (field.aggregate) {\n      hasAggr = true;\n    }\n    if (vl.encDef.isDimension(field) && (encType !== ROW && encType !== COL)) {\n      hasOtherO = true;\n    }\n    if (hasAggr && hasOtherO) break;\n  }\n\n  return hasAggr && !hasOtherO;\n};\n\n\nfunction genEncodings(encodings, fieldDefs, stats, opt) {\n  // generate a collection vega-lite's enc\n  var tmpEncoding = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fieldDefs.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (generalRules(tmpEncoding, stats, opt)) {\n        encodings.push(vl.duplicate(tmpEncoding));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var fieldDef = fieldDefs[i];\n    for (var j in opt.encodingTypeList) {\n      var encType = opt.encodingTypeList[j],\n        isDim = isDimension(fieldDef);\n\n      //TODO: support \"multiple\" assignment\n      if (!(encType in tmpEncoding) && // encoding not used\n        ((isDim && rules[encType].dimension) || (!isDim && rules[encType].measure)) &&\n        (!rules[encType].rules || rules[encType].rules(tmpEncoding, fieldDef, stats, opt))\n      ) {\n        tmpEncoding[encType] = fieldDef;\n        assignField(i + 1);\n        delete tmpEncoding[encType];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encodings;\n}\n","'use strict';\n\nvar util = require('../util');\n\n/**\n * Module for generating visualizations\n */\n\nvar gen = module.exports = {\n  // data variations\n  aggregates: require('./aggregates'),\n  projections: require('./projections'),\n  // encodings / visual variations\n  specs: require('./specs'),\n  encodings: require('./encodings'),\n  marktypes: require('./marktypes')\n};\n\n\n// TODO(kanitw): revise if this is still working\ngen.charts = function(fieldDefs, opt, config, flat) {\n  opt = util.gen.getOpt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? gen.aggregates([], fieldDefs, opt) : [fieldDefs],\n    encodings, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggregate)) {\n    encodings = fieldSets.reduce(function(output, fieldDefs) {\n      return gen.encs(output, fieldDefs, opt);\n    }, []);\n  } else {\n    encodings = fieldSets.map(function(fieldDefs) {\n      return gen.encs([], fieldDefs, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = util.nestedReduce(encodings, function(output, encoding) {\n      return gen.marktypes(output, encoding, opt, config);\n    }, level, true);\n  } else {\n    charts = util.nestedMap(encodings, function(encoding) {\n      return gen.marktypes([], encoding, opt, config);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};","\"use strict\";\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension,\n  isOrdinalScale = vl.encDef.isOrdinalScale;\n\nvar vlmarktypes = module.exports = getMarktypes;\n\nvar marksRule = vlmarktypes.rule = {\n  point:  pointRule,\n  bar:    barRule,\n  line:   lineRule,\n  area:   areaRule, // area is similar to line\n  text:   textRule,\n  tick:   tickRule\n};\n\nfunction getMarktypes(encoding, stats, opt) {\n  return opt.marktypeList.filter(function(markType){\n    return vlmarktypes.satisfyRules(encoding, markType, stats, opt);\n  });\n}\n\nvlmarktypes.satisfyRules = function (encoding, markType, stats, opt) {\n  var mark = vl.compiler.marks[markType],\n    reqs = mark.requiredEncoding,\n    support = mark.supportedEncoding;\n\n  for (var i in reqs) { // all required encodings in enc\n    if (!(reqs[i] in encoding)) return false;\n  }\n\n  for (var encType in encoding) { // all encodings in enc are supported\n    if (!support[encType]) return false;\n  }\n\n  return !marksRule[markType] || marksRule[markType](encoding, stats, opt);\n};\n\nfunction facetRule(fieldDef, stats, opt) {\n  return vl.encDef.cardinality(fieldDef, stats) <= opt.maxCardinalityForFacets;\n}\n\nfunction facetsRule(encoding, stats, opt) {\n  if(encoding.row && !facetRule(encoding.row, stats, opt)) return false;\n  if(encoding.col && !facetRule(encoding.col, stats, opt)) return false;\n  return true;\n}\n\nfunction pointRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n  if (encoding.x && encoding.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    var xIsDim = isDimension(encoding.x),\n      yIsDim = isDimension(encoding.y);\n\n    // For OxO\n    if (xIsDim && yIsDim) {\n      // shape doesn't work with both x, y as ordinal\n      if (encoding.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (encoding.color && isDimension(encoding.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && encoding.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(encoding).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (encoding.shape) return false;\n  }\n  return true;\n}\n\nfunction tickRule(encoding, stats, opt) {\n  // jshint unused:false\n  if (encoding.x || encoding.y) {\n    if(vl.enc.isAggregate(encoding)) return false;\n\n    var xIsDim = isDimension(encoding.x),\n      yIsDim = isDimension(encoding.y);\n\n    return (!xIsDim && (!encoding.y || isOrdinalScale(encoding.y))) ||\n      (!yIsDim && (!encoding.x || isOrdinalScale(encoding.x)));\n  }\n  return false;\n}\n\nfunction barRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  // bar requires at least x or y\n  if (!encoding.x && !encoding.y) return false;\n\n  if (opt.omitSizeOnBar && encoding.size !== undefined) return false;\n\n  // FIXME actually check if there would be occlusion #90\n  // need to aggregate on either x or y\n  var aggEitherXorY =\n    (!encoding.x || encoding.x.aggregate === undefined) ^\n    (!encoding.y || encoding.y.aggregate === undefined);\n\n\n  if (aggEitherXorY) {\n    var eitherXorYisDimOrNull =\n      (!encoding.x || isDimension(encoding.x)) ^\n      (!encoding.y || isDimension(encoding.y));\n\n    if (eitherXorYisDimOrNull) {\n      var aggregate = encoding.x.aggregate || encoding.y.aggregate;\n      return !(opt.omitStackedAverage && aggregate ==='mean' && encoding.color);\n    }\n  }\n\n  return false;\n}\n\nfunction lineRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // FIXME truly ordinal data is fine here too.\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return encoding.x.type == 'T' && encoding.x.timeUnit && encoding.y.type == 'Q' && encoding.y.aggregate;\n}\n\nfunction areaRule(encoding, stats, opt) {\n  if(!facetsRule(encoding, stats, opt)) return false;\n\n  if(!lineRule(encoding, stats, opt)) return false;\n\n  return !(opt.omitStackedAverage && encoding.y.aggregate ==='mean' && encoding.color);\n}\n\nfunction textRule(encoding, stats, opt) {\n  // at least must have row or col and aggregated text values\n  return (encoding.row || encoding.col) && encoding.text && encoding.text.aggregate && !encoding.x && !encoding.y && !encoding.size &&\n    (!opt.alwaysGenerateTableAsHeatmap || !encoding.color);\n}\n","'use strict';\n\nvar util = require('../util'),\n  consts = require('../consts'),\n  vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension;\n\nmodule.exports = projections;\n\n// TODO support other mode of projections generation\n// powerset, chooseK, chooseKorLess are already included in the util\n\n/**\n * fields\n * @param  {[type]} fieldDefs array of fields and query information\n * @return {[type]}        [description]\n */\nfunction projections(fieldDefs, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.projections);\n\n  // First categorize field, selected, fieldsToAdd, and save indices\n  var selected = [], fieldsToAdd = [], fieldSets = [],\n    hasSelectedDimension = false,\n    hasSelectedMeasure = false,\n    indices = {};\n\n  fieldDefs.forEach(function(fieldDef, index){\n    //save indices for stable sort later\n    indices[fieldDef.name] = index;\n\n    if (fieldDef.selected) {\n      selected.push(fieldDef);\n      if (isDimension(fieldDef) || fieldDef.type ==='T') { // FIXME / HACK\n        hasSelectedDimension = true;\n      } else {\n        hasSelectedMeasure = true;\n      }\n    } else if (fieldDef.selected !== false && !vl.encDef.isCount(fieldDef)) {\n      if (vl.encDef.isDimension(fieldDef) &&\n          !opt.maxCardinalityForAutoAddOrdinal &&\n          vl.encDef.cardinality(fieldDef, stats, 15) > opt.maxCardinalityForAutoAddOrdinal\n        ) {\n        return;\n      }\n      fieldsToAdd.push(fieldDef);\n    }\n  });\n\n  fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n\n  var setsToAdd = util.chooseKorLess(fieldsToAdd, 1);\n\n  setsToAdd.forEach(function(setToAdd) {\n    var fieldSet = selected.concat(setToAdd);\n    if (fieldSet.length > 0) {\n      if (opt.omitDotPlot && fieldSet.length === 1) return;\n      fieldSets.push(fieldSet);\n    }\n  });\n\n  fieldSets.forEach(function(fieldSet) {\n      // always append projection's key to each projection returned, d3 style.\n    fieldSet.key = projections.key(fieldSet);\n  });\n\n  return fieldSets;\n}\n\nvar typeIsMeasureScore = {\n  N: 0,\n  O: 0,\n  T: 2,\n  Q: 3\n};\n\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n  return function(a, b){\n    // sort by type of the data\n    if (a.type !== b.type) {\n      if (!hasSelectedDimension) {\n        return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n      } else { //if (!hasSelectedMeasure) {\n        return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n      }\n    }\n    //make the sort stable\n    return indices[a.name] - indices[b.name];\n  };\n}\n\nprojections.key = function(projection) {\n  return projection.map(function(field) {\n    return vl.encDef.isCount(field) ? 'count' : field.name;\n  }).join(',');\n};\n\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  genEncodings = require('./encodings'),\n  getMarktypes = require('./marktypes'),\n  rank = require('../rank/rank'),\n  consts = require('../consts');\n\nmodule.exports = genSpecsFromFieldDefs;\n\n/** Design Encodings for a set of field definition */\n\nfunction genSpecsFromFieldDefs(output, fieldDefs, stats, opt, nested) {\n  // opt must be augmented before being passed to genEncodings or getMarktypes\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  var encodings = genEncodings([], fieldDefs, stats, opt);\n\n  if (nested) {\n    return encodings.reduce(function(dict, encoding) {\n      dict[encoding] = genSpecsFromEncodings([], encoding, stats, opt);\n      return dict;\n    }, {});\n  } else {\n    return encodings.reduce(function(list, encoding) {\n      return genSpecsFromEncodings(list, encoding, stats, opt);\n    }, []);\n  }\n}\n\nfunction genSpecsFromEncodings(output, encoding, stats, opt) {\n  getMarktypes(encoding, stats, opt)\n    .forEach(function(markType) {\n      var spec = vl.duplicate({\n          // Clone config & encoding to unique objects\n          encoding: encoding,\n          config: opt.config\n        });\n\n      spec.marktype = markType;\n      // Data object is the same across charts: pass by reference\n      spec.data = opt.data;\n\n      spec = finalTouch(spec, stats, opt);\n      var score = rank.encoding(spec, stats, opt);\n\n      spec._info = score;\n      output.push(spec);\n    });\n  return output;\n}\n\n//FIXME this should be refactors\nfunction finalTouch(spec, stats, opt) {\n  if (spec.marktype === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n    spec.encoding.color = spec.encoding.text;\n  }\n\n  // don't include zero if stdev/mean < 0.01\n  // https://github.com/uwdata/visrec/issues/69\n  var encoding = spec.encoding;\n  ['x', 'y'].forEach(function(encType) {\n    var field = encoding[encType];\n    if (field && vl.encDef.isMeasure(field) && !vl.encDef.isCount(field)) {\n      var stat = stats[field.name];\n      if (stat && stat.stdev / stat.mean < 0.01) {\n        field.scale = {zero: false};\n      }\n    }\n  });\n  return spec;\n}\n","'use strict';\n\nvar g = global || window;\n\nrequire('vega-lite/src/globals');\n\ng.CHART_TYPES = {\n  TABLE: 'TABLE',\n  BAR: 'BAR',\n  PLOT: 'PLOT',\n  LINE: 'LINE',\n  AREA: 'AREA',\n  MAP: 'MAP',\n  HISTOGRAM: 'HISTOGRAM'\n};\n\ng.ANY_DATA_TYPES = (1 << 4) - 1;","module.exports = {\n  encoding: require('./rankEncodings')\n};\n\n\n","'use strict';\n\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension;\n\nmodule.exports = rankEncodings;\n\n// bad score not specified in the table above\nvar UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  tick: 0.96,\n  point: 0.95,\n  circle: 0.94,\n  square: 0.94,\n  text: 0.8\n};\n\nfunction rankEncodings(spec, stats, opt, selected) {\n  var features = [],\n    encTypes = vl.keys(spec.encoding),\n    marktype = spec.marktype,\n    encoding = spec.encoding;\n\n  var encodingMappingByField = vl.enc.reduce(spec.encoding, function(o, fieldDef, encType) {\n    var key = vl.encDef.shorthand(fieldDef);\n    var mappings = o[key] = o[key] || [];\n    mappings.push({encType: encType, field: fieldDef});\n    return o;\n  }, {});\n\n  // data - encoding mapping score\n  vl.forEach(encodingMappingByField, function(mappings) {\n    var reasons = mappings.map(function(m) {\n        return m.encType + vl.shorthand.assign + vl.encDef.shorthand(m.field) +\n          ' ' + (selected && selected[m.field.name] ? '[x]' : '[ ]');\n      }),\n      scores = mappings.map(function(m) {\n        var role = vl.encDef.isDimension(m.field) ? 'dimension' : 'measure';\n\n        var score = rankEncodings.score[role](m.field, m.encType, spec.marktype, stats, opt);\n\n        return !selected || selected[m.field.name] ? score : Math.pow(score, 0.125);\n      });\n\n    features.push({\n      reason: reasons.join(\" | \"),\n      score: Math.max.apply(null, scores)\n    });\n  });\n\n  // plot type\n  if (marktype === TEXT) {\n    // TODO\n  } else {\n    if (encoding.x && encoding.y) {\n      if (isDimension(encoding.x) ^ isDimension(encoding.y)) {\n        features.push({\n          reason: 'OxQ plot',\n          score: 0.8\n        });\n      }\n    }\n  }\n\n  // penalize not using positional only penalize for non-text\n  if (encTypes.length > 1 && marktype !== TEXT) {\n    if ((!encoding.x || !encoding.y) && !encoding.geo && !encoding.text) {\n      features.push({\n        reason: 'unused position',\n        score: UNUSED_POSITION\n      });\n    }\n  }\n\n  // mark type score\n  features.push({\n    reason: 'marktype='+marktype,\n    score: MARK_SCORE[marktype]\n  });\n\n  return {\n    score: features.reduce(function(p, f) {\n      return p * f.score;\n    }, 1),\n    features: features\n  };\n}\n\n\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\n\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675; // < color_ok, > color_bad\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65; // > M.Size\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\n\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\n\nrankEncodings.dimensionScore = function (fieldDef, encType, marktype, stats, opt){\n  var cardinality = vl.encDef.cardinality(fieldDef, stats);\n  switch (encType) {\n    case X:\n      if (vl.encDef.isTypes(fieldDef, [N, O]))  return D.pos - D.minor;\n      return D.pos;\n\n    case Y:\n      if (vl.encDef.isTypes(fieldDef, [N, O])) return D.pos - D.minor; //prefer ordinal on y\n      if (fieldDef.type === T) return D.Y_T; // time should not be on Y\n      return D.pos - D.minor;\n\n    case COL:\n      if (marktype === TEXT) return D.facet_text;\n      //prefer column over row due to scrolling issues\n      return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n\n    case ROW:\n      if (marktype === TEXT) return D.facet_text;\n      return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n\n    case COLOR:\n      var hasOrder = (fieldDef.bin && fieldDef.type===Q) || (fieldDef.timeUnit && fieldDef.type===T);\n\n      //FIXME add stacking option once we have control ..\n      var isStacked = marktype === 'bar' || marktype === 'area';\n\n      // true ordinal on color is currently BAD (until we have good ordinal color scale support)\n      if (hasOrder) return D.color_bad;\n\n      //stacking gets lower score\n      if (isStacked) return D.color_stack;\n\n      return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good: cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n    case SHAPE:\n      return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n    case DETAIL:\n      return D.detail;\n  }\n  return TERRIBLE;\n};\n\nrankEncodings.dimensionScore.consts = D;\n\nrankEncodings.measureScore = function (fieldDef, encType, marktype, stats, opt) {\n  // jshint unused:false\n  switch (encType){\n    case X: return M.pos;\n    case Y: return M.pos;\n    case SIZE:\n      if (marktype === 'bar') return BAD; //size of bar is very bad\n      if (marktype === TEXT) return BAD;\n      if (marktype === 'line') return BAD;\n      return M.size;\n    case COLOR: return M.color;\n    case TEXT: return M.text;\n  }\n  return BAD;\n};\n\nrankEncodings.measureScore.consts = M;\n\n\nrankEncodings.score = {\n  dimension: rankEncodings.dimensionScore,\n  measure: rankEncodings.measureScore,\n};\n","\"use strict\";\n\nvar consts = require('./consts');\n\nvar util = module.exports = {\n  gen: {}\n};\n\nutil.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) == '[object Array]';\n};\n\nutil.json = function(s, sp) {\n  return JSON.stringify(s, null, sp);\n};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.nestedMap = function (col, f, level, filter) {\n  return level === 0 ?\n    col.map(f) :\n    col.map(function(v) {\n      var r = util.nestedMap(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nestedReduce = function (col, f, level, filter) {\n  return level === 0 ?\n    col.reduce(f, []) :\n    col.map(function(v) {\n      var r = util.nestedReduce(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nonEmpty = function(grp) {\n  return !util.isArray(grp) || grp.length > 0;\n};\n\n\nutil.traverse = function (node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) util.traverse(node.left, arr);\n    if (node.right) util.traverse(node.right, arr);\n  }\n  return arr;\n};\n\nutil.union = function (a, b) {\n  var o = {};\n  a.forEach(function(x) { o[x] = true;});\n  b.forEach(function(x) { o[x] = true;});\n  return util.keys(o);\n};\n\n\nutil.gen.getOpt = function (opt) {\n  //merge with default\n  return (opt ? util.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(consts.gen.DEFAULT_OPT));\n};\n\n/**\n * powerset code from http://rosettacode.org/wiki/Power_Set#JavaScript\n *\n *   var res = powerset([1,2,3,4]);\n *\n * returns\n *\n * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],\n * [2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n[edit]\n*/\n\nutil.powerset = function(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n};\n\nutil.chooseKorLess = function(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length <= k){\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n};\n\nutil.chooseK = function(list, k) {\n  var subset = [[]];\n  var kArray =[];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length < k){\n        subset.push(sub);\n      }else if (sub.length === k){\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n};\n\nutil.cross = function(a,b){\n  var x = [];\n  for(var i=0; i< a.length; i++){\n    for(var j=0;j< b.length; j++){\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n};\n\n"],"sourceRoot":"/source/"}