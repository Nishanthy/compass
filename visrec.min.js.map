{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/vr","visrec.js","src/visgen.js","src/visrank.js"],"names":["e","exports","module","define","amd","f","window","global","self","vr","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"gen","rank","./visgen","./visrank",2,"colenc","encoding","_colenc","enc","vl","keys","forEach","encType","duplicate","type","name","marktype","col","traverse","node","arr","undefined","value","push","left","right","isDim","field","bin","xOyQ","x","y","generalRule","opt","geo","text","arc","omitTranpose","row","omitAggrWithAllDimsOnFacets","hasAggr","hasOtherO","aggr","pointRule","shape","color","omitDotPlotWithExtraEncoding","barRule","lineRule","nestedMap","level","filter","map","v","nonEmpty","nestedReduce","reduce","getopt","c","k","Object","create","vgn","DEFAULT_OPT","union","b","range","start","stop","step","arguments","Infinity","j","d3_range_integerScale","abs","clusterfck","genAggr","genBin","genTypeCasting","aggrList","marktypeList","omitDimensionOnly","omitAggregateWithMeasureOnly","ENCODING_TYPES","encodingTypes","ANY_DATA_TYPES","DIST_BY_ENCTYPE","d","DIST_MISSING","CLUSTER_THRESHOLD","_getDistance","colenc1","colenc2","cols","dist","e1","e2","getDistanceTable","encodings","len","colencs","diff","Array","cluster","clusterTrees","hcluster","clusters","tree","marksRule","point","bar","line","area","ENCODING_RULES","dataTypes","O","Q","T","multiple","size","alpha","grp","isArray","generateCharts","fields","cfg","flat","charts","fieldSets","genAggregate","output","genFieldEncodings","genMarkTypes","_getSupportedMarkTypes","markType","markTypes","mark","marks","reqs","requiredEncoding","support","supportedEncoding","assignField","hasMeasure","hasDimension","hasRaw","tf","_aggr","aggregates","tmpEnc","et","obj","toString","Math","this",3,"vrank","ENCODING_SCORE","BAD_ENCODING_SCORE","UNUSED_POSITION","MARK_SCORE","circle","square","encodingScore","features","encTypes","score","unusedPosition","p","fieldsScore"],"mappings":"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","file":"visrec.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var vr = module.exports = {};\n\nvr.gen = require('./visgen');\nvr.rank = require('./visrank');\n\n","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.vr=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar vr = module.exports = {};\n\nvr.gen = require('./visgen');\nvr.rank = require('./visrank');\n\n\n},{\"./visgen\":2,\"./visrank\":3}],2:[function(require,module,exports){\n(function (global){\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  clusterfck = (typeof window !== \"undefined\" ? window.clusterfck : typeof global !== \"undefined\" ? global.clusterfck : null);\n\nvar vgn = module.exports = {}; //VisGeN\n\nvgn.DEFAULT_OPT = {\n  genAggr: true,\n  genBin: true,\n  genTypeCasting: false,\n\n  aggrList: [undefined, \"avg\"], //undefined = no aggregation\n  marktypeList: [\"point\", \"bar\", \"line\", \"area\", \"text\"], //filled_map\n\n  // PRUNING RULES FOR ENCODING VARIATIONS\n\n  /**\n   * Eliminate all transpose\n   * - keeping horizontal dot plot only.\n   * - for OxQ charts, always put O on Y\n   * - show only one OxO, QxQ (currently sorted by name)\n   */\n  omitTranpose: true,\n  /** remove all dot plot with >1 encoding */\n  omitDotPlotWithExtraEncoding: true,\n\n  /** remove all aggregate charts with all dims on facets (row, col) */\n  //FIXME this is good for text though!\n  omitAggrWithAllDimsOnFacets: true,\n\n  // PRUNING RULES FOR TRANFORMATION VARIATIONS\n\n  /** omit field sets with only dimensions */\n  omitDimensionOnly: true,\n  /** omit aggregate field sets with only measures */\n  omitAggregateWithMeasureOnly: true\n\n};\n\nvar ENCODING_TYPES = vl.encodingTypes;\n\nvar CHART_TYPES = {\n  TABLE: 'TABLE',\n  BAR: 'BAR',\n  PLOT: 'PLOT',\n  LINE: 'LINE',\n  AREA: 'AREA',\n  MAP: 'MAP',\n  HISTOGRAM: 'HISTOGRAM'\n};\n\nvar ANY_DATA_TYPES = (1 << 4) - 1;\n\n//FIXME move these to vl\nvar AGGREGATION_FN = { //all possible aggregate function listed by each data type\n  Q: [\"avg\", \"sum\", \"min\", \"max\", \"count\"]\n};\n\nvar TRANSFORM_FN = { //all possible transform function listed by each data type\n  Q: [\"log\", \"sqrt\", \"abs\"], // \"logit?\"\n  T: [\"year\", \"month\", \"day\"] //,\"hr\", \"min\", \"bmon\", \"bday\", \"bdow\", \"bhr\"]\n};\n\nvar json = function(s,sp){ return JSON.stringify(s, null, sp);};\n\n// Begin of Distance\n\nvar DIST_BY_ENCTYPE = [\n    // positional\n    [\"x\", \"y\", 0.2],\n    [\"row\", \"col\", 0.2],\n\n    // ordinal mark properties\n    [\"color\", \"shape\", 0.2],\n\n    // quantitative mark properties\n    [\"color\", \"alpha\", 0.2],\n    [\"size\", \"alpha\", 0.2],\n    [\"size\", \"color\", 0.2]\n  ].reduce(function(r, x) {\n  var a=x[0], b=x[1], d=x[2];\n    r[a] = r[a] || {};\n    r[b] = r[b] || {};\n    r[a][b] = r[b][a] = d;\n    return r;\n  }, {}),\n  DIST_MISSING = 100, CLUSTER_THRESHOLD=1;\n\nfunction colenc(encoding) {\n  var _colenc = {},\n    enc = encoding.enc;\n\n  vl.keys(enc).forEach(function(encType) {\n    var e = vl.duplicate(enc[encType]);\n    e.type = encType;\n    _colenc[e.name || \"\"] = e;\n    delete e.name;\n  });\n\n  return {\n    marktype: encoding.marktype,\n    col: _colenc\n  };\n}\n\nvgn._getDistance = function(colenc1, colenc2) {\n  var cols = union(vl.keys(colenc1.col), vl.keys(colenc2.col)),\n    dist = 0;\n\n  cols.forEach(function(col) {\n    var e1 = colenc1.col[col], e2 = colenc2.col[col];\n\n    if (e1 && e2) {\n      if (e1.type != e2.type) {\n        dist += (DIST_BY_ENCTYPE[e1.type] || {})[e2.type] || 1;\n      }\n      //FIXME add aggregation\n    } else {\n      dist += DIST_MISSING;\n    }\n  });\n  return dist;\n};\n\nvgn.getDistanceTable = function(encodings) {\n  var len = encodings.length,\n    colencs = encodings.map(function(e){ return colenc(e);}),\n    diff = new Array(len), i;\n\n  for (i = 0; i < len; i++) diff[i] = new Array(len);\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      diff[j][i] = diff[i][j] = vgn._getDistance(colencs[i], colencs[j]);\n    }\n  }\n  return diff;\n};\n\nvgn.cluster = function(encodings, maxDistance) {\n  var dist = vgn.getDistanceTable(encodings),\n    n = encodings.length;\n\n  var clusterTrees = clusterfck.hcluster(range(n), function(i, j) {\n    return dist[i][j];\n  }, \"average\", CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n    return traverse(tree, []);\n  });\n\n  //console.log(\"clusters\", clusters.map(function(c){ return c.join(\"+\"); }));\n  return clusters;\n};\n\nfunction traverse(node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) traverse(node.left, arr);\n    if (node.right) traverse(node.right, arr);\n  }\n  return arr;\n}\n\n// End of Clustering\n\n\n// BEGINING OF RULES\n\n//TODO markTypesAggregateSupport\n\nvar marksRule = vgn.marksRule = generalRule;\nmarksRule.point = pointRule;\nmarksRule.bar = barRule;\nmarksRule.line = lineRule;\nmarksRule.area = lineRule;\n\nfunction isDim(field){\n  return field.bin || field.type === \"O\";\n}\n\nfunction xOyQ(enc) {\n  return enc.x && enc.y && isDim(enc.x) && isDim(enc.y);\n}\n\nfunction generalRule(enc, opt) {\n  // need at least one basic encoding\n  if (enc.x || enc.y || enc.geo || enc.text || enc.arc) {\n\n    if (enc.x && enc.y) {\n      // show only one OxO, QxQ\n      if (opt.omitTranpose && enc.x.type == enc.y.type) {\n        //TODO better criteria than name\n        if (enc.x.name > enc.y.name) return false;\n      }\n    }\n\n    if (enc.row || enc.col) { //have facet(s)\n      // don't use facets before filling up x,y\n      if ((!enc.x || !enc.y)) return false;\n\n      if (opt.omitAggrWithAllDimsOnFacets) {\n        // don't use facet with aggregate plot with other other ordinal on LOD\n\n        var hasAggr = false, hasOtherO = false;\n        for (var encType in enc) {\n          var field = enc[encType];\n          if (field.aggr) {\n            hasAggr = true;\n          }\n          if (isDim(field) && (encType !== \"row\" && encType !== \"col\")) {\n            hasOtherO = true;\n          }\n          if (hasAggr && hasOtherO) break;\n        }\n\n        if (hasAggr && !hasOtherO) return false;\n      }\n    }\n\n    // one dimension \"count\" is useless\n    if (enc.x && enc.x.aggr == \"count\" && !enc.y) return false;\n    if (enc.y && enc.y.aggr == \"count\" && !enc.x) return false;\n\n    return true;\n  }\n  return false;\n}\n\nfunction pointRule(enc, opt) {\n  if (enc.x && enc.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    // For OxQ\n    if (opt.omitTranpose && xOyQ(enc)) {\n      // if omitTranpose, put Q on X, O on Y\n      return false;\n    }\n\n    // For OxO\n    if (isDim(enc.x) && isDim(enc.y)) {\n      // shape doesn't work with both x, y as ordinal\n      if (enc.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (enc.color && isDim(enc.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (enc.shape) return false;\n  }\n  return true;\n}\n\nfunction barRule(enc, opt) {\n  // need to aggregate on either x or y\n  if ((enc.x.aggr !== undefined) ^ (enc.y.aggr !== undefined)) {\n\n    // if omitTranpose, put Q on X, O on Y\n    if (opt.omitTranpose && xOyQ(enc)) return false;\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction lineRule(enc, opt) {\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return enc.x == \"T\" && enc.y == \"Q\";\n}\n\nvar ENCODING_RULES = {\n  x: {\n    dataTypes: vl.dataTypes.O + vl.dataTypes.Q + vl.dataTypes.T,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dataTypes: vl.dataTypes.O + vl.dataTypes.Q + vl.dataTypes.T,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dataTypes: vl.dataTypes.O,\n    multiple: true\n  },\n  col: {\n    dataTypes: vl.dataTypes.O,\n    multiple: true\n  },\n  shape: {\n    dataTypes: vl.dataTypes.O\n  },\n  size: {\n    dataTypes: vl.dataTypes.Q\n  },\n  color: {\n    dataTypes: vl.dataTypes.O + vl.dataTypes.Q\n  },\n  alpha: {\n    dataTypes: vl.dataTypes.Q\n  },\n  text: {\n    dataTypes: ANY_DATA_TYPES\n  }\n  //geo: {\n  //  dataTypes: [vl.dataTypes.G]\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\n// END OF RULES\n\n// Beginning of Chart Generation\n\nvar nonEmpty = function(grp) {\n  return !isArray(grp) || grp.length > 0;\n};\n\nfunction nestedMap(col, f, level, filter) {\n  return level === 0 ?\n    col.map(f) :\n    col.map(function(v) {\n      var r = nestedMap(v, f, level - 1);\n      return filter ? r.filter(nonEmpty) : r;\n    });\n}\n\nfunction nestedReduce(col, f, level, filter) {\n  return level === 0 ?\n    col.reduce(f, []) :\n    col.map(function(v) {\n      var r = nestedReduce(v, f, level - 1);\n      return filter ? r.filter(nonEmpty) : r;\n    });\n}\n\nfunction getopt(opt) {\n  //merge with default\n  return (opt ? vl.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(vgn.DEFAULT_OPT));\n}\n\nvgn.generateCharts = function(fields, opt, cfg, flat) {\n  opt = getopt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? vgn.genAggregate([], fields, opt) : [fields],\n    encodings, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggr)) {\n    encodings = fieldSets.reduce(function(output, fields) {\n      return vgn.genFieldEncodings(output, fields, opt);\n    }, []);\n  } else {\n    encodings = fieldSets.map(function(fields) {\n      return vgn.genFieldEncodings([], fields, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = nestedReduce(encodings, function(output, encodings) {\n      return vgn.genMarkTypes(output, encodings, opt, cfg);\n    }, level, true);\n  } else {\n    charts = nestedMap(encodings, function(encodings) {\n      return vgn.genMarkTypes([], encodings, opt, cfg);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};\n\n\nvgn.genMarkTypes = function(output, enc, opt, cfg) {\n  opt = getopt(opt);\n  vgn._getSupportedMarkTypes(enc, opt)\n    .forEach(function(markType) {\n      output.push({ marktype: markType, enc: enc, cfg: cfg });\n    });\n  return output;\n};\n\n//TODO(kanitw): write test case\nvgn._getSupportedMarkTypes = function(enc, opt) {\n  var markTypes = opt.marktypeList.filter(function(markType) {\n    var mark = vl.marks[markType],\n      reqs = mark.requiredEncoding,\n      support = mark.supportedEncoding;\n\n    for (var i in reqs) { // all required encodings in enc\n      if (!(reqs[i] in enc)) return false;\n    }\n\n    for (var encType in enc) { // all encodings in enc are supported\n      if (!support[encType]) return false;\n    }\n\n    return !marksRule[markType] || marksRule[markType](enc, opt);\n  });\n\n  //console.log('enc:', json(enc), \" ~ marks:\", markTypes);\n\n  return markTypes;\n};\n\nvgn.genAggregate = function(output, fields, opt) {\n  var tf = new Array(fields.length);\n  opt = getopt(opt);\n\n  function assignField(i, hasAggr) {\n    // If all fields are assigned, save\n    if (i === fields.length) {\n      if(opt.omitAggregateWithMeasureOnly || opt.omitDimensionOnly){\n        var hasMeasure=false, hasDimension=false, hasRaw=false;\n        tf.forEach(function(f){\n          if (isDim(f)) {\n            hasDimension = true;\n          } else {\n            hasMeasure = true;\n            if(!f.aggr) hasRaw = true;\n          }\n        });\n        if(!hasMeasure && opt.omitDimensionOnly) return;\n        if(!hasDimension && !hasRaw && opt.omitAggregateWithMeasureOnly) return;\n      }\n\n      output.push(vl.duplicate(tf));\n      return;\n    }\n\n    var f = fields[i];\n\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case \"Q\":\n        tf[i] = {name: f.name, type: f.type};\n        if (f.aggr) {\n          tf[i].aggr = f.aggr;\n          assignField(i + 1, true);\n        } else if (f._aggr) {\n          var aggregates = f._aggr == \"*\" ? opt.aggrList : f._aggr;\n\n          for (var j in aggregates) {\n            var a = aggregates[j];\n            if (a !== undefined) {\n              if (hasAggr === true || hasAggr === null) {\n                // must be aggregated, or no constraint\n                //set aggregate to that one\n                tf[i].aggr = a;\n                assignField(i + 1, true);\n              }\n            } else { // if(a === undefined)\n              if (hasAggr === false || hasAggr === null) {\n                // must be raw plot, or no constraint\n                delete tf[i].aggr;\n                assignField(i + 1, false);\n              }\n            }\n          }\n\n          if (opt.genBin) {\n            // bin the field instead!\n            delete tf[i].aggr;\n            tf[i].bin = true;\n            tf[i].type = \"Q\";\n            assignField(i + 1, hasAggr);\n          }\n\n          if (opt.genTypeCasting) {\n            // we can also change it to dimension (cast type=\"O\")\n            delete tf[i].aggr;\n            delete tf[i].bin;\n            tf[i].type = \"O\";\n            assignField(i + 1, hasAggr);\n          }\n        } else { // both \"aggr\", \"_aggr\" not in f\n          assignField(i + 1, false);\n        }\n        break;\n\n      case \"O\":\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr);\n        break;\n    }\n\n  }\n\n  assignField(0, null);\n\n  return output;\n};\n\n//TODO(kanitw): write test case\nvgn.genFieldEncodings = function(encodings, fields, opt) { // generate encodings (_enc property in vega)\n  var tmpEnc = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fields.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (marksRule(tmpEnc, opt)) {\n        encodings.push(vl.duplicate(tmpEnc));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var field = fields[i];\n    for (var j in ENCODING_TYPES) {\n      var et = ENCODING_TYPES[j];\n\n      //TODO: support \"multiple\" assignment\n      if (!(et in tmpEnc) &&\n        (ENCODING_RULES[et].dataTypes & vl.dataTypes[field.type]) > 0) {\n        tmpEnc[et] = field;\n        assignField(i + 1);\n        delete tmpEnc[et];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encodings;\n};\n\n// UTILITY\n\nvar isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nfunction union(a, b) {\n  var o = {};\n  a.forEach(function(x){ o[x] = true;});\n  b.forEach(function(x){ o[x] = true;});\n  return vl.keys(o);\n}\n\nvar abs = Math.abs;\n\nfunction range(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n  var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;\n  start *= k; stop *= k; step *= k;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);\n  return range;\n}\n\nfunction d3_range_integerScale(x) {\n  var k = 1;\n  while (x * k % 1) k *= 10;\n  return k;\n}\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],3:[function(require,module,exports){\n(function (global){\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null);\n\nvar vrank = module.exports = {};\n\n//TODO lower score if we use G as O?\nvar ENCODING_SCORE = {\n  Q: {\n    x: 1,\n    y: 1,\n    size: 0.6, //FIXME SIZE for Bar is horrible!\n    color: 0.4,\n    alpha: 0.4\n  },\n  O: { // TODO need to take cardinality into account\n    x: 0.99, // harder to read axis\n    y: 1,\n    row: 0.7,\n    col: 0.7,\n    color: 0.8,\n    shape: 0.6\n  }\n};\n\n// bad score not specified in the table above\nvar BAD_ENCODING_SCORE = 0.01,\n  UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  point: 0.96,\n  circle: 0.95,\n  square: 0.95,\n  text: 0.8\n};\n\nvrank.encodingScore = function(encoding){\n  var features = {},\n    encTypes = vl.keys(encoding.enc);\n  encTypes.forEach(function(encType){\n    var field = encoding.enc[encType];\n    features[field.name] = {\n      value: field.type+\":\"+encType,\n      score: ENCODING_SCORE[field.type][encType] || BAD_ENCODING_SCORE\n    };\n  });\n\n  // penalize not using positional\n  if(encTypes.length > 1){\n    if((!encoding.enc.x || !encoding.enc.y) && !encoding.enc.geo) {\n      features.unusedPosition = {score: UNUSED_POSITION};\n    }\n  }\n\n  features.markType = {\n    value: encoding.marktype,\n    score: MARK_SCORE[encoding.marktype]\n  }\n\n  return {\n    score: vl.keys(features).reduce(function(p, s){ return p * features[s].score}, 1),\n    features: features\n  };\n};\n\n\n// raw > avg, sum > min,max > bin\n\nvrank.fieldsScore = function(fields){\n\n};\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvdnIiLCJzcmMvdmlzZ2VuLmpzIiwic3JjL3Zpc3JhbmsuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3prQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgdnIgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52ci5nZW4gPSByZXF1aXJlKCcuL3Zpc2dlbicpO1xudnIucmFuayA9IHJlcXVpcmUoJy4vdmlzcmFuaycpO1xuXG4iLCJ2YXIgdmwgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy52bCA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudmwgOiBudWxsKSxcbiAgY2x1c3RlcmZjayA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmNsdXN0ZXJmY2sgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmNsdXN0ZXJmY2sgOiBudWxsKTtcblxudmFyIHZnbiA9IG1vZHVsZS5leHBvcnRzID0ge307IC8vVmlzR2VOXG5cbnZnbi5ERUZBVUxUX09QVCA9IHtcbiAgZ2VuQWdncjogdHJ1ZSxcbiAgZ2VuQmluOiB0cnVlLFxuICBnZW5UeXBlQ2FzdGluZzogZmFsc2UsXG5cbiAgYWdnckxpc3Q6IFt1bmRlZmluZWQsIFwiYXZnXCJdLCAvL3VuZGVmaW5lZCA9IG5vIGFnZ3JlZ2F0aW9uXG4gIG1hcmt0eXBlTGlzdDogW1wicG9pbnRcIiwgXCJiYXJcIiwgXCJsaW5lXCIsIFwiYXJlYVwiLCBcInRleHRcIl0sIC8vZmlsbGVkX21hcFxuXG4gIC8vIFBSVU5JTkcgUlVMRVMgRk9SIEVOQ09ESU5HIFZBUklBVElPTlNcblxuICAvKipcbiAgICogRWxpbWluYXRlIGFsbCB0cmFuc3Bvc2VcbiAgICogLSBrZWVwaW5nIGhvcml6b250YWwgZG90IHBsb3Qgb25seS5cbiAgICogLSBmb3IgT3hRIGNoYXJ0cywgYWx3YXlzIHB1dCBPIG9uIFlcbiAgICogLSBzaG93IG9ubHkgb25lIE94TywgUXhRIChjdXJyZW50bHkgc29ydGVkIGJ5IG5hbWUpXG4gICAqL1xuICBvbWl0VHJhbnBvc2U6IHRydWUsXG4gIC8qKiByZW1vdmUgYWxsIGRvdCBwbG90IHdpdGggPjEgZW5jb2RpbmcgKi9cbiAgb21pdERvdFBsb3RXaXRoRXh0cmFFbmNvZGluZzogdHJ1ZSxcblxuICAvKiogcmVtb3ZlIGFsbCBhZ2dyZWdhdGUgY2hhcnRzIHdpdGggYWxsIGRpbXMgb24gZmFjZXRzIChyb3csIGNvbCkgKi9cbiAgLy9GSVhNRSB0aGlzIGlzIGdvb2QgZm9yIHRleHQgdGhvdWdoIVxuICBvbWl0QWdncldpdGhBbGxEaW1zT25GYWNldHM6IHRydWUsXG5cbiAgLy8gUFJVTklORyBSVUxFUyBGT1IgVFJBTkZPUk1BVElPTiBWQVJJQVRJT05TXG5cbiAgLyoqIG9taXQgZmllbGQgc2V0cyB3aXRoIG9ubHkgZGltZW5zaW9ucyAqL1xuICBvbWl0RGltZW5zaW9uT25seTogdHJ1ZSxcbiAgLyoqIG9taXQgYWdncmVnYXRlIGZpZWxkIHNldHMgd2l0aCBvbmx5IG1lYXN1cmVzICovXG4gIG9taXRBZ2dyZWdhdGVXaXRoTWVhc3VyZU9ubHk6IHRydWVcblxufTtcblxudmFyIEVOQ09ESU5HX1RZUEVTID0gdmwuZW5jb2RpbmdUeXBlcztcblxudmFyIENIQVJUX1RZUEVTID0ge1xuICBUQUJMRTogJ1RBQkxFJyxcbiAgQkFSOiAnQkFSJyxcbiAgUExPVDogJ1BMT1QnLFxuICBMSU5FOiAnTElORScsXG4gIEFSRUE6ICdBUkVBJyxcbiAgTUFQOiAnTUFQJyxcbiAgSElTVE9HUkFNOiAnSElTVE9HUkFNJ1xufTtcblxudmFyIEFOWV9EQVRBX1RZUEVTID0gKDEgPDwgNCkgLSAxO1xuXG4vL0ZJWE1FIG1vdmUgdGhlc2UgdG8gdmxcbnZhciBBR0dSRUdBVElPTl9GTiA9IHsgLy9hbGwgcG9zc2libGUgYWdncmVnYXRlIGZ1bmN0aW9uIGxpc3RlZCBieSBlYWNoIGRhdGEgdHlwZVxuICBROiBbXCJhdmdcIiwgXCJzdW1cIiwgXCJtaW5cIiwgXCJtYXhcIiwgXCJjb3VudFwiXVxufTtcblxudmFyIFRSQU5TRk9STV9GTiA9IHsgLy9hbGwgcG9zc2libGUgdHJhbnNmb3JtIGZ1bmN0aW9uIGxpc3RlZCBieSBlYWNoIGRhdGEgdHlwZVxuICBROiBbXCJsb2dcIiwgXCJzcXJ0XCIsIFwiYWJzXCJdLCAvLyBcImxvZ2l0P1wiXG4gIFQ6IFtcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiXSAvLyxcImhyXCIsIFwibWluXCIsIFwiYm1vblwiLCBcImJkYXlcIiwgXCJiZG93XCIsIFwiYmhyXCJdXG59O1xuXG52YXIganNvbiA9IGZ1bmN0aW9uKHMsc3ApeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkocywgbnVsbCwgc3ApO307XG5cbi8vIEJlZ2luIG9mIERpc3RhbmNlXG5cbnZhciBESVNUX0JZX0VOQ1RZUEUgPSBbXG4gICAgLy8gcG9zaXRpb25hbFxuICAgIFtcInhcIiwgXCJ5XCIsIDAuMl0sXG4gICAgW1wicm93XCIsIFwiY29sXCIsIDAuMl0sXG5cbiAgICAvLyBvcmRpbmFsIG1hcmsgcHJvcGVydGllc1xuICAgIFtcImNvbG9yXCIsIFwic2hhcGVcIiwgMC4yXSxcblxuICAgIC8vIHF1YW50aXRhdGl2ZSBtYXJrIHByb3BlcnRpZXNcbiAgICBbXCJjb2xvclwiLCBcImFscGhhXCIsIDAuMl0sXG4gICAgW1wic2l6ZVwiLCBcImFscGhhXCIsIDAuMl0sXG4gICAgW1wic2l6ZVwiLCBcImNvbG9yXCIsIDAuMl1cbiAgXS5yZWR1Y2UoZnVuY3Rpb24ociwgeCkge1xuICB2YXIgYT14WzBdLCBiPXhbMV0sIGQ9eFsyXTtcbiAgICByW2FdID0gclthXSB8fCB7fTtcbiAgICByW2JdID0gcltiXSB8fCB7fTtcbiAgICByW2FdW2JdID0gcltiXVthXSA9IGQ7XG4gICAgcmV0dXJuIHI7XG4gIH0sIHt9KSxcbiAgRElTVF9NSVNTSU5HID0gMTAwLCBDTFVTVEVSX1RIUkVTSE9MRD0xO1xuXG5mdW5jdGlvbiBjb2xlbmMoZW5jb2RpbmcpIHtcbiAgdmFyIF9jb2xlbmMgPSB7fSxcbiAgICBlbmMgPSBlbmNvZGluZy5lbmM7XG5cbiAgdmwua2V5cyhlbmMpLmZvckVhY2goZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHZhciBlID0gdmwuZHVwbGljYXRlKGVuY1tlbmNUeXBlXSk7XG4gICAgZS50eXBlID0gZW5jVHlwZTtcbiAgICBfY29sZW5jW2UubmFtZSB8fCBcIlwiXSA9IGU7XG4gICAgZGVsZXRlIGUubmFtZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtYXJrdHlwZTogZW5jb2RpbmcubWFya3R5cGUsXG4gICAgY29sOiBfY29sZW5jXG4gIH07XG59XG5cbnZnbi5fZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbihjb2xlbmMxLCBjb2xlbmMyKSB7XG4gIHZhciBjb2xzID0gdW5pb24odmwua2V5cyhjb2xlbmMxLmNvbCksIHZsLmtleXMoY29sZW5jMi5jb2wpKSxcbiAgICBkaXN0ID0gMDtcblxuICBjb2xzLmZvckVhY2goZnVuY3Rpb24oY29sKSB7XG4gICAgdmFyIGUxID0gY29sZW5jMS5jb2xbY29sXSwgZTIgPSBjb2xlbmMyLmNvbFtjb2xdO1xuXG4gICAgaWYgKGUxICYmIGUyKSB7XG4gICAgICBpZiAoZTEudHlwZSAhPSBlMi50eXBlKSB7XG4gICAgICAgIGRpc3QgKz0gKERJU1RfQllfRU5DVFlQRVtlMS50eXBlXSB8fCB7fSlbZTIudHlwZV0gfHwgMTtcbiAgICAgIH1cbiAgICAgIC8vRklYTUUgYWRkIGFnZ3JlZ2F0aW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3QgKz0gRElTVF9NSVNTSU5HO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkaXN0O1xufTtcblxudmduLmdldERpc3RhbmNlVGFibGUgPSBmdW5jdGlvbihlbmNvZGluZ3MpIHtcbiAgdmFyIGxlbiA9IGVuY29kaW5ncy5sZW5ndGgsXG4gICAgY29sZW5jcyA9IGVuY29kaW5ncy5tYXAoZnVuY3Rpb24oZSl7IHJldHVybiBjb2xlbmMoZSk7fSksXG4gICAgZGlmZiA9IG5ldyBBcnJheShsZW4pLCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgZGlmZltpXSA9IG5ldyBBcnJheShsZW4pO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGRpZmZbal1baV0gPSBkaWZmW2ldW2pdID0gdmduLl9nZXREaXN0YW5jZShjb2xlbmNzW2ldLCBjb2xlbmNzW2pdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59O1xuXG52Z24uY2x1c3RlciA9IGZ1bmN0aW9uKGVuY29kaW5ncywgbWF4RGlzdGFuY2UpIHtcbiAgdmFyIGRpc3QgPSB2Z24uZ2V0RGlzdGFuY2VUYWJsZShlbmNvZGluZ3MpLFxuICAgIG4gPSBlbmNvZGluZ3MubGVuZ3RoO1xuXG4gIHZhciBjbHVzdGVyVHJlZXMgPSBjbHVzdGVyZmNrLmhjbHVzdGVyKHJhbmdlKG4pLCBmdW5jdGlvbihpLCBqKSB7XG4gICAgcmV0dXJuIGRpc3RbaV1bal07XG4gIH0sIFwiYXZlcmFnZVwiLCBDTFVTVEVSX1RIUkVTSE9MRCk7XG5cbiAgdmFyIGNsdXN0ZXJzID0gY2x1c3RlclRyZWVzLm1hcChmdW5jdGlvbih0cmVlKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlKHRyZWUsIFtdKTtcbiAgfSk7XG5cbiAgLy9jb25zb2xlLmxvZyhcImNsdXN0ZXJzXCIsIGNsdXN0ZXJzLm1hcChmdW5jdGlvbihjKXsgcmV0dXJuIGMuam9pbihcIitcIik7IH0pKTtcbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxuZnVuY3Rpb24gdHJhdmVyc2Uobm9kZSwgYXJyKSB7XG4gIGlmIChub2RlLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBhcnIucHVzaChub2RlLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobm9kZS5sZWZ0KSB0cmF2ZXJzZShub2RlLmxlZnQsIGFycik7XG4gICAgaWYgKG5vZGUucmlnaHQpIHRyYXZlcnNlKG5vZGUucmlnaHQsIGFycik7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLy8gRW5kIG9mIENsdXN0ZXJpbmdcblxuXG4vLyBCRUdJTklORyBPRiBSVUxFU1xuXG4vL1RPRE8gbWFya1R5cGVzQWdncmVnYXRlU3VwcG9ydFxuXG52YXIgbWFya3NSdWxlID0gdmduLm1hcmtzUnVsZSA9IGdlbmVyYWxSdWxlO1xubWFya3NSdWxlLnBvaW50ID0gcG9pbnRSdWxlO1xubWFya3NSdWxlLmJhciA9IGJhclJ1bGU7XG5tYXJrc1J1bGUubGluZSA9IGxpbmVSdWxlO1xubWFya3NSdWxlLmFyZWEgPSBsaW5lUnVsZTtcblxuZnVuY3Rpb24gaXNEaW0oZmllbGQpe1xuICByZXR1cm4gZmllbGQuYmluIHx8IGZpZWxkLnR5cGUgPT09IFwiT1wiO1xufVxuXG5mdW5jdGlvbiB4T3lRKGVuYykge1xuICByZXR1cm4gZW5jLnggJiYgZW5jLnkgJiYgaXNEaW0oZW5jLngpICYmIGlzRGltKGVuYy55KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhbFJ1bGUoZW5jLCBvcHQpIHtcbiAgLy8gbmVlZCBhdCBsZWFzdCBvbmUgYmFzaWMgZW5jb2RpbmdcbiAgaWYgKGVuYy54IHx8IGVuYy55IHx8IGVuYy5nZW8gfHwgZW5jLnRleHQgfHwgZW5jLmFyYykge1xuXG4gICAgaWYgKGVuYy54ICYmIGVuYy55KSB7XG4gICAgICAvLyBzaG93IG9ubHkgb25lIE94TywgUXhRXG4gICAgICBpZiAob3B0Lm9taXRUcmFucG9zZSAmJiBlbmMueC50eXBlID09IGVuYy55LnR5cGUpIHtcbiAgICAgICAgLy9UT0RPIGJldHRlciBjcml0ZXJpYSB0aGFuIG5hbWVcbiAgICAgICAgaWYgKGVuYy54Lm5hbWUgPiBlbmMueS5uYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuYy5yb3cgfHwgZW5jLmNvbCkgeyAvL2hhdmUgZmFjZXQocylcbiAgICAgIC8vIGRvbid0IHVzZSBmYWNldHMgYmVmb3JlIGZpbGxpbmcgdXAgeCx5XG4gICAgICBpZiAoKCFlbmMueCB8fCAhZW5jLnkpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGlmIChvcHQub21pdEFnZ3JXaXRoQWxsRGltc09uRmFjZXRzKSB7XG4gICAgICAgIC8vIGRvbid0IHVzZSBmYWNldCB3aXRoIGFnZ3JlZ2F0ZSBwbG90IHdpdGggb3RoZXIgb3RoZXIgb3JkaW5hbCBvbiBMT0RcblxuICAgICAgICB2YXIgaGFzQWdnciA9IGZhbHNlLCBoYXNPdGhlck8gPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgZW5jVHlwZSBpbiBlbmMpIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSBlbmNbZW5jVHlwZV07XG4gICAgICAgICAgaWYgKGZpZWxkLmFnZ3IpIHtcbiAgICAgICAgICAgIGhhc0FnZ3IgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNEaW0oZmllbGQpICYmIChlbmNUeXBlICE9PSBcInJvd1wiICYmIGVuY1R5cGUgIT09IFwiY29sXCIpKSB7XG4gICAgICAgICAgICBoYXNPdGhlck8gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzQWdnciAmJiBoYXNPdGhlck8pIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0FnZ3IgJiYgIWhhc090aGVyTykgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG9uZSBkaW1lbnNpb24gXCJjb3VudFwiIGlzIHVzZWxlc3NcbiAgICBpZiAoZW5jLnggJiYgZW5jLnguYWdnciA9PSBcImNvdW50XCIgJiYgIWVuYy55KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGVuYy55ICYmIGVuYy55LmFnZ3IgPT0gXCJjb3VudFwiICYmICFlbmMueCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwb2ludFJ1bGUoZW5jLCBvcHQpIHtcbiAgaWYgKGVuYy54ICYmIGVuYy55KSB7XG4gICAgLy8gaGF2ZSBib3RoIHggJiB5ID09PiBzY2F0dGVyIHBsb3QgLyBidWJibGUgcGxvdFxuXG4gICAgLy8gRm9yIE94UVxuICAgIGlmIChvcHQub21pdFRyYW5wb3NlICYmIHhPeVEoZW5jKSkge1xuICAgICAgLy8gaWYgb21pdFRyYW5wb3NlLCBwdXQgUSBvbiBYLCBPIG9uIFlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGb3IgT3hPXG4gICAgaWYgKGlzRGltKGVuYy54KSAmJiBpc0RpbShlbmMueSkpIHtcbiAgICAgIC8vIHNoYXBlIGRvZXNuJ3Qgd29yayB3aXRoIGJvdGggeCwgeSBhcyBvcmRpbmFsXG4gICAgICBpZiAoZW5jLnNoYXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyhrYW5pdHcpOiBjaGVjayB0aGF0IHRoZXJlIGlzIHF1YW50IGF0IGxlYXN0IC4uLlxuICAgICAgaWYgKGVuYy5jb2xvciAmJiBpc0RpbShlbmMuY29sb3IpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIHsgLy8gcGxvdCB3aXRoIG9uZSBheGlzID0gZG90IHBsb3RcbiAgICAvLyBEb3QgcGxvdCBzaG91bGQgYWx3YXlzIGJlIGhvcml6b250YWxcbiAgICBpZiAob3B0Lm9taXRUcmFucG9zZSAmJiBlbmMueSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gZG90IHBsb3Qgc2hvdWxkbid0IGhhdmUgb3RoZXIgZW5jb2RpbmdcbiAgICBpZiAob3B0Lm9taXREb3RQbG90V2l0aEV4dHJhRW5jb2RpbmcgJiYgdmwua2V5cyhlbmMpLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGRvdCBwbG90IHdpdGggc2hhcGUgaXMgbm9uLXNlbnNlXG4gICAgaWYgKGVuYy5zaGFwZSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYXJSdWxlKGVuYywgb3B0KSB7XG4gIC8vIG5lZWQgdG8gYWdncmVnYXRlIG9uIGVpdGhlciB4IG9yIHlcbiAgaWYgKChlbmMueC5hZ2dyICE9PSB1bmRlZmluZWQpIF4gKGVuYy55LmFnZ3IgIT09IHVuZGVmaW5lZCkpIHtcblxuICAgIC8vIGlmIG9taXRUcmFucG9zZSwgcHV0IFEgb24gWCwgTyBvbiBZXG4gICAgaWYgKG9wdC5vbWl0VHJhbnBvc2UgJiYgeE95UShlbmMpKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGluZVJ1bGUoZW5jLCBvcHQpIHtcbiAgLy8gVE9ETyhrYW5pdHcpOiBhZGQgb21pdFZlcnRpY2FsTGluZSBhcyBjb25maWdcblxuICAvLyBMaW5lIGNoYXJ0IHNob3VsZCBiZSBvbmx5IGhvcml6b250YWxcbiAgLy8gYW5kIHVzZSBvbmx5IHRlbXBvcmFsIGRhdGFcbiAgcmV0dXJuIGVuYy54ID09IFwiVFwiICYmIGVuYy55ID09IFwiUVwiO1xufVxuXG52YXIgRU5DT0RJTkdfUlVMRVMgPSB7XG4gIHg6IHtcbiAgICBkYXRhVHlwZXM6IHZsLmRhdGFUeXBlcy5PICsgdmwuZGF0YVR5cGVzLlEgKyB2bC5kYXRhVHlwZXMuVCxcbiAgICBtdWx0aXBsZTogdHJ1ZSAvL0ZJWE1FIHNob3VsZCBhbGxvdyBtdWx0aXBsZSBvbmx5IGZvciBRLCBUXG4gIH0sXG4gIHk6IHtcbiAgICBkYXRhVHlwZXM6IHZsLmRhdGFUeXBlcy5PICsgdmwuZGF0YVR5cGVzLlEgKyB2bC5kYXRhVHlwZXMuVCxcbiAgICBtdWx0aXBsZTogdHJ1ZSAvL0ZJWE1FIHNob3VsZCBhbGxvdyBtdWx0aXBsZSBvbmx5IGZvciBRLCBUXG4gIH0sXG4gIHJvdzoge1xuICAgIGRhdGFUeXBlczogdmwuZGF0YVR5cGVzLk8sXG4gICAgbXVsdGlwbGU6IHRydWVcbiAgfSxcbiAgY29sOiB7XG4gICAgZGF0YVR5cGVzOiB2bC5kYXRhVHlwZXMuTyxcbiAgICBtdWx0aXBsZTogdHJ1ZVxuICB9LFxuICBzaGFwZToge1xuICAgIGRhdGFUeXBlczogdmwuZGF0YVR5cGVzLk9cbiAgfSxcbiAgc2l6ZToge1xuICAgIGRhdGFUeXBlczogdmwuZGF0YVR5cGVzLlFcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBkYXRhVHlwZXM6IHZsLmRhdGFUeXBlcy5PICsgdmwuZGF0YVR5cGVzLlFcbiAgfSxcbiAgYWxwaGE6IHtcbiAgICBkYXRhVHlwZXM6IHZsLmRhdGFUeXBlcy5RXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBkYXRhVHlwZXM6IEFOWV9EQVRBX1RZUEVTXG4gIH1cbiAgLy9nZW86IHtcbiAgLy8gIGRhdGFUeXBlczogW3ZsLmRhdGFUeXBlcy5HXVxuICAvL30sXG4gIC8vYXJjOiB7IC8vIHBpZVxuICAvL1xuICAvL31cbn07XG5cbi8vIEVORCBPRiBSVUxFU1xuXG4vLyBCZWdpbm5pbmcgb2YgQ2hhcnQgR2VuZXJhdGlvblxuXG52YXIgbm9uRW1wdHkgPSBmdW5jdGlvbihncnApIHtcbiAgcmV0dXJuICFpc0FycmF5KGdycCkgfHwgZ3JwLmxlbmd0aCA+IDA7XG59O1xuXG5mdW5jdGlvbiBuZXN0ZWRNYXAoY29sLCBmLCBsZXZlbCwgZmlsdGVyKSB7XG4gIHJldHVybiBsZXZlbCA9PT0gMCA/XG4gICAgY29sLm1hcChmKSA6XG4gICAgY29sLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgciA9IG5lc3RlZE1hcCh2LCBmLCBsZXZlbCAtIDEpO1xuICAgICAgcmV0dXJuIGZpbHRlciA/IHIuZmlsdGVyKG5vbkVtcHR5KSA6IHI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG5lc3RlZFJlZHVjZShjb2wsIGYsIGxldmVsLCBmaWx0ZXIpIHtcbiAgcmV0dXJuIGxldmVsID09PSAwID9cbiAgICBjb2wucmVkdWNlKGYsIFtdKSA6XG4gICAgY29sLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgciA9IG5lc3RlZFJlZHVjZSh2LCBmLCBsZXZlbCAtIDEpO1xuICAgICAgcmV0dXJuIGZpbHRlciA/IHIuZmlsdGVyKG5vbkVtcHR5KSA6IHI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldG9wdChvcHQpIHtcbiAgLy9tZXJnZSB3aXRoIGRlZmF1bHRcbiAgcmV0dXJuIChvcHQgPyB2bC5rZXlzKG9wdCkgOiBbXSkucmVkdWNlKGZ1bmN0aW9uKGMsIGspIHtcbiAgICBjW2tdID0gb3B0W2tdO1xuICAgIHJldHVybiBjO1xuICB9LCBPYmplY3QuY3JlYXRlKHZnbi5ERUZBVUxUX09QVCkpO1xufVxuXG52Z24uZ2VuZXJhdGVDaGFydHMgPSBmdW5jdGlvbihmaWVsZHMsIG9wdCwgY2ZnLCBmbGF0KSB7XG4gIG9wdCA9IGdldG9wdChvcHQpO1xuICBmbGF0ID0gZmxhdCA9PT0gdW5kZWZpbmVkID8ge2VuY29kaW5nczogMX0gOiBmbGF0O1xuXG4gIC8vIFRPRE8gZ2VuZXJhdGVcblxuICAvLyBnZW5lcmF0ZSBwZXJtdXRhdGlvbiBvZiBlbmNvZGluZyBtYXBwaW5nc1xuICB2YXIgZmllbGRTZXRzID0gb3B0LmdlbkFnZ3IgPyB2Z24uZ2VuQWdncmVnYXRlKFtdLCBmaWVsZHMsIG9wdCkgOiBbZmllbGRzXSxcbiAgICBlbmNvZGluZ3MsIGNoYXJ0cywgbGV2ZWwgPSAwO1xuXG4gIGlmIChmbGF0ID09PSB0cnVlIHx8IChmbGF0ICYmIGZsYXQuYWdncikpIHtcbiAgICBlbmNvZGluZ3MgPSBmaWVsZFNldHMucmVkdWNlKGZ1bmN0aW9uKG91dHB1dCwgZmllbGRzKSB7XG4gICAgICByZXR1cm4gdmduLmdlbkZpZWxkRW5jb2RpbmdzKG91dHB1dCwgZmllbGRzLCBvcHQpO1xuICAgIH0sIFtdKTtcbiAgfSBlbHNlIHtcbiAgICBlbmNvZGluZ3MgPSBmaWVsZFNldHMubWFwKGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgcmV0dXJuIHZnbi5nZW5GaWVsZEVuY29kaW5ncyhbXSwgZmllbGRzLCBvcHQpO1xuICAgIH0sIHRydWUpO1xuICAgIGxldmVsICs9IDE7XG4gIH1cblxuICBpZiAoZmxhdCA9PT0gdHJ1ZSB8fCAoZmxhdCAmJiBmbGF0LmVuY29kaW5ncykpIHtcbiAgICBjaGFydHMgPSBuZXN0ZWRSZWR1Y2UoZW5jb2RpbmdzLCBmdW5jdGlvbihvdXRwdXQsIGVuY29kaW5ncykge1xuICAgICAgcmV0dXJuIHZnbi5nZW5NYXJrVHlwZXMob3V0cHV0LCBlbmNvZGluZ3MsIG9wdCwgY2ZnKTtcbiAgICB9LCBsZXZlbCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnRzID0gbmVzdGVkTWFwKGVuY29kaW5ncywgZnVuY3Rpb24oZW5jb2RpbmdzKSB7XG4gICAgICByZXR1cm4gdmduLmdlbk1hcmtUeXBlcyhbXSwgZW5jb2RpbmdzLCBvcHQsIGNmZyk7XG4gICAgfSwgbGV2ZWwsIHRydWUpO1xuICAgIGxldmVsICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0cztcbn07XG5cblxudmduLmdlbk1hcmtUeXBlcyA9IGZ1bmN0aW9uKG91dHB1dCwgZW5jLCBvcHQsIGNmZykge1xuICBvcHQgPSBnZXRvcHQob3B0KTtcbiAgdmduLl9nZXRTdXBwb3J0ZWRNYXJrVHlwZXMoZW5jLCBvcHQpXG4gICAgLmZvckVhY2goZnVuY3Rpb24obWFya1R5cGUpIHtcbiAgICAgIG91dHB1dC5wdXNoKHsgbWFya3R5cGU6IG1hcmtUeXBlLCBlbmM6IGVuYywgY2ZnOiBjZmcgfSk7XG4gICAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vL1RPRE8oa2FuaXR3KTogd3JpdGUgdGVzdCBjYXNlXG52Z24uX2dldFN1cHBvcnRlZE1hcmtUeXBlcyA9IGZ1bmN0aW9uKGVuYywgb3B0KSB7XG4gIHZhciBtYXJrVHlwZXMgPSBvcHQubWFya3R5cGVMaXN0LmZpbHRlcihmdW5jdGlvbihtYXJrVHlwZSkge1xuICAgIHZhciBtYXJrID0gdmwubWFya3NbbWFya1R5cGVdLFxuICAgICAgcmVxcyA9IG1hcmsucmVxdWlyZWRFbmNvZGluZyxcbiAgICAgIHN1cHBvcnQgPSBtYXJrLnN1cHBvcnRlZEVuY29kaW5nO1xuXG4gICAgZm9yICh2YXIgaSBpbiByZXFzKSB7IC8vIGFsbCByZXF1aXJlZCBlbmNvZGluZ3MgaW4gZW5jXG4gICAgICBpZiAoIShyZXFzW2ldIGluIGVuYykpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBlbmNUeXBlIGluIGVuYykgeyAvLyBhbGwgZW5jb2RpbmdzIGluIGVuYyBhcmUgc3VwcG9ydGVkXG4gICAgICBpZiAoIXN1cHBvcnRbZW5jVHlwZV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gIW1hcmtzUnVsZVttYXJrVHlwZV0gfHwgbWFya3NSdWxlW21hcmtUeXBlXShlbmMsIG9wdCk7XG4gIH0pO1xuXG4gIC8vY29uc29sZS5sb2coJ2VuYzonLCBqc29uKGVuYyksIFwiIH4gbWFya3M6XCIsIG1hcmtUeXBlcyk7XG5cbiAgcmV0dXJuIG1hcmtUeXBlcztcbn07XG5cbnZnbi5nZW5BZ2dyZWdhdGUgPSBmdW5jdGlvbihvdXRwdXQsIGZpZWxkcywgb3B0KSB7XG4gIHZhciB0ZiA9IG5ldyBBcnJheShmaWVsZHMubGVuZ3RoKTtcbiAgb3B0ID0gZ2V0b3B0KG9wdCk7XG5cbiAgZnVuY3Rpb24gYXNzaWduRmllbGQoaSwgaGFzQWdncikge1xuICAgIC8vIElmIGFsbCBmaWVsZHMgYXJlIGFzc2lnbmVkLCBzYXZlXG4gICAgaWYgKGkgPT09IGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgIGlmKG9wdC5vbWl0QWdncmVnYXRlV2l0aE1lYXN1cmVPbmx5IHx8IG9wdC5vbWl0RGltZW5zaW9uT25seSl7XG4gICAgICAgIHZhciBoYXNNZWFzdXJlPWZhbHNlLCBoYXNEaW1lbnNpb249ZmFsc2UsIGhhc1Jhdz1mYWxzZTtcbiAgICAgICAgdGYuZm9yRWFjaChmdW5jdGlvbihmKXtcbiAgICAgICAgICBpZiAoaXNEaW0oZikpIHtcbiAgICAgICAgICAgIGhhc0RpbWVuc2lvbiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhc01lYXN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYoIWYuYWdncikgaGFzUmF3ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZighaGFzTWVhc3VyZSAmJiBvcHQub21pdERpbWVuc2lvbk9ubHkpIHJldHVybjtcbiAgICAgICAgaWYoIWhhc0RpbWVuc2lvbiAmJiAhaGFzUmF3ICYmIG9wdC5vbWl0QWdncmVnYXRlV2l0aE1lYXN1cmVPbmx5KSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG91dHB1dC5wdXNoKHZsLmR1cGxpY2F0ZSh0ZikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmID0gZmllbGRzW2ldO1xuXG4gICAgLy8gT3RoZXJ3aXNlLCBhc3NpZ24gaS10aCBmaWVsZFxuICAgIHN3aXRjaCAoZi50eXBlKSB7XG4gICAgICAvL1RPRE8gXCJEXCIsIFwiR1wiXG4gICAgICBjYXNlIFwiUVwiOlxuICAgICAgICB0ZltpXSA9IHtuYW1lOiBmLm5hbWUsIHR5cGU6IGYudHlwZX07XG4gICAgICAgIGlmIChmLmFnZ3IpIHtcbiAgICAgICAgICB0ZltpXS5hZ2dyID0gZi5hZ2dyO1xuICAgICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChmLl9hZ2dyKSB7XG4gICAgICAgICAgdmFyIGFnZ3JlZ2F0ZXMgPSBmLl9hZ2dyID09IFwiKlwiID8gb3B0LmFnZ3JMaXN0IDogZi5fYWdncjtcblxuICAgICAgICAgIGZvciAodmFyIGogaW4gYWdncmVnYXRlcykge1xuICAgICAgICAgICAgdmFyIGEgPSBhZ2dyZWdhdGVzW2pdO1xuICAgICAgICAgICAgaWYgKGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoaGFzQWdnciA9PT0gdHJ1ZSB8fCBoYXNBZ2dyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbXVzdCBiZSBhZ2dyZWdhdGVkLCBvciBubyBjb25zdHJhaW50XG4gICAgICAgICAgICAgICAgLy9zZXQgYWdncmVnYXRlIHRvIHRoYXQgb25lXG4gICAgICAgICAgICAgICAgdGZbaV0uYWdnciA9IGE7XG4gICAgICAgICAgICAgICAgYXNzaWduRmllbGQoaSArIDEsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpZihhID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIGlmIChoYXNBZ2dyID09PSBmYWxzZSB8fCBoYXNBZ2dyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbXVzdCBiZSByYXcgcGxvdCwgb3Igbm8gY29uc3RyYWludFxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZltpXS5hZ2dyO1xuICAgICAgICAgICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0LmdlbkJpbikge1xuICAgICAgICAgICAgLy8gYmluIHRoZSBmaWVsZCBpbnN0ZWFkIVxuICAgICAgICAgICAgZGVsZXRlIHRmW2ldLmFnZ3I7XG4gICAgICAgICAgICB0ZltpXS5iaW4gPSB0cnVlO1xuICAgICAgICAgICAgdGZbaV0udHlwZSA9IFwiUVwiO1xuICAgICAgICAgICAgYXNzaWduRmllbGQoaSArIDEsIGhhc0FnZ3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHQuZ2VuVHlwZUNhc3RpbmcpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbiBhbHNvIGNoYW5nZSBpdCB0byBkaW1lbnNpb24gKGNhc3QgdHlwZT1cIk9cIilcbiAgICAgICAgICAgIGRlbGV0ZSB0ZltpXS5hZ2dyO1xuICAgICAgICAgICAgZGVsZXRlIHRmW2ldLmJpbjtcbiAgICAgICAgICAgIHRmW2ldLnR5cGUgPSBcIk9cIjtcbiAgICAgICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCBoYXNBZ2dyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGJvdGggXCJhZ2dyXCIsIFwiX2FnZ3JcIiBub3QgaW4gZlxuICAgICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJPXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0ZltpXSA9IGY7XG4gICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCBoYXNBZ2dyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gIH1cblxuICBhc3NpZ25GaWVsZCgwLCBudWxsKTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLy9UT0RPKGthbml0dyk6IHdyaXRlIHRlc3QgY2FzZVxudmduLmdlbkZpZWxkRW5jb2RpbmdzID0gZnVuY3Rpb24oZW5jb2RpbmdzLCBmaWVsZHMsIG9wdCkgeyAvLyBnZW5lcmF0ZSBlbmNvZGluZ3MgKF9lbmMgcHJvcGVydHkgaW4gdmVnYSlcbiAgdmFyIHRtcEVuYyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGFzc2lnbkZpZWxkKGkpIHtcbiAgICAvLyBJZiBhbGwgZmllbGRzIGFyZSBhc3NpZ25lZCwgc2F2ZVxuICAgIGlmIChpID09PSBmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAvLyBhdCB0aGUgbWluaW1hbCBhbGwgY2hhcnQgc2hvdWxkIGhhdmUgeCwgeSwgZ2VvLCB0ZXh0IG9yIGFyY1xuICAgICAgaWYgKG1hcmtzUnVsZSh0bXBFbmMsIG9wdCkpIHtcbiAgICAgICAgZW5jb2RpbmdzLnB1c2godmwuZHVwbGljYXRlKHRtcEVuYykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgYXNzaWduIGktdGggZmllbGRcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgZm9yICh2YXIgaiBpbiBFTkNPRElOR19UWVBFUykge1xuICAgICAgdmFyIGV0ID0gRU5DT0RJTkdfVFlQRVNbal07XG5cbiAgICAgIC8vVE9ETzogc3VwcG9ydCBcIm11bHRpcGxlXCIgYXNzaWdubWVudFxuICAgICAgaWYgKCEoZXQgaW4gdG1wRW5jKSAmJlxuICAgICAgICAoRU5DT0RJTkdfUlVMRVNbZXRdLmRhdGFUeXBlcyAmIHZsLmRhdGFUeXBlc1tmaWVsZC50eXBlXSkgPiAwKSB7XG4gICAgICAgIHRtcEVuY1tldF0gPSBmaWVsZDtcbiAgICAgICAgYXNzaWduRmllbGQoaSArIDEpO1xuICAgICAgICBkZWxldGUgdG1wRW5jW2V0XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3NpZ25GaWVsZCgwKTtcblxuICByZXR1cm4gZW5jb2RpbmdzO1xufTtcblxuLy8gVVRJTElUWVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIHVuaW9uKGEsIGIpIHtcbiAgdmFyIG8gPSB7fTtcbiAgYS5mb3JFYWNoKGZ1bmN0aW9uKHgpeyBvW3hdID0gdHJ1ZTt9KTtcbiAgYi5mb3JFYWNoKGZ1bmN0aW9uKHgpeyBvW3hdID0gdHJ1ZTt9KTtcbiAgcmV0dXJuIHZsLmtleXMobyk7XG59XG5cbnZhciBhYnMgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT09IEluZmluaXR5KSB0aHJvdyBuZXcgRXJyb3IoXCJpbmZpbml0ZSByYW5nZVwiKTtcbiAgdmFyIHJhbmdlID0gW10sIGsgPSBkM19yYW5nZV9pbnRlZ2VyU2NhbGUoYWJzKHN0ZXApKSwgaSA9IC0xLCBqO1xuICBzdGFydCAqPSBrOyBzdG9wICo9IGs7IHN0ZXAgKj0gaztcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqIC8gayk7IGVsc2Ugd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA8IHN0b3ApIHJhbmdlLnB1c2goaiAvIGspO1xuICByZXR1cm4gcmFuZ2U7XG59XG5cbmZ1bmN0aW9uIGQzX3JhbmdlX2ludGVnZXJTY2FsZSh4KSB7XG4gIHZhciBrID0gMTtcbiAgd2hpbGUgKHggKiBrICUgMSkgayAqPSAxMDtcbiAgcmV0dXJuIGs7XG59IiwidmFyIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cudmwgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLnZsIDogbnVsbCk7XG5cbnZhciB2cmFuayA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vVE9ETyBsb3dlciBzY29yZSBpZiB3ZSB1c2UgRyBhcyBPP1xudmFyIEVOQ09ESU5HX1NDT1JFID0ge1xuICBROiB7XG4gICAgeDogMSxcbiAgICB5OiAxLFxuICAgIHNpemU6IDAuNiwgLy9GSVhNRSBTSVpFIGZvciBCYXIgaXMgaG9ycmlibGUhXG4gICAgY29sb3I6IDAuNCxcbiAgICBhbHBoYTogMC40XG4gIH0sXG4gIE86IHsgLy8gVE9ETyBuZWVkIHRvIHRha2UgY2FyZGluYWxpdHkgaW50byBhY2NvdW50XG4gICAgeDogMC45OSwgLy8gaGFyZGVyIHRvIHJlYWQgYXhpc1xuICAgIHk6IDEsXG4gICAgcm93OiAwLjcsXG4gICAgY29sOiAwLjcsXG4gICAgY29sb3I6IDAuOCxcbiAgICBzaGFwZTogMC42XG4gIH1cbn07XG5cbi8vIGJhZCBzY29yZSBub3Qgc3BlY2lmaWVkIGluIHRoZSB0YWJsZSBhYm92ZVxudmFyIEJBRF9FTkNPRElOR19TQ09SRSA9IDAuMDEsXG4gIFVOVVNFRF9QT1NJVElPTiA9IDAuNTtcblxudmFyIE1BUktfU0NPUkUgPSB7XG4gIGxpbmU6IDAuOTksXG4gIGFyZWE6IDAuOTgsXG4gIGJhcjogMC45NyxcbiAgcG9pbnQ6IDAuOTYsXG4gIGNpcmNsZTogMC45NSxcbiAgc3F1YXJlOiAwLjk1LFxuICB0ZXh0OiAwLjhcbn07XG5cbnZyYW5rLmVuY29kaW5nU2NvcmUgPSBmdW5jdGlvbihlbmNvZGluZyl7XG4gIHZhciBmZWF0dXJlcyA9IHt9LFxuICAgIGVuY1R5cGVzID0gdmwua2V5cyhlbmNvZGluZy5lbmMpO1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGVuY1R5cGUpe1xuICAgIHZhciBmaWVsZCA9IGVuY29kaW5nLmVuY1tlbmNUeXBlXTtcbiAgICBmZWF0dXJlc1tmaWVsZC5uYW1lXSA9IHtcbiAgICAgIHZhbHVlOiBmaWVsZC50eXBlK1wiOlwiK2VuY1R5cGUsXG4gICAgICBzY29yZTogRU5DT0RJTkdfU0NPUkVbZmllbGQudHlwZV1bZW5jVHlwZV0gfHwgQkFEX0VOQ09ESU5HX1NDT1JFXG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGVuYWxpemUgbm90IHVzaW5nIHBvc2l0aW9uYWxcbiAgaWYoZW5jVHlwZXMubGVuZ3RoID4gMSl7XG4gICAgaWYoKCFlbmNvZGluZy5lbmMueCB8fCAhZW5jb2RpbmcuZW5jLnkpICYmICFlbmNvZGluZy5lbmMuZ2VvKSB7XG4gICAgICBmZWF0dXJlcy51bnVzZWRQb3NpdGlvbiA9IHtzY29yZTogVU5VU0VEX1BPU0lUSU9OfTtcbiAgICB9XG4gIH1cblxuICBmZWF0dXJlcy5tYXJrVHlwZSA9IHtcbiAgICB2YWx1ZTogZW5jb2RpbmcubWFya3R5cGUsXG4gICAgc2NvcmU6IE1BUktfU0NPUkVbZW5jb2RpbmcubWFya3R5cGVdXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNjb3JlOiB2bC5rZXlzKGZlYXR1cmVzKS5yZWR1Y2UoZnVuY3Rpb24ocCwgcyl7IHJldHVybiBwICogZmVhdHVyZXNbc10uc2NvcmV9LCAxKSxcbiAgICBmZWF0dXJlczogZmVhdHVyZXNcbiAgfTtcbn07XG5cblxuLy8gcmF3ID4gYXZnLCBzdW0gPiBtaW4sbWF4ID4gYmluXG5cbnZyYW5rLmZpZWxkc1Njb3JlID0gZnVuY3Rpb24oZmllbGRzKXtcblxufTtcblxuIl19\n","var vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  clusterfck = (typeof window !== \"undefined\" ? window.clusterfck : typeof global !== \"undefined\" ? global.clusterfck : null);\n\nvar vgn = module.exports = {}; //VisGeN\n\nvgn.DEFAULT_OPT = {\n  genAggr: true,\n  genBin: true,\n  genTypeCasting: false,\n\n  aggrList: [undefined, \"avg\"], //undefined = no aggregation\n  marktypeList: [\"point\", \"bar\", \"line\", \"area\", \"text\"], //filled_map\n\n  // PRUNING RULES FOR ENCODING VARIATIONS\n\n  /**\n   * Eliminate all transpose\n   * - keeping horizontal dot plot only.\n   * - for OxQ charts, always put O on Y\n   * - show only one OxO, QxQ (currently sorted by name)\n   */\n  omitTranpose: true,\n  /** remove all dot plot with >1 encoding */\n  omitDotPlotWithExtraEncoding: true,\n\n  /** remove all aggregate charts with all dims on facets (row, col) */\n  //FIXME this is good for text though!\n  omitAggrWithAllDimsOnFacets: true,\n\n  // PRUNING RULES FOR TRANFORMATION VARIATIONS\n\n  /** omit field sets with only dimensions */\n  omitDimensionOnly: true,\n  /** omit aggregate field sets with only measures */\n  omitAggregateWithMeasureOnly: true\n\n};\n\nvar ENCODING_TYPES = vl.encodingTypes;\n\nvar CHART_TYPES = {\n  TABLE: 'TABLE',\n  BAR: 'BAR',\n  PLOT: 'PLOT',\n  LINE: 'LINE',\n  AREA: 'AREA',\n  MAP: 'MAP',\n  HISTOGRAM: 'HISTOGRAM'\n};\n\nvar ANY_DATA_TYPES = (1 << 4) - 1;\n\n//FIXME move these to vl\nvar AGGREGATION_FN = { //all possible aggregate function listed by each data type\n  Q: [\"avg\", \"sum\", \"min\", \"max\", \"count\"]\n};\n\nvar TRANSFORM_FN = { //all possible transform function listed by each data type\n  Q: [\"log\", \"sqrt\", \"abs\"], // \"logit?\"\n  T: [\"year\", \"month\", \"day\"] //,\"hr\", \"min\", \"bmon\", \"bday\", \"bdow\", \"bhr\"]\n};\n\nvar json = function(s,sp){ return JSON.stringify(s, null, sp);};\n\n// Begin of Distance\n\nvar DIST_BY_ENCTYPE = [\n    // positional\n    [\"x\", \"y\", 0.2],\n    [\"row\", \"col\", 0.2],\n\n    // ordinal mark properties\n    [\"color\", \"shape\", 0.2],\n\n    // quantitative mark properties\n    [\"color\", \"alpha\", 0.2],\n    [\"size\", \"alpha\", 0.2],\n    [\"size\", \"color\", 0.2]\n  ].reduce(function(r, x) {\n  var a=x[0], b=x[1], d=x[2];\n    r[a] = r[a] || {};\n    r[b] = r[b] || {};\n    r[a][b] = r[b][a] = d;\n    return r;\n  }, {}),\n  DIST_MISSING = 100, CLUSTER_THRESHOLD=1;\n\nfunction colenc(encoding) {\n  var _colenc = {},\n    enc = encoding.enc;\n\n  vl.keys(enc).forEach(function(encType) {\n    var e = vl.duplicate(enc[encType]);\n    e.type = encType;\n    _colenc[e.name || \"\"] = e;\n    delete e.name;\n  });\n\n  return {\n    marktype: encoding.marktype,\n    col: _colenc\n  };\n}\n\nvgn._getDistance = function(colenc1, colenc2) {\n  var cols = union(vl.keys(colenc1.col), vl.keys(colenc2.col)),\n    dist = 0;\n\n  cols.forEach(function(col) {\n    var e1 = colenc1.col[col], e2 = colenc2.col[col];\n\n    if (e1 && e2) {\n      if (e1.type != e2.type) {\n        dist += (DIST_BY_ENCTYPE[e1.type] || {})[e2.type] || 1;\n      }\n      //FIXME add aggregation\n    } else {\n      dist += DIST_MISSING;\n    }\n  });\n  return dist;\n};\n\nvgn.getDistanceTable = function(encodings) {\n  var len = encodings.length,\n    colencs = encodings.map(function(e){ return colenc(e);}),\n    diff = new Array(len), i;\n\n  for (i = 0; i < len; i++) diff[i] = new Array(len);\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      diff[j][i] = diff[i][j] = vgn._getDistance(colencs[i], colencs[j]);\n    }\n  }\n  return diff;\n};\n\nvgn.cluster = function(encodings, maxDistance) {\n  var dist = vgn.getDistanceTable(encodings),\n    n = encodings.length;\n\n  var clusterTrees = clusterfck.hcluster(range(n), function(i, j) {\n    return dist[i][j];\n  }, \"average\", CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n    return traverse(tree, []);\n  });\n\n  //console.log(\"clusters\", clusters.map(function(c){ return c.join(\"+\"); }));\n  return clusters;\n};\n\nfunction traverse(node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) traverse(node.left, arr);\n    if (node.right) traverse(node.right, arr);\n  }\n  return arr;\n}\n\n// End of Clustering\n\n\n// BEGINING OF RULES\n\n//TODO markTypesAggregateSupport\n\nvar marksRule = vgn.marksRule = generalRule;\nmarksRule.point = pointRule;\nmarksRule.bar = barRule;\nmarksRule.line = lineRule;\nmarksRule.area = lineRule;\n\nfunction isDim(field){\n  return field.bin || field.type === \"O\";\n}\n\nfunction xOyQ(enc) {\n  return enc.x && enc.y && isDim(enc.x) && isDim(enc.y);\n}\n\nfunction generalRule(enc, opt) {\n  // need at least one basic encoding\n  if (enc.x || enc.y || enc.geo || enc.text || enc.arc) {\n\n    if (enc.x && enc.y) {\n      // show only one OxO, QxQ\n      if (opt.omitTranpose && enc.x.type == enc.y.type) {\n        //TODO better criteria than name\n        if (enc.x.name > enc.y.name) return false;\n      }\n    }\n\n    if (enc.row || enc.col) { //have facet(s)\n      // don't use facets before filling up x,y\n      if ((!enc.x || !enc.y)) return false;\n\n      if (opt.omitAggrWithAllDimsOnFacets) {\n        // don't use facet with aggregate plot with other other ordinal on LOD\n\n        var hasAggr = false, hasOtherO = false;\n        for (var encType in enc) {\n          var field = enc[encType];\n          if (field.aggr) {\n            hasAggr = true;\n          }\n          if (isDim(field) && (encType !== \"row\" && encType !== \"col\")) {\n            hasOtherO = true;\n          }\n          if (hasAggr && hasOtherO) break;\n        }\n\n        if (hasAggr && !hasOtherO) return false;\n      }\n    }\n\n    // one dimension \"count\" is useless\n    if (enc.x && enc.x.aggr == \"count\" && !enc.y) return false;\n    if (enc.y && enc.y.aggr == \"count\" && !enc.x) return false;\n\n    return true;\n  }\n  return false;\n}\n\nfunction pointRule(enc, opt) {\n  if (enc.x && enc.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    // For OxQ\n    if (opt.omitTranpose && xOyQ(enc)) {\n      // if omitTranpose, put Q on X, O on Y\n      return false;\n    }\n\n    // For OxO\n    if (isDim(enc.x) && isDim(enc.y)) {\n      // shape doesn't work with both x, y as ordinal\n      if (enc.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (enc.color && isDim(enc.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (enc.shape) return false;\n  }\n  return true;\n}\n\nfunction barRule(enc, opt) {\n  // need to aggregate on either x or y\n  if ((enc.x.aggr !== undefined) ^ (enc.y.aggr !== undefined)) {\n\n    // if omitTranpose, put Q on X, O on Y\n    if (opt.omitTranpose && xOyQ(enc)) return false;\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction lineRule(enc, opt) {\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return enc.x == \"T\" && enc.y == \"Q\";\n}\n\nvar ENCODING_RULES = {\n  x: {\n    dataTypes: vl.dataTypes.O + vl.dataTypes.Q + vl.dataTypes.T,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dataTypes: vl.dataTypes.O + vl.dataTypes.Q + vl.dataTypes.T,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dataTypes: vl.dataTypes.O,\n    multiple: true\n  },\n  col: {\n    dataTypes: vl.dataTypes.O,\n    multiple: true\n  },\n  shape: {\n    dataTypes: vl.dataTypes.O\n  },\n  size: {\n    dataTypes: vl.dataTypes.Q\n  },\n  color: {\n    dataTypes: vl.dataTypes.O + vl.dataTypes.Q\n  },\n  alpha: {\n    dataTypes: vl.dataTypes.Q\n  },\n  text: {\n    dataTypes: ANY_DATA_TYPES\n  }\n  //geo: {\n  //  dataTypes: [vl.dataTypes.G]\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\n// END OF RULES\n\n// Beginning of Chart Generation\n\nvar nonEmpty = function(grp) {\n  return !isArray(grp) || grp.length > 0;\n};\n\nfunction nestedMap(col, f, level, filter) {\n  return level === 0 ?\n    col.map(f) :\n    col.map(function(v) {\n      var r = nestedMap(v, f, level - 1);\n      return filter ? r.filter(nonEmpty) : r;\n    });\n}\n\nfunction nestedReduce(col, f, level, filter) {\n  return level === 0 ?\n    col.reduce(f, []) :\n    col.map(function(v) {\n      var r = nestedReduce(v, f, level - 1);\n      return filter ? r.filter(nonEmpty) : r;\n    });\n}\n\nfunction getopt(opt) {\n  //merge with default\n  return (opt ? vl.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(vgn.DEFAULT_OPT));\n}\n\nvgn.generateCharts = function(fields, opt, cfg, flat) {\n  opt = getopt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? vgn.genAggregate([], fields, opt) : [fields],\n    encodings, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggr)) {\n    encodings = fieldSets.reduce(function(output, fields) {\n      return vgn.genFieldEncodings(output, fields, opt);\n    }, []);\n  } else {\n    encodings = fieldSets.map(function(fields) {\n      return vgn.genFieldEncodings([], fields, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = nestedReduce(encodings, function(output, encodings) {\n      return vgn.genMarkTypes(output, encodings, opt, cfg);\n    }, level, true);\n  } else {\n    charts = nestedMap(encodings, function(encodings) {\n      return vgn.genMarkTypes([], encodings, opt, cfg);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};\n\n\nvgn.genMarkTypes = function(output, enc, opt, cfg) {\n  opt = getopt(opt);\n  vgn._getSupportedMarkTypes(enc, opt)\n    .forEach(function(markType) {\n      output.push({ marktype: markType, enc: enc, cfg: cfg });\n    });\n  return output;\n};\n\n//TODO(kanitw): write test case\nvgn._getSupportedMarkTypes = function(enc, opt) {\n  var markTypes = opt.marktypeList.filter(function(markType) {\n    var mark = vl.marks[markType],\n      reqs = mark.requiredEncoding,\n      support = mark.supportedEncoding;\n\n    for (var i in reqs) { // all required encodings in enc\n      if (!(reqs[i] in enc)) return false;\n    }\n\n    for (var encType in enc) { // all encodings in enc are supported\n      if (!support[encType]) return false;\n    }\n\n    return !marksRule[markType] || marksRule[markType](enc, opt);\n  });\n\n  //console.log('enc:', json(enc), \" ~ marks:\", markTypes);\n\n  return markTypes;\n};\n\nvgn.genAggregate = function(output, fields, opt) {\n  var tf = new Array(fields.length);\n  opt = getopt(opt);\n\n  function assignField(i, hasAggr) {\n    // If all fields are assigned, save\n    if (i === fields.length) {\n      if(opt.omitAggregateWithMeasureOnly || opt.omitDimensionOnly){\n        var hasMeasure=false, hasDimension=false, hasRaw=false;\n        tf.forEach(function(f){\n          if (isDim(f)) {\n            hasDimension = true;\n          } else {\n            hasMeasure = true;\n            if(!f.aggr) hasRaw = true;\n          }\n        });\n        if(!hasMeasure && opt.omitDimensionOnly) return;\n        if(!hasDimension && !hasRaw && opt.omitAggregateWithMeasureOnly) return;\n      }\n\n      output.push(vl.duplicate(tf));\n      return;\n    }\n\n    var f = fields[i];\n\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case \"Q\":\n        tf[i] = {name: f.name, type: f.type};\n        if (f.aggr) {\n          tf[i].aggr = f.aggr;\n          assignField(i + 1, true);\n        } else if (f._aggr) {\n          var aggregates = f._aggr == \"*\" ? opt.aggrList : f._aggr;\n\n          for (var j in aggregates) {\n            var a = aggregates[j];\n            if (a !== undefined) {\n              if (hasAggr === true || hasAggr === null) {\n                // must be aggregated, or no constraint\n                //set aggregate to that one\n                tf[i].aggr = a;\n                assignField(i + 1, true);\n              }\n            } else { // if(a === undefined)\n              if (hasAggr === false || hasAggr === null) {\n                // must be raw plot, or no constraint\n                delete tf[i].aggr;\n                assignField(i + 1, false);\n              }\n            }\n          }\n\n          if (opt.genBin) {\n            // bin the field instead!\n            delete tf[i].aggr;\n            tf[i].bin = true;\n            tf[i].type = \"Q\";\n            assignField(i + 1, hasAggr);\n          }\n\n          if (opt.genTypeCasting) {\n            // we can also change it to dimension (cast type=\"O\")\n            delete tf[i].aggr;\n            delete tf[i].bin;\n            tf[i].type = \"O\";\n            assignField(i + 1, hasAggr);\n          }\n        } else { // both \"aggr\", \"_aggr\" not in f\n          assignField(i + 1, false);\n        }\n        break;\n\n      case \"O\":\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr);\n        break;\n    }\n\n  }\n\n  assignField(0, null);\n\n  return output;\n};\n\n//TODO(kanitw): write test case\nvgn.genFieldEncodings = function(encodings, fields, opt) { // generate encodings (_enc property in vega)\n  var tmpEnc = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fields.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (marksRule(tmpEnc, opt)) {\n        encodings.push(vl.duplicate(tmpEnc));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var field = fields[i];\n    for (var j in ENCODING_TYPES) {\n      var et = ENCODING_TYPES[j];\n\n      //TODO: support \"multiple\" assignment\n      if (!(et in tmpEnc) &&\n        (ENCODING_RULES[et].dataTypes & vl.dataTypes[field.type]) > 0) {\n        tmpEnc[et] = field;\n        assignField(i + 1);\n        delete tmpEnc[et];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encodings;\n};\n\n// UTILITY\n\nvar isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nfunction union(a, b) {\n  var o = {};\n  a.forEach(function(x){ o[x] = true;});\n  b.forEach(function(x){ o[x] = true;});\n  return vl.keys(o);\n}\n\nvar abs = Math.abs;\n\nfunction range(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n  var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;\n  start *= k; stop *= k; step *= k;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);\n  return range;\n}\n\nfunction d3_range_integerScale(x) {\n  var k = 1;\n  while (x * k % 1) k *= 10;\n  return k;\n}","var vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null);\n\nvar vrank = module.exports = {};\n\n//TODO lower score if we use G as O?\nvar ENCODING_SCORE = {\n  Q: {\n    x: 1,\n    y: 1,\n    size: 0.6, //FIXME SIZE for Bar is horrible!\n    color: 0.4,\n    alpha: 0.4\n  },\n  O: { // TODO need to take cardinality into account\n    x: 0.99, // harder to read axis\n    y: 1,\n    row: 0.7,\n    col: 0.7,\n    color: 0.8,\n    shape: 0.6\n  }\n};\n\n// bad score not specified in the table above\nvar BAD_ENCODING_SCORE = 0.01,\n  UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  point: 0.96,\n  circle: 0.95,\n  square: 0.95,\n  text: 0.8\n};\n\nvrank.encodingScore = function(encoding){\n  var features = {},\n    encTypes = vl.keys(encoding.enc);\n  encTypes.forEach(function(encType){\n    var field = encoding.enc[encType];\n    features[field.name] = {\n      value: field.type+\":\"+encType,\n      score: ENCODING_SCORE[field.type][encType] || BAD_ENCODING_SCORE\n    };\n  });\n\n  // penalize not using positional\n  if(encTypes.length > 1){\n    if((!encoding.enc.x || !encoding.enc.y) && !encoding.enc.geo) {\n      features.unusedPosition = {score: UNUSED_POSITION};\n    }\n  }\n\n  features.markType = {\n    value: encoding.marktype,\n    score: MARK_SCORE[encoding.marktype]\n  }\n\n  return {\n    score: vl.keys(features).reduce(function(p, s){ return p * features[s].score}, 1),\n    features: features\n  };\n};\n\n\n// raw > avg, sum > min,max > bin\n\nvrank.fieldsScore = function(fields){\n\n};\n\n"],"sourceRoot":"/source/"}